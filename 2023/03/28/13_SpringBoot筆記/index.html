<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>SpringBoot筆記 | Myblog</title>
  <meta name="keywords" content=" SpringBoot ">
  <meta name="description" content="SpringBoot筆記 | Myblog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="踩坑紀錄SpringBoot Data Jpa中新增數據到MySql報錯 Table &#39;msystem.hibernate_sequence&#39; doesn&#39;t exist 報錯原因：因為@GeneratedValue主鍵的生成策略，若不寫的話相當於@GeneratedValue(strategy&#x3D;GenerationType.AUTO)，但MySql是不支持的，Oracle">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot Data Jpa中新增數據到MySql報錯">
<meta property="og:url" content="https://ekerchung.github.io/2023/04/28/23_SpringBoot%20Data%20Jpa%E4%B8%AD%E6%96%B0%E5%A2%9E%E6%95%B8%E6%93%9A%E5%88%B0MySql%E5%A0%B1%E9%8C%AF/index.html">
<meta property="og:site_name" content="Myblog">
<meta property="og:description" content="踩坑紀錄SpringBoot Data Jpa中新增數據到MySql報錯 Table &#39;msystem.hibernate_sequence&#39; doesn&#39;t exist 報錯原因：因為@GeneratedValue主鍵的生成策略，若不寫的話相當於@GeneratedValue(strategy&#x3D;GenerationType.AUTO)，但MySql是不支持的，Oracle">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-04-28T04:05:16.450Z">
<meta property="article:modified_time" content="2023-04-28T08:33:40.066Z">
<meta property="article:author" content="Eker的編程筆記">
<meta property="article:tag" content="踩坑">
<meta property="article:tag" content="hibernate">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.4.2"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Eker的編程筆記</span>
</div>

<div class="icon">
    
        
    
        
            <a title="github"
               href="https://github.com/Ekerchung"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="linkedin"
               href="https://www.linkedin.com/in/yhc-b6a641155/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-linkedin"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:b8954008@gmail.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(24)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="自學筆記">
                        <i class="fold iconfont icon-right"></i>
                        
                        自學筆記
                        <small>(6)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="自學筆記<--->前端">
                                        
                                        前端
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="自學筆記<--->數據庫">
                                        
                                        數據庫
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="自學筆記<--->Spring">
                                        
                                        Spring
                                        
                                            <small>(4
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="前端">
                        <i class="fold iconfont icon-right"></i>
                        
                        前端
                        <small>(6)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="前端<--->Spring">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        Spring
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="前端<--->Spring踩坑">
                                                        
                                                        踩坑
                                                        
                                                            <small>(2)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="前端<--->Vue">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        Vue
                                        
                                            <small>(3
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="前端<--->Vue踩坑">
                                                        
                                                        踩坑
                                                        
                                                            <small>(3)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="後端">
                        <i class="fold iconfont icon-right"></i>
                        
                        後端
                        <small>(10)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="後端<--->Spring">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        Spring
                                        
                                            <small>(5
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="後端<--->Spring踩坑">
                                                        
                                                        踩坑
                                                        
                                                            <small>(4)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="後端<--->SpringBoot">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        SpringBoot
                                        
                                            <small>(5
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="後端<--->SpringBoot踩坑">
                                                        
                                                        踩坑
                                                        
                                                            <small>(5)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="數據庫">
                        <i class="fold iconfont icon-right"></i>
                        
                        數據庫
                        <small>(1)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="數據庫<--->踩坑">
                                        
                                        踩坑
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="https://ekerchung.github.io/">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="24">
<input type="hidden" id="yelog_site_word_count" value="140.7k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>踩坑</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>axios</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hibernate</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>mybatis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Mybatis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MySql</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Redis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spring</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Spring</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SpringBoot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>springMVC</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Thymeleaf</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Vue</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All 後端 SpringBoot 踩坑 "
           href="/2023/04/28/23_SpringBoot%20Data%20Jpa%E4%B8%AD%E6%96%B0%E5%A2%9E%E6%95%B8%E6%93%9A%E5%88%B0MySql%E5%A0%B1%E9%8C%AF/"
           data-tag="踩坑,hibernate"
           data-author="" >
            <span class="post-title" title="SpringBoot Data Jpa中新增數據到MySql報錯">SpringBoot Data Jpa中新增數據到MySql報錯</span>
            <span class="post-date" title="2023-04-28 12:05:16">2023/04/28</span>
        </a>
        
        
        <a  class="All 前端 Vue 踩坑 "
           href="/2023/04/27/22_%E4%BD%BF%E7%94%A8Vuex%E4%BF%9D%E5%AD%98%E6%95%B8%E6%93%9A%E5%BE%8C%EF%BC%8C%E5%88%B7%E6%96%B0%E9%A0%81%E9%9D%A2%E5%9C%96%E8%A1%A8%E6%B8%B2%E6%9F%93%E6%B2%92%E8%B3%87%E6%96%99/"
           data-tag="踩坑,Vue"
           data-author="" >
            <span class="post-title" title="使用Vuex保存數據後，刷新頁面圖表渲染沒資料">使用Vuex保存數據後，刷新頁面圖表渲染沒資料</span>
            <span class="post-date" title="2023-04-27 15:01:48">2023/04/27</span>
        </a>
        
        
        <a  class="All 後端 SpringBoot 踩坑 "
           href="/2023/04/25/21_SpringBoot%20Data%20Jpa%E4%B8%AD@OneToMany%E7%9A%84Lazy%E5%8A%A0%E8%BC%89%E5%95%8F%E9%A1%8C/"
           data-tag="踩坑,hibernate"
           data-author="" >
            <span class="post-title" title="SpringBoot Data Jpa中@OneToMany的Lazy加載問題">SpringBoot Data Jpa中@OneToMany的Lazy加載問題</span>
            <span class="post-date" title="2023-04-25 01:24:36">2023/04/25</span>
        </a>
        
        
        <a  class="All 後端 SpringBoot 踩坑 "
           href="/2023/04/24/20_SpringBoot%20+%20Vue%E5%89%8D%E5%BE%8C%E5%88%86%E9%9B%A2%E9%A0%85%E7%9B%AE%E5%9B%9E%E5%82%B3%E6%97%A5%E6%9C%9F%E5%B7%AE%E4%B8%80%E5%A4%A9(8hr)/"
           data-tag="踩坑,Vue,hibernate"
           data-author="" >
            <span class="post-title" title="SpringBoot + Vue前後分離項目回傳日期差一天(8hr)">SpringBoot + Vue前後分離項目回傳日期差一天(8hr)</span>
            <span class="post-date" title="2023-04-24 17:29:28">2023/04/24</span>
        </a>
        
        
        <a  class="All 後端 SpringBoot 踩坑 "
           href="/2023/04/21/19_SpringBoot%20Data%20Jpa%20%E7%B4%9A%E8%81%AF%E6%9F%A5%E8%A9%A2%E6%AD%BB%E5%BE%AA%E7%92%B0/"
           data-tag="踩坑,hibernate"
           data-author="" >
            <span class="post-title" title="SpringBoot Data Jpa 級聯查詢死循環">SpringBoot Data Jpa 級聯查詢死循環</span>
            <span class="post-date" title="2023-04-21 17:15:51">2023/04/21</span>
        </a>
        
        
        <a  class="All 後端 SpringBoot 踩坑 "
           href="/2023/04/21/18_hibernate%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AF%A6%E9%AB%94%E9%A1%9E%E5%B0%8D%E8%B1%A1%E7%84%A1%E6%B3%95%E8%BD%89JSON%E9%9F%BF%E6%87%89%E7%B5%A6%E5%89%8D%E7%AB%AF/"
           data-tag="踩坑,hibernate"
           data-author="" >
            <span class="post-title" title="hibernate返回的實體類對象無法轉JSON響應給前端">hibernate返回的實體類對象無法轉JSON響應給前端</span>
            <span class="post-date" title="2023-04-21 01:44:46">2023/04/21</span>
        </a>
        
        
        <a  class="All 前端 Vue 踩坑 "
           href="/2023/04/19/16_Vue%20Router%E8%8F%9C%E5%96%AE%E9%87%8D%E8%A4%87%E9%BB%9E%E6%93%8A-%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%A0%B1%E9%8C%AF/"
           data-tag="踩坑,Vue"
           data-author="" >
            <span class="post-title" title="Vue Router菜單重複點擊-控制台報錯">Vue Router菜單重複點擊-控制台報錯</span>
            <span class="post-date" title="2023-04-19 11:40:28">2023/04/19</span>
        </a>
        
        
        <a  class="All 前端 Vue 踩坑 "
           href="/2023/04/18/17_%E5%9F%B7%E8%A1%8CVue%E9%A0%85%E7%9B%AE%E5%A0%B1%E9%8C%AFerror_0308010C/"
           data-tag="踩坑,Vue"
           data-author="" >
            <span class="post-title" title="執行Vue項目報錯error_0308010C">執行Vue項目報錯error_0308010C</span>
            <span class="post-date" title="2023-04-18 00:37:45">2023/04/18</span>
        </a>
        
        
        <a  class="All 自學筆記 前端 "
           href="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/"
           data-tag="Vue"
           data-author="" >
            <span class="post-title" title="Vue筆記">Vue筆記</span>
            <span class="post-date" title="2023-04-17 10:05:06">2023/04/17</span>
        </a>
        
        
        <a  class="All 自學筆記 數據庫 "
           href="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis筆記">Redis筆記</span>
            <span class="post-date" title="2023-04-10 11:00:16">2023/04/10</span>
        </a>
        
        
        <a  class="All 自學筆記 Spring "
           href="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/"
           data-tag="SpringBoot"
           data-author="" >
            <span class="post-title" title="SpringBoot筆記">SpringBoot筆記</span>
            <span class="post-date" title="2023-03-28 11:00:16">2023/03/28</span>
        </a>
        
        
        <a  class="All 後端 Spring 踩坑 "
           href="/2023/03/12/12_Mybatis-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%94%A2%E7%94%9FMapper.xml%E6%9C%89%E8%AA%A4/"
           data-tag="Spring,踩坑,Mybatis"
           data-author="" >
            <span class="post-title" title="Mybatis-逆向工程產生Mapper.xml有誤">Mybatis-逆向工程產生Mapper.xml有誤</span>
            <span class="post-date" title="2023-03-12 00:55:45">2023/03/12</span>
        </a>
        
        
        <a  class="All 後端 Spring 踩坑 "
           href="/2023/03/10/11_Thymeleaf%E6%B8%B2%E6%9F%93%E6%95%B8%E6%93%9A%E5%BA%AB%E5%85%A7%E4%BF%9D%E5%AD%98%E7%9A%84%E6%99%82%E9%96%93/"
           data-tag="Spring,踩坑,Thymeleaf"
           data-author="" >
            <span class="post-title" title="Thymeleaf-渲染數據庫內保存的時間">Thymeleaf-渲染數據庫內保存的時間</span>
            <span class="post-date" title="2023-03-10 22:42:14">2023/03/10</span>
        </a>
        
        
        <a  class="All 數據庫 踩坑 "
           href="/2023/03/10/10_MySql%E4%BF%9D%E5%AD%98%E6%99%82%E9%96%93%E6%99%82%E5%8D%80%E5%95%8F%E9%A1%8C/"
           data-tag="踩坑,MySql"
           data-author="" >
            <span class="post-title" title="MySql-保存時間時區問題">MySql-保存時間時區問題</span>
            <span class="post-date" title="2023-03-10 22:20:25">2023/03/10</span>
        </a>
        
        
        <a  class="All 前端 "
           href="/2023/03/07/09_Vue%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9F%E7%9A%84confirm%20dialog/"
           data-tag="Vue"
           data-author="" >
            <span class="post-title" title="Vue使用原生的confirm dialog">Vue使用原生的confirm dialog</span>
            <span class="post-date" title="2023-03-07 15:37:59">2023/03/07</span>
        </a>
        
        
        <a  class="All 前端 Spring 踩坑 "
           href="/2023/03/07/08_Vue%E5%AF%A6%E7%8F%BE%E4%BD%BF%E7%94%A8%E8%B6%85%E9%80%A3%E7%B5%90%E7%99%BC%E9%80%81delete%E8%AB%8B%E6%B1%82/"
           data-tag="Spring,踩坑,Vue"
           data-author="" >
            <span class="post-title" title="Vue實現使用超連結發送delete請求">Vue實現使用超連結發送delete請求</span>
            <span class="post-date" title="2023-03-07 14:39:23">2023/03/07</span>
        </a>
        
        
        <a  class="All 前端 Spring 踩坑 "
           href="/2023/03/05/07_Vue+axios%E5%AF%A6%E7%8F%BE%E7%95%B0%E6%AD%A5%E8%AB%8B%E6%B1%82%E9%A9%97%E8%AD%89%E8%A8%BB%E5%86%8A%E8%A1%A8%E5%96%AE/"
           data-tag="Spring,踩坑,Vue,axios"
           data-author="" >
            <span class="post-title" title="Vue+axios實現異步請求驗證註冊表單">Vue+axios實現異步請求驗證註冊表單</span>
            <span class="post-date" title="2023-03-05 23:05:46">2023/03/05</span>
        </a>
        
        
        <a  class="All 後端 Spring 踩坑 "
           href="/2023/02/26/06_Spring-MySQL%E9%85%8D%E7%BD%AE%E5%A0%B1%E9%8C%AF/"
           data-tag="Spring,踩坑"
           data-author="" >
            <span class="post-title" title="Spring-MySQL配置報錯">Spring-MySQL配置報錯</span>
            <span class="post-date" title="2023-02-26 23:49:18">2023/02/26</span>
        </a>
        
        
        <a  class="All 後端 Spring 踩坑 "
           href="/2023/02/25/05_Mybatis-%E6%8F%92%E4%BB%B6mybatis-generator%E4%B8%8D%E9%A1%AF%E7%A4%BA/"
           data-tag="mybatis,Spring,踩坑"
           data-author="" >
            <span class="post-title" title="Mybatis-插件mybatis-generator不顯示">Mybatis-插件mybatis-generator不顯示</span>
            <span class="post-date" title="2023-02-25 00:28:36">2023/02/25</span>
        </a>
        
        
        <a  class="All 後端 Spring "
           href="/2023/02/23/04_SSM-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%95%B4%E5%90%88/"
           data-tag="mybatis,springMVC,spring"
           data-author="" >
            <span class="post-title" title="SSM-配置文件整合">SSM-配置文件整合</span>
            <span class="post-date" title="2023-02-23 16:39:00">2023/02/23</span>
        </a>
        
        
        <a  class="All 自學筆記 Spring "
           href="/2023/02/23/03_Spring%E7%AD%86%E8%A8%98/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="Spring筆記">Spring筆記</span>
            <span class="post-date" title="2023-02-23 16:39:00">2023/02/23</span>
        </a>
        
        
        <a  class="All 自學筆記 Spring "
           href="/2023/02/23/02_SpringMVC%E7%AD%86%E8%A8%98/"
           data-tag="springMVC"
           data-author="" >
            <span class="post-title" title="SpringMVC筆記">SpringMVC筆記</span>
            <span class="post-date" title="2023-02-23 16:39:00">2023/02/23</span>
        </a>
        
        
        <a  class="All 自學筆記 Spring "
           href="/2023/02/23/01_Mybatis%E7%AD%86%E8%A8%98/"
           data-tag="mybatis"
           data-author="" >
            <span class="post-title" title="Mybatis筆記">Mybatis筆記</span>
            <span class="post-date" title="2023-02-23 16:39:00">2023/02/23</span>
        </a>
        
        
        <a  class="All "
           href="/2023/02/23/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2023-02-23 16:37:11">2023/02/23</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-13_SpringBoot筆記" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">SpringBoot筆記</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="自學筆記">自學筆記</a> > 
            
            <a  data-rel="自學筆記&lt;---&gt;Spring">Spring</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color1">SpringBoot</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2023-03-28 11:22:50'>2023-03-28 11:00</time>
        
    </div>
    <div class="article-meta">
        
        <span>Count:33.9k</span>
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot2%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8"><span class="toc-text">SpringBoot2核心技术-基础入门</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#01%E3%80%81Spring%E8%88%87Springboot"><span class="toc-text">01、Spring與Springboot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Spring%E8%83%BD%E5%81%9A%E4%BB%80%E9%BA%BC"><span class="toc-text">1、Spring能做什麼?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Spring%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="toc-text">1.1 Spring的能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Spring%E7%9A%84%E7%94%9F%E6%80%81"><span class="toc-text">1.2 Spring的生态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Spring5%E9%87%8D%E5%A4%A7%E5%8D%87%E7%BA%A7"><span class="toc-text">1.3 Spring5重大升级</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-text">响应式编程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1"><span class="toc-text">内部源码设计</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8SpringBoot"><span class="toc-text">2、为什么用SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-SpringBoot%E4%BC%98%E7%82%B9"><span class="toc-text">2.1 SpringBoot优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-SpringBoot%E7%BC%BA%E7%82%B9"><span class="toc-text">2.2 SpringBoot缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%97%B6%E4%BB%A3%E8%83%8C%E6%99%AF"><span class="toc-text">3、时代背景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-text">3.1 微服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%88%86%E5%B8%83%E5%BC%8F"><span class="toc-text">3.2 分布式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%9B%B0%E9%9A%BE"><span class="toc-text">分布式的困难</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-text">分布式的解决</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%BA%91%E5%8E%9F%E7%94%9F"><span class="toc-text">3.3 云原生</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%BA%91%E7%9A%84%E5%9B%B0%E9%9A%BE"><span class="toc-text">上云的困难</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%BA%91%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-text">上云的解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%A6%82%E4%BD%95%E5%AD%B8%E7%BF%92SpringBoot"><span class="toc-text">4、如何學習SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%9E%B6%E6%9E%84"><span class="toc-text">4.1 官方文档架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E7%BD%91%E6%96%87%E6%A1%A3%E6%9E%B6%E6%9E%84"><span class="toc-text">官网文档架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#02%E3%80%81SpringBoot2%E5%85%A5%E9%96%80"><span class="toc-text">02、SpringBoot2入門</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%B3%BB%E7%BB%9F%E8%A6%81%E6%B1%82"><span class="toc-text">1、系统要求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Maven%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">1.1 Maven配置文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81HelloWorld%E9%A1%B9%E7%9B%AE"><span class="toc-text">2、HelloWorld项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%88%9B%E5%BB%BAmaven%E5%B7%A5%E7%A8%8B"><span class="toc-text">2.1 创建maven工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-text">2.2 引入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%88%9B%E5%BB%BA%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="toc-text">2.3 创建主程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%BC%96%E5%86%99%E4%B8%9A%E5%8A%A1"><span class="toc-text">2.4 编写业务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E8%BF%90%E8%A1%8C-amp-%E6%B5%8B%E8%AF%95"><span class="toc-text">2.5 运行&amp;测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E7%B0%A1%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="toc-text">2.6 簡化配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E7%B0%A1%E5%8C%96%E9%83%A8%E7%BD%B2"><span class="toc-text">2.7 簡化部署</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#03%E3%80%81%E4%BA%86%E8%A7%A3%E8%87%AA%E5%8B%95%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-text">03、了解自動配置原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-SpriingBoot%E7%89%B9%E9%BB%9E"><span class="toc-text">1. SpriingBoot特點</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="toc-text">1.1 依赖管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%89%B9%E6%80%A7"><span class="toc-text">1.2 自动配置特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%B9%E5%99%A8%E5%8A%9F%E8%83%BD"><span class="toc-text">2. 容器功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%B5%84%E4%BB%B6%E6%B7%BB%E5%8A%A0"><span class="toc-text">2.1 組件添加</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Configuration%E8%AF%A6%E8%A7%A3"><span class="toc-text">1. @Configuration详解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Bean%E3%80%81-Component%E3%80%81-Controller%E3%80%81-Service%E3%80%81-Repository"><span class="toc-text">2. @Bean、@Component、@Controller、@Service、@Repository</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-ComponentScan%E3%80%81-Import"><span class="toc-text">3. @ComponentScan、@Import</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Conditional"><span class="toc-text">4. @Conditional</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%8E%9F%E7%94%9F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%BC%95%E5%85%A5"><span class="toc-text">2.2 原生配置文件引入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-ImportResource"><span class="toc-text">1. @ImportResource</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A"><span class="toc-text">2.3 配置绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-ConfigurationProperties-Component"><span class="toc-text">1. @ConfigurationProperties + @Component</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-ConfigurationProperties-EnableConfigurationProperties"><span class="toc-text">2. @ConfigurationProperties + @EnableConfigurationProperties</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E5%85%A5%E9%96%80"><span class="toc-text">3. 自动配置原理入門</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%BC%95%E5%B0%8E%E5%8A%A0%E8%BC%89%E8%87%AA%E5%8B%95%E9%85%8D%E7%BD%AE%E9%A1%9E"><span class="toc-text">3.1 引導加載自動配置類</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-SpringBootConfiguration"><span class="toc-text">1. @SpringBootConfiguration</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-ComponentScan"><span class="toc-text">2. @ComponentScan</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-EnableAutoConfiguration"><span class="toc-text">3. @EnableAutoConfiguration</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a-AutoConfigurationPackage"><span class="toc-text">a. @AutoConfigurationPackage</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#b-Import-AutoConfigurationImportSelector-class"><span class="toc-text">b. @Import(AutoConfigurationImportSelector.class)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%8C%89%E9%9C%80%E9%96%8B%E5%95%9F%E8%87%AA%E5%8B%95%E9%85%8D%E7%BD%AE%E9%A0%85"><span class="toc-text">3.2 按需開啟自動配置項</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AA%8D%E9%85%8D%E7%BD%AE"><span class="toc-text">3.3 修改默認配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">3.4 最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%96%8B%E7%99%BC%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-text">4. 開發小技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Lombok"><span class="toc-text">4.1 Lombok</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-dev-tools"><span class="toc-text">4.2 dev-tools</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Spring-Initailizr"><span class="toc-text">4.3 Spring Initailizr</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-%E9%80%89%E6%8B%A9%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E7%9A%84%E5%BC%80%E5%8F%91%E5%9C%BA%E6%99%AF"><span class="toc-text">4.3.1 选择我们需要的开发场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-%E8%87%AA%E5%8A%A8%E4%BE%9D%E8%B5%96%E5%BC%95%E5%85%A5"><span class="toc-text">4.3.2 自动依赖引入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-text">4.3.3 自动创建项目结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-4-%E8%87%AA%E5%8A%A8%E7%BC%96%E5%86%99%E5%A5%BD%E4%B8%BB%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">4.3.4 自动编写好主配置类</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot2%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-text">SpringBoot2核心技术-核心功能</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#04%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">04、配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E9%A1%9E%E5%9E%8B"><span class="toc-text">1. 文件類型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-properties"><span class="toc-text">1.1 properties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-yaml"><span class="toc-text">1.2 yaml</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-%E7%B0%A1%E4%BB%8B"><span class="toc-text">1.2.1 簡介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">1.2.1 基本语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.2.3 数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-4-%E5%AE%9E%E4%BE%8B"><span class="toc-text">1.2.4 实例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%85%8D%E7%BD%AE%E6%8F%90%E7%A4%BA"><span class="toc-text">2. 配置提示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#05%E3%80%81web%E5%BC%80%E5%8F%91"><span class="toc-text">05、web开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-SpringMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%A6%82%E8%A7%88"><span class="toc-text">1. SpringMVC自动配置概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%80%E5%8D%95%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">2. 简单功能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%9D%9C%E6%85%8B%E8%B3%87%E6%BA%90%E8%A8%AA%E5%95%8F"><span class="toc-text">2.1 靜態資源訪問</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95"><span class="toc-text">2.1.1 静态资源目录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-2-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%89%8D%E7%BC%80"><span class="toc-text">2.1.2 静态资源访问前缀</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-3-webjar"><span class="toc-text">2.1.3 webjar</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%AC%A2%E8%BF%8E%E9%A1%B5%E6%94%AF%E6%8C%81"><span class="toc-text">2.2 欢迎页支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%87%AA%E5%AE%9A%E4%B9%89Favicon"><span class="toc-text">2.3 自定义Favicon</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86-%E2%80%93-%E5%8E%9F%E7%A2%BC%E8%A7%A3%E6%9E%90"><span class="toc-text">2.4 静态资源配置原理 – (原碼解析)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-1-%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">2.4.1 配置类只有一个有参构造器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-2-%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99"><span class="toc-text">2.4.2 资源处理的默认规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-3-%E6%AC%A2%E8%BF%8E%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E8%A7%84%E5%88%99"><span class="toc-text">2.4.3 欢迎页的处理规则</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AB%8B%E6%B1%82%E5%8F%83%E6%95%B8%E8%99%95%E7%90%86"><span class="toc-text">3. 請求參數處理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84"><span class="toc-text">3.1 请求映射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-rest%E4%BD%BF%E7%94%A8%E8%88%87%E5%8E%9F%E7%90%86"><span class="toc-text">3.1.1 rest使用與原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2-%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86"><span class="toc-text">3.1.2 请求映射原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%99%AE%E9%80%9A%E5%8F%82%E6%95%B0%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3"><span class="toc-text">3.2 普通参数与基本注解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-%E6%B3%A8%E8%A7%A3%EF%BC%9A"><span class="toc-text">3.2.1 注解：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-Servlet-API%EF%BC%9A"><span class="toc-text">3.2.2 Servlet API：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-%E5%A4%8D%E6%9D%82%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="toc-text">3.2.3 复杂参数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="toc-text">3.2.4 自定义对象参数：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-POJO%E5%B0%81%E8%A3%85%E8%BF%87%E7%A8%8B"><span class="toc-text">3.3 POJO封装过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%8F%83%E6%95%B8%E8%99%95%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-text">3.4 參數處理原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-1-HandlerAdapter"><span class="toc-text">3.4.1 HandlerAdapter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-2-%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95"><span class="toc-text">3.4.2 执行目标方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-3-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8-HandlerMethodArgumentResolver"><span class="toc-text">3.4.3 参数解析器-HandlerMethodArgumentResolver</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-4-%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">3.4.4 返回值处理器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-5-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC"><span class="toc-text">3.4.5 如何确定目标方法每一个参数的值</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-4-5-1%E3%80%81%E6%8C%A8%E4%B8%AA%E5%88%A4%E6%96%AD%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8%E9%82%A3%E4%B8%AA%E6%94%AF%E6%8C%81%E8%A7%A3%E6%9E%90%E8%BF%99%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-text">3.4.5.1、挨个判断所有参数解析器那个支持解析这个参数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-4-5-2%E3%80%81%E8%A7%A3%E6%9E%90%E8%BF%99%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC"><span class="toc-text">3.4.5.2、解析这个参数的值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-4-5-3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0-%E5%B0%81%E8%A3%85POJO"><span class="toc-text">3.4.5.3、自定义类型参数 封装POJO</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-6-%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%88%90"><span class="toc-text">3.4.6 目标方法执行完成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-7-%E5%A4%84%E7%90%86%E6%B4%BE%E5%8F%91%E7%BB%93%E6%9E%9C"><span class="toc-text">3.4.7 处理派发结果</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E4%B8%8E%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86"><span class="toc-text">4. 数据响应与内容协商</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E9%9F%BF%E6%87%89JSON"><span class="toc-text">4.1 響應JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-1-jackson-jar-ResponseBody"><span class="toc-text">4.1.1 jackson.jar+@ResponseBody</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-text">1. 返回值解析器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A7%A3%E6%9E%90%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-text">2、返回值解析器原理</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2%E3%80%81SpringMVC%E5%88%B0%E5%BA%95%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">4.1.2、SpringMVC到底支持哪些返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-3%E3%80%81HTTPMessageConverter%E5%8E%9F%E7%90%86"><span class="toc-text">4.1.3、HTTPMessageConverter原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81MessageConverter%E8%A7%84%E8%8C%83"><span class="toc-text">1、MessageConverter规范</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E9%BB%98%E8%AE%A4%E7%9A%84MessageConverter"><span class="toc-text">2、默认的MessageConverter</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86"><span class="toc-text">4.2 内容协商</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-%E5%BC%95%E5%85%A5XML%E4%BE%9D%E8%B5%96%EF%BC%9A"><span class="toc-text">4.2.1 引入XML依赖：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-postman%E5%88%86%E5%88%AB%E6%B5%8B%E8%AF%95%E8%BF%94%E5%9B%9Ejson%E5%92%8Cxml"><span class="toc-text">4.2.2 postman分别测试返回json和xml</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-3-%E5%BC%80%E5%90%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%82%E6%95%B0%E6%96%B9%E5%BC%8F%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E5%8A%9F%E8%83%BD"><span class="toc-text">4.2.3 开启浏览器参数方式内容协商功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-4-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E5%8E%9F%E7%90%86"><span class="toc-text">4.2.4 内容协商原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-5-%E8%87%AA%E5%AE%9A%E4%B9%89-MessageConverter"><span class="toc-text">4.2.5 自定义 MessageConverter</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E"><span class="toc-text">5. 视图解析与模板引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E8%A6%96%E5%9C%96%E8%A7%A3%E6%9E%90"><span class="toc-text">5.1 視圖解析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86%E6%B5%81%E7%A8%8B-%E3%80%90%E6%BA%90%E7%A2%BC%E8%A7%A3%E6%9E%90%E3%80%91"><span class="toc-text">5.1.1视图解析原理流程 【源碼解析】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E-Thymeleaf"><span class="toc-text">5.2 模板引擎-Thymeleaf</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-1-thymeleaf%E7%AE%80%E4%BB%8B"><span class="toc-text">5.2.1 thymeleaf简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-2-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">5.2.2 基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">1、表达式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">2、字面量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E3%80%81%E6%96%87%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">3、文本操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="toc-text">4、数学运算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5%E3%80%81%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97"><span class="toc-text">5、布尔运算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6%E3%80%81%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97"><span class="toc-text">6、比较运算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7%E3%80%81%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97"><span class="toc-text">7、条件运算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8%E3%80%81%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C"><span class="toc-text">8、特殊操作</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-3-%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%80%BC-th-attr"><span class="toc-text">5.2.3 设置属性值-th:attr</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-4-%E8%BF%AD%E4%BB%A3"><span class="toc-text">5.2.4 迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-5-%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97"><span class="toc-text">5.2.5 条件运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-6-%E5%B1%9E%E6%80%A7%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">5.2.6 属性优先级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-thymeleaf%E4%BD%BF%E7%94%A8"><span class="toc-text">5.3 thymeleaf使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-1-%E5%BC%95%E5%85%A5Starter"><span class="toc-text">5.3.1 引入Starter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-2-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%A5%BD%E4%BA%86thymeleaf"><span class="toc-text">5.3.2 自动配置好了thymeleaf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-3-%E9%A0%81%E9%9D%A2%E9%96%8B%E7%99%BC"><span class="toc-text">5.3.3 頁面開發</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%A7%8B%E5%BB%BA%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">5.4 構建后台管理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-1-%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA"><span class="toc-text">5.4.1 项目创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-2-%E9%9D%9C%E6%85%8B%E8%B3%87%E6%BA%90%E8%99%95%E7%90%86"><span class="toc-text">5.4.2 靜態資源處理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-3-%E8%B7%AF%E5%BE%91%E6%A7%8B%E5%BB%BA"><span class="toc-text">5.4.3 路徑構建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-4-%E6%A8%A1%E6%9D%BF%E6%8A%BD%E5%8F%96"><span class="toc-text">5.4.4 模板抽取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-5-%E9%A0%81%E9%9D%A2%E8%B7%B3%E8%BD%89"><span class="toc-text">5.4.5 頁面跳轉</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-6-%E6%95%B8%E6%93%9A%E6%B8%B2%E6%9F%93"><span class="toc-text">5.4.6 數據渲染</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">6. 拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-HandlerInterceptor-%E6%8E%A5%E5%8F%A3"><span class="toc-text">6.1 HandlerInterceptor 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E9%85%8D%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">6.2 配置拦截器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-text">6.3 拦截器原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-text">7. 文件上传</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E9%A1%B5%E9%9D%A2%E8%A1%A8%E5%8D%95"><span class="toc-text">7.1 页面表单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81"><span class="toc-text">7.2 文件上传代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E3%80%90%E6%BA%90%E7%A2%BC%E8%A7%A3%E6%9E%90%E3%80%91"><span class="toc-text">7.3 自动配置原理【源碼解析】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">8. 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99"><span class="toc-text">8.1 默认规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%AE%9A%E5%88%B6%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">8.2 定制错误处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-text">8.3 异常处理自动配置原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4%E6%B5%81%E7%A8%8B"><span class="toc-text">8.4 异常处理步骤流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Web%E5%8E%9F%E7%94%9F%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%85%A5%EF%BC%88Servlet%E3%80%81Filter%E3%80%81Listener%EF%BC%89"><span class="toc-text">9. Web原生组件注入（Servlet、Filter、Listener）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E4%BD%BF%E7%94%A8Servlet-API-%E6%8E%A8%E8%96%A6%E4%BD%BF%E7%94%A8"><span class="toc-text">9.1 使用Servlet API (推薦使用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E4%BD%BF%E7%94%A8RegistrationBean"><span class="toc-text">9.2 使用RegistrationBean</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8"><span class="toc-text">10. 嵌入式Servlet容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%88%87%E6%8D%A2%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8"><span class="toc-text">10.1 切换嵌入式Servlet容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%AE%9A%E5%88%B6Servlet%E5%AE%B9%E5%99%A8"><span class="toc-text">10.2 定制Servlet容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%AE%9A%E5%88%B6%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-text">11 定制化原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E5%AE%9A%E5%88%B6%E5%8C%96%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F"><span class="toc-text">11.1 定制化的常见方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%A5%97%E8%B7%AF"><span class="toc-text">11.2 原理分析套路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#06%E3%80%81%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="toc-text">06、数据访问</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-SQL"><span class="toc-text">1. SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE-HikariDataSource"><span class="toc-text">1.1 数据源的自动配置-HikariDataSource</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-%E5%AF%BC%E5%85%A5JDBC%E5%9C%BA%E6%99%AF"><span class="toc-text">1.1.1 导入JDBC场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-%E5%88%86%E6%9E%90%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">1.1.2 分析自动配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-3-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-text">1.1.3 修改配置项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-4-%E5%96%AE%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">1.1.4 單元测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BD%BF%E7%94%A8Druid%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-text">1.2 使用Druid数据源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-druid%E5%AE%98%E6%96%B9github%E5%9C%B0%E5%9D%80"><span class="toc-text">1.2.1 druid官方github地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-text">1.2.2 自定义方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-text">1、创建数据源</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E9%85%8D%E7%BD%AEDruid%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B5%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-text">2、配置Druid的监控页功能：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-%E4%BD%BF%E7%94%A8%E5%AE%98%E6%96%B9starter%E6%96%B9%E5%BC%8F"><span class="toc-text">1.2.3 使用官方starter方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E5%BC%95%E5%85%A5druid-starter"><span class="toc-text">1、引入druid-starter</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E5%88%86%E6%9E%90%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">2、分析自动配置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E3%80%81%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B"><span class="toc-text">3、配置示例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%95%B4%E5%90%88MyBatis%E6%93%8D%E4%BD%9C"><span class="toc-text">1.3 整合MyBatis操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-1-%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.3.1 配置模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-%E6%B3%A8%E8%A7%A3%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.3.2 注解模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-3-%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.3.3 混合模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%95%B4%E5%90%88-MyBatis-Plus-%E5%AE%8C%E6%88%90CRUD"><span class="toc-text">1.4 整合 MyBatis-Plus 完成CRUD</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-1-%E4%BB%80%E4%B9%88%E6%98%AFMyBatis-Plus"><span class="toc-text">1.4.1 什么是MyBatis-Plus</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-2-%E6%95%B4%E5%90%88MyBatis-Plus"><span class="toc-text">1.4.2 整合MyBatis-Plus</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-3-CRUD%E5%8A%9F%E8%83%BD"><span class="toc-text">1.4.3 CRUD功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-4-%E6%B7%BB%E5%8A%A0%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%EF%BC%9A"><span class="toc-text">1.4.4 添加分页插件：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81NoSQL"><span class="toc-text">2、NoSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Redis%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">2.1 Redis自动配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-RedisTemplate%E4%B8%8ELettuce"><span class="toc-text">2.2 RedisTemplate与Lettuce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%88%87%E6%8D%A2%E8%87%B3jedis"><span class="toc-text">2.3 切换至jedis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Redis%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B"><span class="toc-text">2.4 Redis操作示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#07%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">07、单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JUnit5-%E7%9A%84%E8%AE%8A%E5%8C%96"><span class="toc-text">1. JUnit5 的變化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-JUnit5-%E5%B8%B8%E7%94%A8%E6%B5%8B%E8%AF%95%E6%B3%A8%E8%A7%A3"><span class="toc-text">2. JUnit5 常用测试注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%96%AD%E8%A8%80%E6%9C%BA%E5%88%B6-assertions"><span class="toc-text">3. 断言机制 ( assertions )</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%AE%80%E5%8D%95%E6%96%AD%E8%A8%80"><span class="toc-text">3.1 简单断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%95%B0%E7%BB%84%E6%96%AD%E8%A8%80"><span class="toc-text">3.2 数组断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BB%84%E5%90%88%E6%96%AD%E8%A8%80"><span class="toc-text">3.3 组合断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80"><span class="toc-text">3.4 异常断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E8%B6%85%E6%97%B6%E6%96%AD%E8%A8%80"><span class="toc-text">3.5 超时断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5"><span class="toc-text">3.6 快速失败</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6%EF%BC%88assumptions%EF%BC%89"><span class="toc-text">4. 前置条件（assumptions）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B5%8C%E5%A5%97%E6%B5%8B%E8%AF%95"><span class="toc-text">5. 嵌套测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="toc-text">6. 参数化测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97"><span class="toc-text">7. 迁移指南</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#08%E3%80%81%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7"><span class="toc-text">08、指标监控</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-SpringBoot-Actuator"><span class="toc-text">1. SpringBoot Actuator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%B0%A1%E4%BB%8B"><span class="toc-text">1.1 簡介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-x%E4%B8%8E2-x%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="toc-text">1.2 1.x与2.x的不同：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-text">1.3 如何使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%8F%AF%E8%A6%96%E5%8C%96-%E7%95%A5"><span class="toc-text">1.4 可視化 (略)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Actuator-Endpoint"><span class="toc-text">2. Actuator Endpoint</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84%E7%AB%AF%E7%82%B9"><span class="toc-text">2.1 常使用的端点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Health-Endpoint"><span class="toc-text">2.2 Health Endpoint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Metrics-Endpoint"><span class="toc-text">2.3 Metrics Endpoint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%AE%A1%E7%90%86Endpoints"><span class="toc-text">2.4. 管理Endpoints</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-1-%E5%BC%80%E5%90%AF%E4%B8%8E%E7%A6%81%E7%94%A8Endpoints"><span class="toc-text">2.4.1 开启与禁用Endpoints</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-2-%E6%9A%B4%E9%9C%B2Endpoints"><span class="toc-text">2.4.2 暴露Endpoints</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7-%E5%AE%9A%E5%88%B6Endpoint"><span class="toc-text">3. 指标监控-定制Endpoint</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9A%E5%88%B6-Health-%E4%BF%A1%E6%81%AF"><span class="toc-text">3.1 定制 Health 信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AE%9A%E5%88%B6info%E4%BF%A1%E6%81%AF"><span class="toc-text">3.2 定制info信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%AE%9A%E5%88%B6Metrics%E4%BF%A1%E6%81%AF"><span class="toc-text">3.3 定制Metrics信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-SpringBoot%E6%94%AF%E6%8C%81%E8%87%AA%E5%8A%A8%E9%80%82%E9%85%8D%E7%9A%84Metrics"><span class="toc-text">3.3.1 SpringBoot支持自动适配的Metrics</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-%E5%A2%9E%E5%8A%A0%E5%AE%9A%E5%88%B6Metrics%EF%BC%9A"><span class="toc-text">3.3.2 增加定制Metrics：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%AE%9A%E5%88%B6Endpoint"><span class="toc-text">3.4 定制Endpoint</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#09%E3%80%81%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-text">09、原理解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Profile%E5%8A%9F%E8%83%BD"><span class="toc-text">1. Profile功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-application-profile%E5%8A%9F%E8%83%BD"><span class="toc-text">1.1 application-profile功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Profile%E6%9D%A1%E4%BB%B6%E8%A3%85%E9%85%8D%E5%8A%9F%E8%83%BD"><span class="toc-text">1.2 @Profile条件装配功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-profile%E5%88%86%E7%BB%84"><span class="toc-text">1.3 profile分组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="toc-text">2. 外部化配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%A4%96%E9%83%A8%E9%85%8D%E7%BD%AE%E6%BA%90"><span class="toc-text">2.1 外部配置源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%BB%98%E8%AA%8D%E6%9F%A5%E6%89%BE%E4%BD%8D%E7%BD%AE"><span class="toc-text">2.2 配置文件默認查找位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="toc-text">2.3 配置文件加载顺序：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89starter%E7%BB%86%E8%8A%82"><span class="toc-text">3. 自定义starter细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-starter%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86"><span class="toc-text">3.1 starter启动原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%87%AA%E5%AE%9A%E4%B9%89starter"><span class="toc-text">3.2 自定义starter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-SpringBoot%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-text">4. SpringBoot原理解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-SpringBoot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">4.1 SpringBoot启动过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%87%AA%E5%AE%9A%E7%BE%A9%E4%BA%8B%E4%BB%B6%E7%9B%A3%E8%81%BD%E7%B5%84%E4%BB%B6"><span class="toc-text">5. 自定義事件監聽組件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#star-%E5%B0%9A%E6%9C%AA%E5%AD%B8%E7%BF%92"><span class="toc-text">:star:尚未學習</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot2%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8"><span class="toc-text">SpringBoot2核心技术-基础入门</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#01%E3%80%81Spring%E8%88%87Springboot"><span class="toc-text">01、Spring與Springboot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Spring%E8%83%BD%E5%81%9A%E4%BB%80%E9%BA%BC"><span class="toc-text">1、Spring能做什麼?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Spring%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="toc-text">1.1 Spring的能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Spring%E7%9A%84%E7%94%9F%E6%80%81"><span class="toc-text">1.2 Spring的生态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Spring5%E9%87%8D%E5%A4%A7%E5%8D%87%E7%BA%A7"><span class="toc-text">1.3 Spring5重大升级</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-text">响应式编程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1"><span class="toc-text">内部源码设计</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8SpringBoot"><span class="toc-text">2、为什么用SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-SpringBoot%E4%BC%98%E7%82%B9"><span class="toc-text">2.1 SpringBoot优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-SpringBoot%E7%BC%BA%E7%82%B9"><span class="toc-text">2.2 SpringBoot缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%97%B6%E4%BB%A3%E8%83%8C%E6%99%AF"><span class="toc-text">3、时代背景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-text">3.1 微服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%88%86%E5%B8%83%E5%BC%8F"><span class="toc-text">3.2 分布式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%9B%B0%E9%9A%BE"><span class="toc-text">分布式的困难</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-text">分布式的解决</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%BA%91%E5%8E%9F%E7%94%9F"><span class="toc-text">3.3 云原生</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%BA%91%E7%9A%84%E5%9B%B0%E9%9A%BE"><span class="toc-text">上云的困难</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%BA%91%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-text">上云的解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%A6%82%E4%BD%95%E5%AD%B8%E7%BF%92SpringBoot"><span class="toc-text">4、如何學習SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%9E%B6%E6%9E%84"><span class="toc-text">4.1 官方文档架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E7%BD%91%E6%96%87%E6%A1%A3%E6%9E%B6%E6%9E%84"><span class="toc-text">官网文档架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#02%E3%80%81SpringBoot2%E5%85%A5%E9%96%80"><span class="toc-text">02、SpringBoot2入門</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%B3%BB%E7%BB%9F%E8%A6%81%E6%B1%82"><span class="toc-text">1、系统要求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Maven%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">1.1 Maven配置文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81HelloWorld%E9%A1%B9%E7%9B%AE"><span class="toc-text">2、HelloWorld项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%88%9B%E5%BB%BAmaven%E5%B7%A5%E7%A8%8B"><span class="toc-text">2.1 创建maven工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-text">2.2 引入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%88%9B%E5%BB%BA%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="toc-text">2.3 创建主程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%BC%96%E5%86%99%E4%B8%9A%E5%8A%A1"><span class="toc-text">2.4 编写业务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E8%BF%90%E8%A1%8C-amp-%E6%B5%8B%E8%AF%95"><span class="toc-text">2.5 运行&amp;测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E7%B0%A1%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="toc-text">2.6 簡化配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E7%B0%A1%E5%8C%96%E9%83%A8%E7%BD%B2"><span class="toc-text">2.7 簡化部署</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#03%E3%80%81%E4%BA%86%E8%A7%A3%E8%87%AA%E5%8B%95%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-text">03、了解自動配置原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-SpriingBoot%E7%89%B9%E9%BB%9E"><span class="toc-text">1. SpriingBoot特點</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="toc-text">1.1 依赖管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%89%B9%E6%80%A7"><span class="toc-text">1.2 自动配置特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%B9%E5%99%A8%E5%8A%9F%E8%83%BD"><span class="toc-text">2. 容器功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%B5%84%E4%BB%B6%E6%B7%BB%E5%8A%A0"><span class="toc-text">2.1 組件添加</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Configuration%E8%AF%A6%E8%A7%A3"><span class="toc-text">1. @Configuration详解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Bean%E3%80%81-Component%E3%80%81-Controller%E3%80%81-Service%E3%80%81-Repository"><span class="toc-text">2. @Bean、@Component、@Controller、@Service、@Repository</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-ComponentScan%E3%80%81-Import"><span class="toc-text">3. @ComponentScan、@Import</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Conditional"><span class="toc-text">4. @Conditional</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%8E%9F%E7%94%9F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%BC%95%E5%85%A5"><span class="toc-text">2.2 原生配置文件引入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-ImportResource"><span class="toc-text">1. @ImportResource</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%85%8D%E7%BD%AE%E7%BB%91%E5%AE%9A"><span class="toc-text">2.3 配置绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-ConfigurationProperties-Component"><span class="toc-text">1. @ConfigurationProperties + @Component</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-ConfigurationProperties-EnableConfigurationProperties"><span class="toc-text">2. @ConfigurationProperties + @EnableConfigurationProperties</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E5%85%A5%E9%96%80"><span class="toc-text">3. 自动配置原理入門</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%BC%95%E5%B0%8E%E5%8A%A0%E8%BC%89%E8%87%AA%E5%8B%95%E9%85%8D%E7%BD%AE%E9%A1%9E"><span class="toc-text">3.1 引導加載自動配置類</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-SpringBootConfiguration"><span class="toc-text">1. @SpringBootConfiguration</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-ComponentScan"><span class="toc-text">2. @ComponentScan</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-EnableAutoConfiguration"><span class="toc-text">3. @EnableAutoConfiguration</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#a-AutoConfigurationPackage"><span class="toc-text">a. @AutoConfigurationPackage</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#b-Import-AutoConfigurationImportSelector-class"><span class="toc-text">b. @Import(AutoConfigurationImportSelector.class)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%8C%89%E9%9C%80%E9%96%8B%E5%95%9F%E8%87%AA%E5%8B%95%E9%85%8D%E7%BD%AE%E9%A0%85"><span class="toc-text">3.2 按需開啟自動配置項</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AA%8D%E9%85%8D%E7%BD%AE"><span class="toc-text">3.3 修改默認配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">3.4 最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%96%8B%E7%99%BC%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-text">4. 開發小技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Lombok"><span class="toc-text">4.1 Lombok</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-dev-tools"><span class="toc-text">4.2 dev-tools</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Spring-Initailizr"><span class="toc-text">4.3 Spring Initailizr</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-1-%E9%80%89%E6%8B%A9%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E7%9A%84%E5%BC%80%E5%8F%91%E5%9C%BA%E6%99%AF"><span class="toc-text">4.3.1 选择我们需要的开发场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-2-%E8%87%AA%E5%8A%A8%E4%BE%9D%E8%B5%96%E5%BC%95%E5%85%A5"><span class="toc-text">4.3.2 自动依赖引入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-3-%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-text">4.3.3 自动创建项目结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-4-%E8%87%AA%E5%8A%A8%E7%BC%96%E5%86%99%E5%A5%BD%E4%B8%BB%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-text">4.3.4 自动编写好主配置类</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot2%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-text">SpringBoot2核心技术-核心功能</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#04%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">04、配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E9%A1%9E%E5%9E%8B"><span class="toc-text">1. 文件類型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-properties"><span class="toc-text">1.1 properties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-yaml"><span class="toc-text">1.2 yaml</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-%E7%B0%A1%E4%BB%8B"><span class="toc-text">1.2.1 簡介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">1.2.1 基本语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.2.3 数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-4-%E5%AE%9E%E4%BE%8B"><span class="toc-text">1.2.4 实例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%85%8D%E7%BD%AE%E6%8F%90%E7%A4%BA"><span class="toc-text">2. 配置提示</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#05%E3%80%81web%E5%BC%80%E5%8F%91"><span class="toc-text">05、web开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-SpringMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%A6%82%E8%A7%88"><span class="toc-text">1. SpringMVC自动配置概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AE%80%E5%8D%95%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">2. 简单功能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E9%9D%9C%E6%85%8B%E8%B3%87%E6%BA%90%E8%A8%AA%E5%95%8F"><span class="toc-text">2.1 靜態資源訪問</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95"><span class="toc-text">2.1.1 静态资源目录</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-2-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%89%8D%E7%BC%80"><span class="toc-text">2.1.2 静态资源访问前缀</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-3-webjar"><span class="toc-text">2.1.3 webjar</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%AC%A2%E8%BF%8E%E9%A1%B5%E6%94%AF%E6%8C%81"><span class="toc-text">2.2 欢迎页支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%87%AA%E5%AE%9A%E4%B9%89Favicon"><span class="toc-text">2.3 自定义Favicon</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86-%E2%80%93-%E5%8E%9F%E7%A2%BC%E8%A7%A3%E6%9E%90"><span class="toc-text">2.4 静态资源配置原理 – (原碼解析)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-1-%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">2.4.1 配置类只有一个有参构造器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-2-%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86%E7%9A%84%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99"><span class="toc-text">2.4.2 资源处理的默认规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-3-%E6%AC%A2%E8%BF%8E%E9%A1%B5%E7%9A%84%E5%A4%84%E7%90%86%E8%A7%84%E5%88%99"><span class="toc-text">2.4.3 欢迎页的处理规则</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AB%8B%E6%B1%82%E5%8F%83%E6%95%B8%E8%99%95%E7%90%86"><span class="toc-text">3. 請求參數處理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84"><span class="toc-text">3.1 请求映射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-rest%E4%BD%BF%E7%94%A8%E8%88%87%E5%8E%9F%E7%90%86"><span class="toc-text">3.1.1 rest使用與原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2-%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%8E%9F%E7%90%86"><span class="toc-text">3.1.2 请求映射原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%99%AE%E9%80%9A%E5%8F%82%E6%95%B0%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3"><span class="toc-text">3.2 普通参数与基本注解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1-%E6%B3%A8%E8%A7%A3%EF%BC%9A"><span class="toc-text">3.2.1 注解：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2-Servlet-API%EF%BC%9A"><span class="toc-text">3.2.2 Servlet API：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3-%E5%A4%8D%E6%9D%82%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="toc-text">3.2.3 复杂参数：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="toc-text">3.2.4 自定义对象参数：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-POJO%E5%B0%81%E8%A3%85%E8%BF%87%E7%A8%8B"><span class="toc-text">3.3 POJO封装过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%8F%83%E6%95%B8%E8%99%95%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-text">3.4 參數處理原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-1-HandlerAdapter"><span class="toc-text">3.4.1 HandlerAdapter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-2-%E6%89%A7%E8%A1%8C%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95"><span class="toc-text">3.4.2 执行目标方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-3-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8-HandlerMethodArgumentResolver"><span class="toc-text">3.4.3 参数解析器-HandlerMethodArgumentResolver</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-4-%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">3.4.4 返回值处理器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-5-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E6%AF%8F%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC"><span class="toc-text">3.4.5 如何确定目标方法每一个参数的值</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-4-5-1%E3%80%81%E6%8C%A8%E4%B8%AA%E5%88%A4%E6%96%AD%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8%E9%82%A3%E4%B8%AA%E6%94%AF%E6%8C%81%E8%A7%A3%E6%9E%90%E8%BF%99%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-text">3.4.5.1、挨个判断所有参数解析器那个支持解析这个参数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-4-5-2%E3%80%81%E8%A7%A3%E6%9E%90%E8%BF%99%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC"><span class="toc-text">3.4.5.2、解析这个参数的值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-4-5-3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0-%E5%B0%81%E8%A3%85POJO"><span class="toc-text">3.4.5.3、自定义类型参数 封装POJO</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-6-%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%88%90"><span class="toc-text">3.4.6 目标方法执行完成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-7-%E5%A4%84%E7%90%86%E6%B4%BE%E5%8F%91%E7%BB%93%E6%9E%9C"><span class="toc-text">3.4.7 处理派发结果</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E4%B8%8E%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86"><span class="toc-text">4. 数据响应与内容协商</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E9%9F%BF%E6%87%89JSON"><span class="toc-text">4.1 響應JSON</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-1-jackson-jar-ResponseBody"><span class="toc-text">4.1.1 jackson.jar+@ResponseBody</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-text">1. 返回值解析器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A7%A3%E6%9E%90%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-text">2、返回值解析器原理</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2%E3%80%81SpringMVC%E5%88%B0%E5%BA%95%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">4.1.2、SpringMVC到底支持哪些返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-3%E3%80%81HTTPMessageConverter%E5%8E%9F%E7%90%86"><span class="toc-text">4.1.3、HTTPMessageConverter原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81MessageConverter%E8%A7%84%E8%8C%83"><span class="toc-text">1、MessageConverter规范</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E9%BB%98%E8%AE%A4%E7%9A%84MessageConverter"><span class="toc-text">2、默认的MessageConverter</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86"><span class="toc-text">4.2 内容协商</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-1-%E5%BC%95%E5%85%A5XML%E4%BE%9D%E8%B5%96%EF%BC%9A"><span class="toc-text">4.2.1 引入XML依赖：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-2-postman%E5%88%86%E5%88%AB%E6%B5%8B%E8%AF%95%E8%BF%94%E5%9B%9Ejson%E5%92%8Cxml"><span class="toc-text">4.2.2 postman分别测试返回json和xml</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-3-%E5%BC%80%E5%90%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%82%E6%95%B0%E6%96%B9%E5%BC%8F%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E5%8A%9F%E8%83%BD"><span class="toc-text">4.2.3 开启浏览器参数方式内容协商功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-4-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E5%8E%9F%E7%90%86"><span class="toc-text">4.2.4 内容协商原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-5-%E8%87%AA%E5%AE%9A%E4%B9%89-MessageConverter"><span class="toc-text">4.2.5 自定义 MessageConverter</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E"><span class="toc-text">5. 视图解析与模板引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E8%A6%96%E5%9C%96%E8%A7%A3%E6%9E%90"><span class="toc-text">5.1 視圖解析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86%E6%B5%81%E7%A8%8B-%E3%80%90%E6%BA%90%E7%A2%BC%E8%A7%A3%E6%9E%90%E3%80%91"><span class="toc-text">5.1.1视图解析原理流程 【源碼解析】</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E-Thymeleaf"><span class="toc-text">5.2 模板引擎-Thymeleaf</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-1-thymeleaf%E7%AE%80%E4%BB%8B"><span class="toc-text">5.2.1 thymeleaf简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-2-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">5.2.2 基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">1、表达式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">2、字面量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E3%80%81%E6%96%87%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">3、文本操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97"><span class="toc-text">4、数学运算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5%E3%80%81%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97"><span class="toc-text">5、布尔运算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6%E3%80%81%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97"><span class="toc-text">6、比较运算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7%E3%80%81%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97"><span class="toc-text">7、条件运算</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8%E3%80%81%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C"><span class="toc-text">8、特殊操作</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-3-%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%80%BC-th-attr"><span class="toc-text">5.2.3 设置属性值-th:attr</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-4-%E8%BF%AD%E4%BB%A3"><span class="toc-text">5.2.4 迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-5-%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97"><span class="toc-text">5.2.5 条件运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-6-%E5%B1%9E%E6%80%A7%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">5.2.6 属性优先级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-thymeleaf%E4%BD%BF%E7%94%A8"><span class="toc-text">5.3 thymeleaf使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-1-%E5%BC%95%E5%85%A5Starter"><span class="toc-text">5.3.1 引入Starter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-2-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%A5%BD%E4%BA%86thymeleaf"><span class="toc-text">5.3.2 自动配置好了thymeleaf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-3-%E9%A0%81%E9%9D%A2%E9%96%8B%E7%99%BC"><span class="toc-text">5.3.3 頁面開發</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%A7%8B%E5%BB%BA%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-text">5.4 構建后台管理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-1-%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA"><span class="toc-text">5.4.1 项目创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-2-%E9%9D%9C%E6%85%8B%E8%B3%87%E6%BA%90%E8%99%95%E7%90%86"><span class="toc-text">5.4.2 靜態資源處理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-3-%E8%B7%AF%E5%BE%91%E6%A7%8B%E5%BB%BA"><span class="toc-text">5.4.3 路徑構建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-4-%E6%A8%A1%E6%9D%BF%E6%8A%BD%E5%8F%96"><span class="toc-text">5.4.4 模板抽取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-5-%E9%A0%81%E9%9D%A2%E8%B7%B3%E8%BD%89"><span class="toc-text">5.4.5 頁面跳轉</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-6-%E6%95%B8%E6%93%9A%E6%B8%B2%E6%9F%93"><span class="toc-text">5.4.6 數據渲染</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">6. 拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-HandlerInterceptor-%E6%8E%A5%E5%8F%A3"><span class="toc-text">6.1 HandlerInterceptor 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E9%85%8D%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">6.2 配置拦截器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-text">6.3 拦截器原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-text">7. 文件上传</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E9%A1%B5%E9%9D%A2%E8%A1%A8%E5%8D%95"><span class="toc-text">7.1 页面表单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81"><span class="toc-text">7.2 文件上传代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E3%80%90%E6%BA%90%E7%A2%BC%E8%A7%A3%E6%9E%90%E3%80%91"><span class="toc-text">7.3 自动配置原理【源碼解析】</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">8. 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E9%BB%98%E8%AE%A4%E8%A7%84%E5%88%99"><span class="toc-text">8.1 默认规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%AE%9A%E5%88%B6%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">8.2 定制错误处理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-text">8.3 异常处理自动配置原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%AD%A5%E9%AA%A4%E6%B5%81%E7%A8%8B"><span class="toc-text">8.4 异常处理步骤流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Web%E5%8E%9F%E7%94%9F%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%85%A5%EF%BC%88Servlet%E3%80%81Filter%E3%80%81Listener%EF%BC%89"><span class="toc-text">9. Web原生组件注入（Servlet、Filter、Listener）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E4%BD%BF%E7%94%A8Servlet-API-%E6%8E%A8%E8%96%A6%E4%BD%BF%E7%94%A8"><span class="toc-text">9.1 使用Servlet API (推薦使用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E4%BD%BF%E7%94%A8RegistrationBean"><span class="toc-text">9.2 使用RegistrationBean</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8"><span class="toc-text">10. 嵌入式Servlet容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%88%87%E6%8D%A2%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8"><span class="toc-text">10.1 切换嵌入式Servlet容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%AE%9A%E5%88%B6Servlet%E5%AE%B9%E5%99%A8"><span class="toc-text">10.2 定制Servlet容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%AE%9A%E5%88%B6%E5%8C%96%E5%8E%9F%E7%90%86"><span class="toc-text">11 定制化原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E5%AE%9A%E5%88%B6%E5%8C%96%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F"><span class="toc-text">11.1 定制化的常见方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%A5%97%E8%B7%AF"><span class="toc-text">11.2 原理分析套路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#06%E3%80%81%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="toc-text">06、数据访问</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-SQL"><span class="toc-text">1. SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE-HikariDataSource"><span class="toc-text">1.1 数据源的自动配置-HikariDataSource</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-%E5%AF%BC%E5%85%A5JDBC%E5%9C%BA%E6%99%AF"><span class="toc-text">1.1.1 导入JDBC场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-%E5%88%86%E6%9E%90%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">1.1.2 分析自动配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-3-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-text">1.1.3 修改配置项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-4-%E5%96%AE%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">1.1.4 單元测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BD%BF%E7%94%A8Druid%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-text">1.2 使用Druid数据源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-druid%E5%AE%98%E6%96%B9github%E5%9C%B0%E5%9D%80"><span class="toc-text">1.2.1 druid官方github地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-text">1.2.2 自定义方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-text">1、创建数据源</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E9%85%8D%E7%BD%AEDruid%E7%9A%84%E7%9B%91%E6%8E%A7%E9%A1%B5%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-text">2、配置Druid的监控页功能：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-%E4%BD%BF%E7%94%A8%E5%AE%98%E6%96%B9starter%E6%96%B9%E5%BC%8F"><span class="toc-text">1.2.3 使用官方starter方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E5%BC%95%E5%85%A5druid-starter"><span class="toc-text">1、引入druid-starter</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E5%88%86%E6%9E%90%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">2、分析自动配置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E3%80%81%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B"><span class="toc-text">3、配置示例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%95%B4%E5%90%88MyBatis%E6%93%8D%E4%BD%9C"><span class="toc-text">1.3 整合MyBatis操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-1-%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.3.1 配置模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-%E6%B3%A8%E8%A7%A3%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.3.2 注解模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-3-%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.3.3 混合模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%95%B4%E5%90%88-MyBatis-Plus-%E5%AE%8C%E6%88%90CRUD"><span class="toc-text">1.4 整合 MyBatis-Plus 完成CRUD</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-1-%E4%BB%80%E4%B9%88%E6%98%AFMyBatis-Plus"><span class="toc-text">1.4.1 什么是MyBatis-Plus</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-2-%E6%95%B4%E5%90%88MyBatis-Plus"><span class="toc-text">1.4.2 整合MyBatis-Plus</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-3-CRUD%E5%8A%9F%E8%83%BD"><span class="toc-text">1.4.3 CRUD功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4-4-%E6%B7%BB%E5%8A%A0%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%EF%BC%9A"><span class="toc-text">1.4.4 添加分页插件：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81NoSQL"><span class="toc-text">2、NoSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Redis%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-text">2.1 Redis自动配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-RedisTemplate%E4%B8%8ELettuce"><span class="toc-text">2.2 RedisTemplate与Lettuce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%88%87%E6%8D%A2%E8%87%B3jedis"><span class="toc-text">2.3 切换至jedis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Redis%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B"><span class="toc-text">2.4 Redis操作示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#07%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">07、单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JUnit5-%E7%9A%84%E8%AE%8A%E5%8C%96"><span class="toc-text">1. JUnit5 的變化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-JUnit5-%E5%B8%B8%E7%94%A8%E6%B5%8B%E8%AF%95%E6%B3%A8%E8%A7%A3"><span class="toc-text">2. JUnit5 常用测试注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%96%AD%E8%A8%80%E6%9C%BA%E5%88%B6-assertions"><span class="toc-text">3. 断言机制 ( assertions )</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%AE%80%E5%8D%95%E6%96%AD%E8%A8%80"><span class="toc-text">3.1 简单断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%95%B0%E7%BB%84%E6%96%AD%E8%A8%80"><span class="toc-text">3.2 数组断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BB%84%E5%90%88%E6%96%AD%E8%A8%80"><span class="toc-text">3.3 组合断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80"><span class="toc-text">3.4 异常断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E8%B6%85%E6%97%B6%E6%96%AD%E8%A8%80"><span class="toc-text">3.5 超时断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%BF%AB%E9%80%9F%E5%A4%B1%E8%B4%A5"><span class="toc-text">3.6 快速失败</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%89%8D%E7%BD%AE%E6%9D%A1%E4%BB%B6%EF%BC%88assumptions%EF%BC%89"><span class="toc-text">4. 前置条件（assumptions）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B5%8C%E5%A5%97%E6%B5%8B%E8%AF%95"><span class="toc-text">5. 嵌套测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="toc-text">6. 参数化测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%BF%81%E7%A7%BB%E6%8C%87%E5%8D%97"><span class="toc-text">7. 迁移指南</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#08%E3%80%81%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7"><span class="toc-text">08、指标监控</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-SpringBoot-Actuator"><span class="toc-text">1. SpringBoot Actuator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%B0%A1%E4%BB%8B"><span class="toc-text">1.1 簡介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-x%E4%B8%8E2-x%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="toc-text">1.2 1.x与2.x的不同：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-text">1.3 如何使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%8F%AF%E8%A6%96%E5%8C%96-%E7%95%A5"><span class="toc-text">1.4 可視化 (略)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Actuator-Endpoint"><span class="toc-text">2. Actuator Endpoint</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84%E7%AB%AF%E7%82%B9"><span class="toc-text">2.1 常使用的端点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Health-Endpoint"><span class="toc-text">2.2 Health Endpoint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Metrics-Endpoint"><span class="toc-text">2.3 Metrics Endpoint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%AE%A1%E7%90%86Endpoints"><span class="toc-text">2.4. 管理Endpoints</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-1-%E5%BC%80%E5%90%AF%E4%B8%8E%E7%A6%81%E7%94%A8Endpoints"><span class="toc-text">2.4.1 开启与禁用Endpoints</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-2-%E6%9A%B4%E9%9C%B2Endpoints"><span class="toc-text">2.4.2 暴露Endpoints</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7-%E5%AE%9A%E5%88%B6Endpoint"><span class="toc-text">3. 指标监控-定制Endpoint</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AE%9A%E5%88%B6-Health-%E4%BF%A1%E6%81%AF"><span class="toc-text">3.1 定制 Health 信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%AE%9A%E5%88%B6info%E4%BF%A1%E6%81%AF"><span class="toc-text">3.2 定制info信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%AE%9A%E5%88%B6Metrics%E4%BF%A1%E6%81%AF"><span class="toc-text">3.3 定制Metrics信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-SpringBoot%E6%94%AF%E6%8C%81%E8%87%AA%E5%8A%A8%E9%80%82%E9%85%8D%E7%9A%84Metrics"><span class="toc-text">3.3.1 SpringBoot支持自动适配的Metrics</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-%E5%A2%9E%E5%8A%A0%E5%AE%9A%E5%88%B6Metrics%EF%BC%9A"><span class="toc-text">3.3.2 增加定制Metrics：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%AE%9A%E5%88%B6Endpoint"><span class="toc-text">3.4 定制Endpoint</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#09%E3%80%81%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-text">09、原理解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Profile%E5%8A%9F%E8%83%BD"><span class="toc-text">1. Profile功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-application-profile%E5%8A%9F%E8%83%BD"><span class="toc-text">1.1 application-profile功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Profile%E6%9D%A1%E4%BB%B6%E8%A3%85%E9%85%8D%E5%8A%9F%E8%83%BD"><span class="toc-text">1.2 @Profile条件装配功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-profile%E5%88%86%E7%BB%84"><span class="toc-text">1.3 profile分组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="toc-text">2. 外部化配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%A4%96%E9%83%A8%E9%85%8D%E7%BD%AE%E6%BA%90"><span class="toc-text">2.1 外部配置源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E9%BB%98%E8%AA%8D%E6%9F%A5%E6%89%BE%E4%BD%8D%E7%BD%AE"><span class="toc-text">2.2 配置文件默認查找位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="toc-text">2.3 配置文件加载顺序：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89starter%E7%BB%86%E8%8A%82"><span class="toc-text">3. 自定义starter细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-starter%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86"><span class="toc-text">3.1 starter启动原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%87%AA%E5%AE%9A%E4%B9%89starter"><span class="toc-text">3.2 自定义starter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-SpringBoot%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-text">4. SpringBoot原理解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-SpringBoot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">4.1 SpringBoot启动过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%87%AA%E5%AE%9A%E7%BE%A9%E4%BA%8B%E4%BB%B6%E7%9B%A3%E8%81%BD%E7%B5%84%E4%BB%B6"><span class="toc-text">5. 自定義事件監聽組件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#star-%E5%B0%9A%E6%9C%AA%E5%AD%B8%E7%BF%92"><span class="toc-text">:star:尚未學習</span></a></li></ol></div></p>
<h1 id="SpringBoot2核心技术-基础入门"><a href="#SpringBoot2核心技术-基础入门" class="headerlink" title="SpringBoot2核心技术-基础入门"></a><strong>SpringBoot2核心技术-基础入门</strong></h1><ol>
<li><p>Spring Boot 2核心技术</p>
</li>
<li><p>Spring Boot 2响应式编程</p>
</li>
</ol>
<ul>
<li>学习要求<br>-熟悉Spring基础<br>-熟悉Maven使用</li>
<li>环境要求<ul>
<li>Java8及以上</li>
<li>Maven 3.3及以上</li>
</ul>
</li>
<li>学习资料<ul>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-boot">Spring Boot官网</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/">Spring Boot官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://www.yuque.com/atguigu/springboot">本课程文档地址</a></li>
<li><a target="_blank" rel="noopener" href="http://www.gulixueyuan.com/">视频地址1</a>、<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19K4y1L7MT?p=1">视频地址2</a></li>
<li><a target="_blank" rel="noopener" href="https://gitee.com/leifengyang/springboot2">源码地址</a></li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://spring.io/">Spring官网</a></p>
<h1 id="01、Spring與Springboot"><a href="#01、Spring與Springboot" class="headerlink" title="01、Spring與Springboot"></a>01、Spring與Springboot</h1><h2 id="1、Spring能做什麼"><a href="#1、Spring能做什麼" class="headerlink" title="1、Spring能做什麼?"></a>1、Spring能做什麼?</h2><h3 id="1-1-Spring的能力"><a href="#1-1-Spring的能力" class="headerlink" title="1.1 Spring的能力"></a>1.1 Spring的能力</h3><p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20210205004146543.png" alt="在这里插入图片描述"></p>
<h3 id="1-2-Spring的生态"><a href="#1-2-Spring的生态" class="headerlink" title="1.2 Spring的生态"></a>1.2 Spring的生态</h3><p>覆盖了：</p>
<ul>
<li>web开发</li>
<li>数据访问</li>
<li>安全控制</li>
<li>分布式</li>
<li>消息服务</li>
<li>移动开发</li>
<li>批处理</li>
<li>……</li>
</ul>
<h3 id="1-3-Spring5重大升级"><a href="#1-3-Spring5重大升级" class="headerlink" title="1.3 Spring5重大升级"></a>1.3 Spring5重大升级</h3><ul>
<li><h5 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h5></li>
</ul>
<p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20210205004250581.png" alt="在这里插入图片描述"></p>
<ul>
<li><h5 id="内部源码设计"><a href="#内部源码设计" class="headerlink" title="内部源码设计"></a>内部源码设计</h5></li>
</ul>
<p>基于Java8的一些新特性，如：接口默认实现。重新设计源码架构。</p>
<h2 id="2、为什么用SpringBoot"><a href="#2、为什么用SpringBoot" class="headerlink" title="2、为什么用SpringBoot"></a>2、为什么用SpringBoot</h2><blockquote>
<p>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-boot">link</a></p>
<p>能快速创建出生产级别的Spring应用。</p>
</blockquote>
<h3 id="2-1-SpringBoot优点"><a href="#2-1-SpringBoot优点" class="headerlink" title="2.1 SpringBoot优点"></a>2.1 SpringBoot优点</h3><ul>
<li>Create stand-alone Spring applications<ul>
<li>创建独立Spring应用</li>
</ul>
</li>
<li>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)<ul>
<li>内嵌web服务器</li>
</ul>
</li>
<li>Provide opinionated ‘starter’ dependencies to simplify your build configuration<ul>
<li>自动starter依赖，简化构建配置</li>
</ul>
</li>
<li>Automatically configure Spring and 3rd party libraries whenever possible<ul>
<li>自动配置Spring以及第三方功能</li>
</ul>
</li>
<li>Provide production-ready features such as metrics, health checks, and externalized configuration<ul>
<li>提供生产级别的监控、健康检查及外部化配置</li>
</ul>
</li>
<li>Absolutely no code generation and no requirement for XML configuration<ul>
<li>无代码生成、无需编写XML</li>
</ul>
</li>
</ul>
<blockquote>
<p>SpringBoot是整合Spring技术栈的一站式框架</p>
<p>SpringBoot是简化Spring技术栈的快速开发脚手架</p>
</blockquote>
<h3 id="2-2-SpringBoot缺点"><a href="#2-2-SpringBoot缺点" class="headerlink" title="2.2 SpringBoot缺点"></a>2.2 SpringBoot缺点</h3><ul>
<li><p>人称版本帝，迭代快，需要时刻关注变化</p>
</li>
<li><p>封装太深，内部原理复杂，不容易精通</p>
</li>
</ul>
<h2 id="3、时代背景"><a href="#3、时代背景" class="headerlink" title="3、时代背景"></a>3、时代背景</h2><h3 id="3-1-微服务"><a href="#3-1-微服务" class="headerlink" title="3.1 微服务"></a>3.1 微服务</h3><p><a target="_blank" rel="noopener" href="https://martinfowler.com/articles/microservices.html">James Lewis and Martin Fowler (2014)</a>  提出微服务完整概念。<a target="_blank" rel="noopener" href="https://martinfowler.com/microservices/">https://martinfowler.com/microservices/</a></p>
<blockquote>
<p>In short, the <strong>microservice architectural style</strong> is an approach to developing a single application as a <strong>suite of small services</strong>, each <strong>running in its own process</strong> and communicating with <strong>lightweight</strong> mechanisms, often an <strong>HTTP</strong> resource API. These services are built around <strong>business capabilities</strong> and <strong>independently deployable</strong> by fully <strong>automated deployment</strong> machinery. There is a bare minimum of centralized management of these services, which may be <strong>written in different programming languages</strong> and use different data storage technologies.——<a target="_blank" rel="noopener" href="https://martinfowler.com/articles/microservices.html">James Lewis and Martin Fowler (2014)</a></p>
</blockquote>
<ul>
<li>微服务是一种架构风格</li>
<li>一个应用拆分为一组小型服务</li>
<li>每个服务运行在自己的进程内，也就是可独立部署和升级</li>
<li>服务之间使用轻量级HTTP交互</li>
<li>服务围绕业务功能拆分</li>
<li>可以由全自动部署机制独立部署</li>
<li>去中心化，服务自治。服务可以使用不同的语言、不同的存储技术</li>
</ul>
<h3 id="3-2-分布式"><a href="#3-2-分布式" class="headerlink" title="3.2 分布式"></a>3.2 分布式</h3><p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/2021020500434620.png" alt="在这里插入图片描述"></p>
<h4 id="分布式的困难"><a href="#分布式的困难" class="headerlink" title="分布式的困难"></a>分布式的困难</h4><ul>
<li>远程调用</li>
<li>服务发现</li>
<li>负载均衡</li>
<li>服务容错</li>
<li>配置管理</li>
<li>服务监控</li>
<li>链路追踪</li>
<li>日志管理</li>
<li>任务调度</li>
<li>……</li>
</ul>
<h4 id="分布式的解决"><a href="#分布式的解决" class="headerlink" title="分布式的解决"></a>分布式的解决</h4><ul>
<li>SpringBoot + SpringCloud</li>
</ul>
<p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20210205004523307.png" alt="在这里插入图片描述"></p>
<h3 id="3-3-云原生"><a href="#3-3-云原生" class="headerlink" title="3.3 云原生"></a>3.3 云原生</h3><p>原生应用如何上云。 Cloud Native</p>
<h4 id="上云的困难"><a href="#上云的困难" class="headerlink" title="上云的困难"></a>上云的困难</h4><ul>
<li>服务自愈</li>
<li>弹性伸缩</li>
<li>服务隔离</li>
<li>自动化部署</li>
<li>灰度发布</li>
<li>流量治理</li>
<li>……</li>
</ul>
<h4 id="上云的解决"><a href="#上云的解决" class="headerlink" title="上云的解决"></a>上云的解决</h4><p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20210205004621290.png" alt="在这里插入图片描述"></p>
<h2 id="4、如何學習SpringBoot"><a href="#4、如何學習SpringBoot" class="headerlink" title="4、如何學習SpringBoot"></a>4、如何學習SpringBoot</h2><h3 id="4-1-官方文档架构"><a href="#4-1-官方文档架构" class="headerlink" title="4.1 官方文档架构"></a>4.1 官方文档架构</h3><ul>
<li><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-boot">Spring Boot官网</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/">Spring Boot官方文档</a></li>
</ul>
<h3 id="官网文档架构"><a href="#官网文档架构" class="headerlink" title="官网文档架构"></a>官网文档架构</h3><p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20210205004733270.png" alt="在这里插入图片描述"><br><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20210205004828702.png" alt="在这里插入图片描述"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/wiki#release-notes">查看版本新特性</a></p>
<p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20210205005342147.png" alt="在这里插入图片描述"></p>
<h1 id="02、SpringBoot2入門"><a href="#02、SpringBoot2入門" class="headerlink" title="02、SpringBoot2入門"></a>02、SpringBoot2入門</h1><h2 id="1、系统要求"><a href="#1、系统要求" class="headerlink" title="1、系统要求"></a>1、系统要求</h2><ul>
<li>Java 8</li>
<li>Maven 3.3+</li>
<li>IntelliJ IDEA 2019.1.2</li>
</ul>
<h3 id="1-1-Maven配置文件"><a href="#1-1-Maven配置文件" class="headerlink" title="1.1 Maven配置文件"></a>1.1 Maven配置文件</h3><p>在Maven安裝目錄下的settings.xml中新添内容：</p>
<pre><code class="xml">&lt;!--阿里雲鏡像，台灣應該不用--&gt;
&lt;mirrors&gt;
      &lt;mirror&gt;
        &lt;id&gt;nexus-aliyun&lt;/id&gt;
        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
        &lt;name&gt;Nexus aliyun&lt;/name&gt;
        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;
      &lt;/mirror&gt;
  &lt;/mirrors&gt;
 &lt;!--以jdk1.8執行--&gt;
  &lt;profiles&gt;
         &lt;profile&gt;
              &lt;id&gt;jdk-1.8&lt;/id&gt;
              &lt;activation&gt;
                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
                &lt;jdk&gt;1.8&lt;/jdk&gt;
              &lt;/activation&gt;
              &lt;properties&gt;
                &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
                &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
                &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;
              &lt;/properties&gt;
         &lt;/profile&gt;
  &lt;/profiles&gt;
</code></pre>
<h2 id="2、HelloWorld项目"><a href="#2、HelloWorld项目" class="headerlink" title="2、HelloWorld项目"></a>2、HelloWorld项目</h2><p>需求：浏览发送/hello请求，响应 “Hello，Spring Boot 2”</p>
<h3 id="2-1-创建maven工程"><a href="#2-1-创建maven工程" class="headerlink" title="2.1 创建maven工程"></a>2.1 创建maven工程</h3><h3 id="2-2-引入依赖"><a href="#2-2-引入依赖" class="headerlink" title="2.2 引入依赖"></a>2.2 引入依赖</h3><pre><code class="xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h3 id="2-3-创建主程序"><a href="#2-3-创建主程序" class="headerlink" title="2.3 创建主程序"></a>2.3 创建主程序</h3><pre><code class="java">/**
 * 主程序类
 * @SpringBootApplication：这是一个SpringBoot应用
 */
@SpringBootApplication
public class MainApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(MainApplication.class,args);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>@SpringBootApplication：在SpringBoot中新增的標籤，將此類定義為SpringBoot應用</p>
</blockquote>
<h3 id="2-4-编写业务"><a href="#2-4-编写业务" class="headerlink" title="2.4 编写业务"></a>2.4 编写业务</h3><pre><code class="java">@RestController
public class HelloController &#123;
    @RequestMapping(&quot;/hello&quot;)
    public String handle01()&#123;
        return &quot;Hello, Spring Boot 2!&quot;;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>@RestController：含有@ResponseBody和@Controller的功能</p>
<p>@ResponseBody：可加註在類上或方法上，表示將方法的返回值返回到ResponseBody中</p>
</blockquote>
<h3 id="2-5-运行-amp-测试"><a href="#2-5-运行-amp-测试" class="headerlink" title="2.5 运行&amp;测试"></a>2.5 运行&amp;测试</h3><ul>
<li>直接运行主類<code>MainApplication</code>中的main方法即可</li>
<li>浏览器输入<code>http://localhost:8888/hello</code>，頁面将会输出<code>Hello, Spring Boot 2!</code>。</li>
</ul>
<h3 id="2-6-簡化配置"><a href="#2-6-簡化配置" class="headerlink" title="2.6 簡化配置"></a>2.6 簡化配置</h3><p>maven工程的resource文件夹中创建application.properties文件(固定格式)。</p>
<pre><code class="properties"># 设置端口号
server.port=8888
</code></pre>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.3.7.RELEASE/reference/html/appendix-application-properties.html#common-application-properties-server">更多配置信息</a></p>
<blockquote>
<p>SpringBoot將所有的配置文件整合再一起，沒設定代表使用SpringBoot中的默認設置(詳官方文檔)，若有要修改的地方直接寫在application.properties文件中。</p>
</blockquote>
<h3 id="2-7-簡化部署"><a href="#2-7-簡化部署" class="headerlink" title="2.7 簡化部署"></a>2.7 簡化部署</h3><p>在pom.xml添加</p>
<pre><code class="xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<blockquote>
<p>此插件可將工程打包為可執行的jar包(不像之前須打包為war包，交由tomcat執行)，內含tomcat伺服器，直接運行jar包即可部屬。</p>
<p>注意点：</p>
<ul>
<li>取消掉cmd的快速编辑模式(避免執行被中斷)</li>
</ul>
</blockquote>
<p>在IDEA的Maven插件上点击运行 clean 、package，把helloworld工程项目的打包成jar包，</p>
<p>打包好的jar包被生成在helloworld工程项目的target文件夹内。</p>
<p>用cmd运行<code>java -jar boot-01-helloworld-1.0-SNAPSHOT.jar</code>，既可以运行helloworld工程项目。</p>
<p>将jar包直接在目标服务器执行即可。</p>
<h1 id="03、了解自動配置原理"><a href="#03、了解自動配置原理" class="headerlink" title="03、了解自動配置原理"></a>03、了解自動配置原理</h1><h2 id="1-SpriingBoot特點"><a href="#1-SpriingBoot特點" class="headerlink" title="1. SpriingBoot特點"></a>1. SpriingBoot特點</h2><h3 id="1-1-依赖管理"><a href="#1-1-依赖管理" class="headerlink" title="1.1 依赖管理"></a>1.1 依赖管理</h3><ul>
<li>父项目做依赖管理</li>
</ul>
<pre><code class="xml">依赖管理
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;
&lt;/parent&gt;

&quot;spring-boot-starter-parent&quot;的父项目如下：
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
    &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;
&lt;/parent&gt;

它几乎声明了所有开发中常用的依赖及其版本号，自动版本仲裁机制
</code></pre>
<ul>
<li>开发导入starter场景启动器</li>
</ul>
<pre><code class="xml">1. 见到很多 spring-boot-starter-* ： *就某种场景
2. 只要引入starter，这个场景的所有常规需要的依赖我们都自动引入
3. SpringBoot所有支持的场景，見官方連結
    (https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter)
4. 见到的  *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。
5. 所有场景启动器最底层的依赖 --&gt; spring-boot-starter
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>无需关注版本号，自动版本仲裁<ol>
<li>引入依赖默认都可以不写版本</li>
<li>引入非版本仲裁的jar，要写版本号。(即不包含在官方仲裁的依賴)</li>
</ol>
</li>
</ul>
<ul>
<li>可以修改默认版本号</li>
</ul>
<pre><code class="xml">1. 查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。
2. 在当前项目pom.xml里面重写配置版本，如下面的代码。
&lt;properties&gt;
    &lt;mysql.version&gt;5.1.43&lt;/mysql.version&gt;
&lt;/properties&gt;
</code></pre>
<hr>
<p>IDEA快捷键：</p>
<ul>
<li><code> ctrl + shift + alt + U</code>：以图的方式显示项目中依赖之间的关系。</li>
<li><code>alt + ins</code>：相当于Eclipse的 Ctrl + N，创建新类，新包等。</li>
</ul>
<h3 id="1-2-自动配置特性"><a href="#1-2-自动配置特性" class="headerlink" title="1.2 自动配置特性"></a>1.2 自动配置特性</h3><ul>
<li>自动配好Tomcat<ul>
<li>引入Tomcat依赖。</li>
<li>配置Tomcat</li>
</ul>
</li>
</ul>
<pre><code class="xml">&quot;spring-boot-starter-web&quot;內包含以下配置
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
    &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li><p>自动配好SpringMVC</p>
<ul>
<li>引入SpringMVC全套组件</li>
<li>自动配好SpringMVC常用组件（功能）</li>
</ul>
</li>
</ul>
<ul>
<li><p>自动配好Web常见功能，如：字符编码问题</p>
<ul>
<li>SpringBoot帮我们配置好了所有web开发的常见场景</li>
</ul>
</li>
</ul>
<ul>
<li>默认的包结构<ul>
<li>描組件功能，默認在主程序所在的包及其子包下可以被掃描到</li>
<li>无需以前的包扫描配置</li>
<li>想要改变扫描路径<ul>
<li>方法一：@SpringBootApplication(scanBasePackages=”com.atguigu”)</li>
<li>方法二：@ComponentScan 指定扫描路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="java">@SpringBootApplication等同于下面三個註解的組合，可將主程序中的註解&quot;@SpringBootApplication&quot;，改為下面三個，並在@ComponentScan中定義掃描路徑
------------------------------------
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(&quot;com.atguigu.boot&quot;)
</code></pre>
<ul>
<li><p>各种配置拥有默认值</p>
<ul>
<li>默认配置最终都是映射到某个类上，如：<code>MultipartProperties</code></li>
<li>配置文件的值最终会绑定每个类上，这个类会在容器中创建对象</li>
</ul>
</li>
<li><p>按需加载所有自动配置项</p>
<ul>
<li><p>非常多的starter</p>
</li>
<li><p>引入了哪些场景这个场景的自动配置才会开启</p>
</li>
<li><p>SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-容器功能"><a href="#2-容器功能" class="headerlink" title="2. 容器功能"></a>2. 容器功能</h2><h3 id="2-1-組件添加"><a href="#2-1-組件添加" class="headerlink" title="2.1 組件添加"></a>2.1 組件添加</h3><h5 id="1-Configuration详解"><a href="#1-Configuration详解" class="headerlink" title="1. @Configuration详解"></a>1. @Configuration详解</h5><ul>
<li>基本使用</li>
<li>Full模式与Lite模式<ul>
<li>示例如下</li>
</ul>
</li>
</ul>
<pre><code class="java">/**
 * 1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的
 * 2、配置类本身也是组件
 * 3、proxyBeanMethods：代理bean的方法
 *      Full(proxyBeanMethods = true)（保证每个@Bean方法被调用多少次返回的组件都是单实例的）（默认）
 *      Lite(proxyBeanMethods = false)（每个@Bean方法被调用多少次返回的组件都是新创建的）
 */
@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件
public class MyConfig &#123;

    /**
     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象
     * @return
     */
    @Bean //给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例
    public User user01()&#123;
        User zhangsan = new User(&quot;zhangsan&quot;, 18);
        //user组件依赖了Pet组件
        zhangsan.setPet(tomcatPet());
        return zhangsan;
    &#125;

    @Bean(&quot;tom&quot;)
    public Pet tomcatPet()&#123;
        return new Pet(&quot;tomcat&quot;);
    &#125;
&#125;
</code></pre>
<p>@Configuration测试代码如下:</p>
<pre><code class="java">@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(&quot;com.atguigu.boot&quot;)
public class MainApplication &#123;

    public static void main(String[] args) &#123;
    //1、返回我们IOC容器
        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

    //2、查看容器里面的组件
        String[] names = run.getBeanDefinitionNames();
        for (String name : names) &#123;
            System.out.println(name);
        &#125;

    //3、从容器中获取组件
        Pet tom01 = run.getBean(&quot;tom&quot;, Pet.class);
        Pet tom02 = run.getBean(&quot;tom&quot;, Pet.class);
        System.out.println(&quot;组件：&quot;+(tom01 == tom02));

    //4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892
        MyConfig bean = run.getBean(MyConfig.class);
        System.out.println(bean);

    //如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。
        //保持组件单实例
        User user = bean.user01();
        User user1 = bean.user01();
        System.out.println(user == user1);

        User user01 = run.getBean(&quot;user01&quot;, User.class);
        Pet tom = run.getBean(&quot;tom&quot;, Pet.class);

        System.out.println(&quot;用户的宠物：&quot;+(user01.getPet() == tom));
    &#125;
&#125;
</code></pre>
<ul>
<li>最佳实战經驗如下：<ul>
<li>配置 类组件之间<strong>无依赖关系</strong>用Lite模式加速容器启动过程，减少判断</li>
<li>配置 类组件之间<strong>有依赖关系</strong>，方法会被调用得到之前单实例组件，用Full模式（默认）</li>
</ul>
</li>
</ul>
<hr>
<p>IDEA快捷键：</p>
<ul>
<li><code>Alt + Ins</code>:生成getter，setter、构造器等代码。</li>
<li><code>Ctrl + Alt + B</code>:查看类的具体实现代码。</li>
</ul>
<h5 id="2-Bean、-Component、-Controller、-Service、-Repository"><a href="#2-Bean、-Component、-Controller、-Service、-Repository" class="headerlink" title="2. @Bean、@Component、@Controller、@Service、@Repository"></a>2. @Bean、@Component、@Controller、@Service、@Repository</h5><p>它们是Spring的基本标签，在Spring Boot中并未改变它们原来的功能，跟以前一樣用法就好。</p>
<h5 id="3-ComponentScan、-Import"><a href="#3-ComponentScan、-Import" class="headerlink" title="3. @ComponentScan、@Import"></a>3. @ComponentScan、@Import</h5><ul>
<li><p>@ComponentScan：是Spring的基本标签，在Spring Boot中并未改变它们原来的功能，跟以前一樣用法就好。</p>
</li>
<li><p>@Import：加註在組件上方，如：@Configuration、@RestController….等。其功用是给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名，範例如下：</p>
</li>
</ul>
<pre><code class="java"> * 4、@Import(&#123;User.class, DBHelper.class&#125;)
 *      给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名
 * 
 */

@Import(&#123;User.class, DBHelper.class&#125;)
@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件
public class MyConfig &#123;
&#125;
</code></pre>
<p>测试类：</p>
<pre><code class="java">//1、返回我们IOC容器
ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

//...

//5、获取组件
String[] beanNamesForType = run.getBeanNamesForType(User.class);

for (String s : beanNamesForType) &#123;
    System.out.println(s);
&#125;

DBHelper bean1 = run.getBean(DBHelper.class);
System.out.println(bean1);
</code></pre>
<blockquote>
<p>@Import 高级用法： <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gW411W7wy?p=8">https://www.bilibili.com/video/BV1gW411W7wy?p=8</a></p>
</blockquote>
<h5 id="4-Conditional"><a href="#4-Conditional" class="headerlink" title="4. @Conditional"></a>4. @Conditional</h5><p>条件装配：满足Conditional指定的条件，则进行组件注入</p>
<p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20210205005453173.png" alt="在这里插入图片描述"></p>
<p>用<code>@ConditionalOnBean</code>举例说明</p>
<pre><code class="java">=====================测试条件装配==========================
@Configuration(proxyBeanMethods = false)
@ConditionalOnBean(name = &quot;tom&quot;)//在容器中有tom名字的Bean时，MyConfig类的Bean才能生效。
public class MyConfig &#123;

    @Bean
    public User user01()&#123;
        User zhangsan = new User(&quot;zhangsan&quot;, 18);
        zhangsan.setPet(tomcatPet());
        return zhangsan;
    &#125;

    @Bean(&quot;tom22&quot;)
    public Pet tomcatPet()&#123;
        return new Pet(&quot;tomcat&quot;);
    &#125;
&#125;

public static void main(String[] args) &#123;
    //1、返回我们IOC容器
    ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

    //2、查看容器里面的组件
    String[] names = run.getBeanDefinitionNames();
    for (String name : names) &#123;
        System.out.println(name);
    &#125;

    boolean tom = run.containsBean(&quot;tom&quot;);
    System.out.println(&quot;容器中Tom组件：&quot;+tom);//false

    boolean user01 = run.containsBean(&quot;user01&quot;);
    System.out.println(&quot;容器中user01组件：&quot;+user01);//true

    boolean tom22 = run.containsBean(&quot;tom22&quot;);
    System.out.println(&quot;容器中tom22组件：&quot;+tom22);//true

&#125;
</code></pre>
<h3 id="2-2-原生配置文件引入"><a href="#2-2-原生配置文件引入" class="headerlink" title="2.2 原生配置文件引入"></a>2.2 原生配置文件引入</h3><h5 id="1-ImportResource"><a href="#1-ImportResource" class="headerlink" title="1. @ImportResource"></a>1. @ImportResource</h5><p>比如，公司以前使用bean.xml文件生成配置bean，然而你为了省事，想继续复用bean.xml，@ImportResource粉墨登场。</p>
<ul>
<li>bean.xml：</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans ...&quot;&gt;

    &lt;bean id=&quot;haha&quot; class=&quot;com.lun.boot.bean.User&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;hehe&quot; class=&quot;com.lun.boot.bean.Pet&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;tomcat&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
<ul>
<li>使用方法：</li>
</ul>
<pre><code class="java">@ImportResource(&quot;classpath:beans.xml&quot;)
public class MyConfig &#123;
...
&#125;
</code></pre>
<ul>
<li>测试类：</li>
</ul>
<pre><code class="java">public static void main(String[] args) &#123;
    //1、返回我们IOC容器
    ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

    boolean haha = run.containsBean(&quot;haha&quot;);
    boolean hehe = run.containsBean(&quot;hehe&quot;);
    System.out.println(&quot;haha：&quot;+haha);//true
    System.out.println(&quot;hehe：&quot;+hehe);//true
&#125;
</code></pre>
<h3 id="2-3-配置绑定"><a href="#2-3-配置绑定" class="headerlink" title="2.3 配置绑定"></a>2.3 配置绑定</h3><p>如何使用Java读取到properties文件中的内容，并且把它封装到JavaBean中，以供随时使用</p>
<blockquote>
<p> 如：以前使用配置文件將連結mysql的設置，配置到properties中，再將其內容解析到javabean</p>
</blockquote>
<p>传统方法：</p>
<pre><code class="java">public class getProperties &#123;
     public static void main(String[] args) throws FileNotFoundException, IOException &#123;
         Properties pps = new Properties();
         pps.load(new FileInputStream(&quot;a.properties&quot;));
         Enumeration enum1 = pps.propertyNames();//得到配置文件的名字
         while(enum1.hasMoreElements()) &#123;
             String strKey = (String) enum1.nextElement();
             String strValue = pps.getProperty(strKey);
             System.out.println(strKey + &quot;=&quot; + strValue);
             //封装到JavaBean。
         &#125;
     &#125;
 &#125;
</code></pre>
<hr>
<p>Spring Boot提供的配置绑定：</p>
<h5 id="1-ConfigurationProperties-Component"><a href="#1-ConfigurationProperties-Component" class="headerlink" title="1. @ConfigurationProperties + @Component"></a>1. @ConfigurationProperties + @Component</h5><p>假设有配置文件application.properties</p>
<blockquote>
<p><font color=red><strong>注意：所有配置綁定都只能綁定application.properties內的參數</strong></font></p>
</blockquote>
<pre><code class="properties">mycar.brand=BYD
mycar.price=100000
</code></pre>
<pre><code class="java">@Component
@ConfigurationProperties(prefix = &quot;mycar&quot;) //將配置文件application.properties中前綴為&quot;mycar&quot;的鍵值對配對綁定到car的屬性中
public class Car &#123;
    private String brand;
    private Integer price;
&#125;
</code></pre>
<hr>
<h5 id="2-ConfigurationProperties-EnableConfigurationProperties"><a href="#2-ConfigurationProperties-EnableConfigurationProperties" class="headerlink" title="2. @ConfigurationProperties + @EnableConfigurationProperties"></a>2. @ConfigurationProperties + @EnableConfigurationProperties</h5><p>這種方式需在配置類中配置 (配置類在容器中)</p>
<ul>
<li>@EnableConfigurationProperties具有下面兩個功能<ul>
<li>开启Car配置绑定功能</li>
<li>把这个Car这个组件自动注册到容器中</li>
</ul>
</li>
</ul>
<pre><code class="java">@Configuration //配置類註解標籤
@EnableConfigurationProperties(Car.class)
public class MyConfig &#123;
...
&#125;
</code></pre>
<pre><code class="java">//car類
@ConfigurationProperties(prefix = &quot;mycar&quot;)
public class Car &#123;
    private String brand;
    private Integer price;
&#125;
</code></pre>
<blockquote>
<p><strong><font color=red>只有在容器中的组件，才会拥有SpringBoot提供的强大功能 =&gt; 配置綁定，所以@ConfigurationProperties需配合@Component或@EnableConfigurationProperties使用</font></strong></p>
</blockquote>
<h2 id="3-自动配置原理入門"><a href="#3-自动配置原理入門" class="headerlink" title="3. 自动配置原理入門"></a>3. 自动配置原理入門</h2><h3 id="3-1-引導加載自動配置類"><a href="#3-1-引導加載自動配置類" class="headerlink" title="3.1 引導加載自動配置類"></a>3.1 引導加載自動配置類</h3><p>Spring Boot应用的启动类：</p>
<pre><code class="java">@SpringBootApplication
public class MainApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(MainApplication.class, args);
    &#125;

&#125;
</code></pre>
<p>分析下<code>@SpringBootApplication</code>：主要包含3個功能註解<code>@SpringBootConfiguration</code>，<code>@EnableAutoConfiguration</code>，<code>@ComponentScan</code>。</p>
<pre><code class="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = &#123;@Filter(
    type = FilterType.CUSTOM,
    classes = &#123;TypeExcludeFilter.class&#125;
), @Filter(
    type = FilterType.CUSTOM,
    classes = &#123;AutoConfigurationExcludeFilter.class&#125;
)&#125;
)
public @interface SpringBootApplication &#123;
    ...
&#125;
</code></pre>
<blockquote>
<p><strong><font color="red"><code>@AutoConfigurationPackage</code>：自动配置包注解，默认将主配置类(<code>@SpringBootApplication</code>)所在的包及其子包里面的所有组件扫描到<code>IOC容器</code>中。</font></strong></p>
<p><strong><font color="red"><code>@Import</code>：这里是导入了<code>AutoConfigurationImportSelector</code>，用来注入自动配置类。</font></strong></p>
</blockquote>
<p>—————————————-以下為原碼解析——————————————–</p>
<h5 id="1-SpringBootConfiguration"><a href="#1-SpringBootConfiguration" class="headerlink" title="1. @SpringBootConfiguration"></a>1. @SpringBootConfiguration</h5><pre><code class="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
public @interface SpringBootConfiguration &#123;
    @AliasFor(
        annotation = Configuration.class
    )
    boolean proxyBeanMethods() default true;
&#125;
</code></pre>
<p><code>@Configuration</code>代表当前是一个配置类。</p>
<blockquote>
<p>MainApplication也是一個配置類，特別的是其為核心配置類</p>
</blockquote>
<h5 id="2-ComponentScan"><a href="#2-ComponentScan" class="headerlink" title="2. @ComponentScan"></a>2. @ComponentScan</h5><p>指定扫描哪些Spring注解。</p>
<p>@ComponentScan 在<a href="#">07、基础入门-SpringBoot-自动配置特性</a>有用例。</p>
<h5 id="3-EnableAutoConfiguration"><a href="#3-EnableAutoConfiguration" class="headerlink" title="3. @EnableAutoConfiguration"></a>3. @EnableAutoConfiguration</h5><p>原碼解析可參考此網址–&gt;<a target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/forum/topic/0201415961299750448">头秃了，Spring Boot 自动配置源码解析了解一波~-华为开发者论坛 | 华为开发者联盟 (huawei.com)</a></p>
<pre><code class="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration &#123;
    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;

    Class&lt;?&gt;[] exclude() default &#123;&#125;;

    String[] excludeName() default &#123;&#125;;
&#125;
</code></pre>
<p>重点分析<code>@AutoConfigurationPackage</code>，<code>@Import(AutoConfigurationImportSelector.class)</code>。</p>
<h6 id="a-AutoConfigurationPackage"><a href="#a-AutoConfigurationPackage" class="headerlink" title="a. @AutoConfigurationPackage"></a>a. @AutoConfigurationPackage</h6><p>标签名直译为：自动配置包，指定了默认的包规则。</p>
<pre><code class="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(AutoConfigurationPackages.Registrar.class)//给容器中导入一个组件
public @interface AutoConfigurationPackage &#123;
    String[] basePackages() default &#123;&#125;;

    Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;
&#125;
</code></pre>
<p>利用Registrar给容器中批量导入组件，即将MainApplication所在包下的所有组件导入IOC。</p>
<h6 id="b-Import-AutoConfigurationImportSelector-class"><a href="#b-Import-AutoConfigurationImportSelector-class" class="headerlink" title="b. @Import(AutoConfigurationImportSelector.class)"></a>b. @Import(AutoConfigurationImportSelector.class)</h6><ol>
<li>利用<code>getAutoConfigurationEntry(annotationMetadata);</code>给容器中批量导入一些组件</li>
<li>调用<code>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)</code>获取到所有需要导入到容器中的配置类</li>
<li>利用工厂加载 <code>Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader);</code>得到所有的组件</li>
<li>从<code>META-INF/spring.factories</code>位置来加载一个文件。<ul>
<li>默认扫描我们当前系统里面所有<code>META-INF/spring.factories</code>位置的文件</li>
<li><code>spring-boot-autoconfigure-2.3.4.RELEASE.jar</code>包里面也有<code>META-INF/spring.factories</code></li>
</ul>
</li>
</ol>
<p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20210205005536620.png" alt="在这里插入图片描述"></p>
<pre><code class="properties"># 文件里面写死了spring-boot一启动就要给容器中加载的所有配置类
# spring-boot-autoconfigure-2.3.4.RELEASE.jar/META-INF/spring.factories
# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
...
</code></pre>
<h3 id="3-2-按需開啟自動配置項"><a href="#3-2-按需開啟自動配置項" class="headerlink" title="3.2 按需開啟自動配置項"></a>3.2 按需開啟自動配置項</h3><p>虽然我们127个场景的所有自动配置启动的时候默认全部加载，但是<code>xxxxAutoConfiguration</code>按照条件装配规则（<code>@Conditional</code>），最终会按需配置。</p>
<p>如<code>AopAutoConfiguration</code>类：</p>
<pre><code class="java">@Configuration(
    proxyBeanMethods = false
)
@ConditionalOnProperty(  // &lt;---- 條件裝配
    prefix = &quot;spring.aop&quot;,
    name = &quot;auto&quot;,
    havingValue = &quot;true&quot;,
    matchIfMissing = true
)
public class AopAutoConfiguration &#123;
    public AopAutoConfiguration() &#123;
    &#125;
    ...
&#125;
</code></pre>
<h3 id="3-3-修改默認配置"><a href="#3-3-修改默認配置" class="headerlink" title="3.3 修改默認配置"></a>3.3 修改默認配置</h3><p>以DispatcherServlet中的multipartResolver為例：</p>
<pre><code class="java">@Bean
@ConditionalOnBean(MultipartResolver.class)  //容器中有这个类型组件
@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME) //容器中没有这个名字 multipartResolver 的组件
public MultipartResolver multipartResolver(MultipartResolver resolver) &#123;
    //给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。
    //SpringMVC multipartResolver。防止有些用户配置的文件上传解析器不符合规范
    // Detect if the user has created a MultipartResolver but named it incorrectly
    return resolver;//给容器中加入了文件上传解析器；
&#125;
</code></pre>
<p>SpringBoot默认会在底层配好所有的组件，但是<strong>如果用户自己配置了以用户的优先</strong>。如下面例子：</p>
<pre><code class="java">@Bean
@ConditionalOnMissingBean //若沒有這個配置類，才設置此配置類
public CharacterEncodingFilter characterEncodingFilter() &#123;
    .......
&#125;
</code></pre>
<p><strong>总结</strong>：</p>
<ul>
<li>SpringBoot先加载所有的自动配置类  xxxxxAutoConfiguration</li>
<li>每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。（xxxxProperties里面读取，xxxProperties和配置文件进行了绑定）</li>
<li>生效的配置类就会给容器中装配很多组件</li>
<li>只要容器中有这些组件，相当于这些功能就有了</li>
<li>定制化配置<ul>
<li>用户直接自己@Bean替换底层的组件<ul>
<li>因為@ConditionalOnMissingBean這個條件裝配</li>
</ul>
</li>
<li>用户去看这个组件是获取的配置文件什么值就去修改。<ul>
<li>到application.properties裡改</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong><font color=red>xxxxxAutoConfiguration —&gt; 组件 —&gt; xxxxProperties里面拿值  —-&gt; application.properties</font></strong></p>
<h3 id="3-4-最佳实践"><a href="#3-4-最佳实践" class="headerlink" title="3.4 最佳实践"></a>3.4 最佳实践</h3><ul>
<li><p>引入场景依赖</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter">官方文档</a></li>
</ul>
</li>
<li><p>查看自动配置了哪些（选做）</p>
<ul>
<li>自己分析，引入场景对应的自动配置一般都生效了</li>
<li>配置文件中配置<code>debug=true</code>开启自动配置报告。<ul>
<li>Negative（不生效）</li>
<li>Positive（生效）</li>
</ul>
</li>
</ul>
</li>
<li><p>是否需要修改</p>
<ul>
<li><p>参照文档修改配置项</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties">官方文档</a></li>
<li>自己分析。xxxxProperties绑定了配置文件的哪些前綴，直接到application.properties去輸入<code>前綴.</code>，就會跑出可以修改的屬性。</li>
</ul>
</li>
<li><p>自定义加入或者替换组件</p>
<ul>
<li>@Bean、@Component…</li>
</ul>
</li>
<li><p>自定义器  XXXXXCustomizer；</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-開發小技巧"><a href="#4-開發小技巧" class="headerlink" title="4. 開發小技巧"></a>4. 開發小技巧</h2><h3 id="4-1-Lombok"><a href="#4-1-Lombok" class="headerlink" title="4.1 Lombok"></a>4.1 Lombok</h3><p>功能：能簡化javabean開發，Lombok用标签方式代替构造器、getter/setter、toString()等代码。</p>
<ul>
<li>使用方法：</li>
</ul>
<ol>
<li>spring boot已经管理Lombok依賴版本。只需在pom文件裡面引入依赖：</li>
</ol>
<pre><code class="xml"> &lt;dependency&gt;
     &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
     &lt;artifactId&gt;lombok&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>IDEA中File-&gt;Settings-&gt;Plugins，搜索安装Lombok插件。下面代碼為示例</li>
</ol>
<pre><code class="java">@NoArgsConstructor //無參構造器
//@AllArgsConstructor //有參構造器  =&gt; 因為Pet pet不想加在有參構造器裡面，因此手動添加帶參的構造器，不使用@AllArgsConstructo
@Data //get、set方法
@ToString //tostring方法
@EqualsAndHashCode //重寫hashcode
public class User &#123;

    private String name;
    private Integer age;

    private Pet pet;

    public User(String name,Integer age)&#123;
        this.name = name;
        this.age = age;
    &#125;
&#125;
</code></pre>
<ul>
<li><p>Lombok標籤方法</p>
<ul>
<li>@NoArgsConstructor：無參構造器</li>
<li>@AllArgsConstructor：有參構造器</li>
<li>@Data：get、set方法</li>
<li>@ToString：tostring方法</li>
<li>@EqualsAndHashCode：重寫hashcode</li>
<li>@Slf4j：導入日誌</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>简化日志开发</li>
</ul>
<p>使用log.info打印到控制台，不需再使用system.out.println</p>
<pre><code class="java">@Slf4j
@RestController
public class HelloController &#123;
    @RequestMapping(&quot;/hello&quot;)
    public String handle01(@RequestParam(&quot;name&quot;) String name)&#123;
        log.info(&quot;请求进来了....&quot;);
        return &quot;Hello, Spring Boot 2!&quot;+&quot;你好：&quot;+name;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>System.out V.S log.info</p>
<p>System.out日志打印不可控制、打印时间无法确定、不能添加过滤器、日志没有级别区分。在Log中可以根据需要添加一个自定义的过滤器，在成百上千条日志中轻松找到我们要想要的信息。</p>
<p>知识剖析</p>
<p>Log4j有三个主要的组件：Loggers(记录器)，Appenders  (输出源)和Layouts(布局)。这里可简单理解为日志类别，日志要输出的地方和日志以何种形式输出。</p>
<p>Loggers组件在此系统中被分为五个级别：DEBUG、INFO、WARN、ERROR和FATAL。</p>
<p>这五个级别是有顺序的，DEBUG &lt; INFO &lt; WARN&lt; ERROR &lt; FATAL，分别用来指定这条日志信息的重要程度。</p>
<p>Log4j有一个规则：只输出级别不低于设定级别的日志信息。</p>
<p>Appenders 配置日志信息输出。</p>
<p>Layouts 设置日志输出的格式，Layouts提供四种日志输出样式，如根据HTML样式、自由指定样式、包含日志级别与信息的样式和包含日志时间、线程、类别等信息的样式。</p>
<p>log4j的配置文件中有输出到文件的相关配置，这就是它和System.out.println的区别，也是我们为什么使用log的关键点，因为我们查找日志信息的时候就可以到相应的日志文件中去查看，并且不会因为程序关闭等等因素丢失掉之前的日志信息，如果是sout的话，程序关闭，信息就丢失了，那我们想看到报错等等，就必须要重新运行程序。</p>
</blockquote>
<h3 id="4-2-dev-tools"><a href="#4-2-dev-tools" class="headerlink" title="4.2 dev-tools"></a>4.2 dev-tools</h3><p>功用：熱更新(自動重啟)</p>
<p>在IDEA中，项目或者页面修改以后：<code>Ctrl+F9</code>重新編譯即可看到修改後的效果。</p>
<blockquote>
<p>Spring Boot includes an additional set of tools that can make the application development experience a little more pleasant. The <code>spring-boot-devtools</code> module can be included in any project to provide additional development-time features.——<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/html/using-spring-boot.html#using-boot-devtools">link</a></p>
<p>Applications that use <code>spring-boot-devtools</code> automatically restart whenever files on the classpath change. This can be a useful feature when working in an IDE, as it gives a very fast feedback loop for code changes. By default, any entry on the classpath that points to a directory is monitored for changes. Note that certain resources, such as static assets and view templates, <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/html/using-spring-boot.html#using-boot-devtools-restart-exclude">do not need to restart the application</a>.——<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/html/using-spring-boot.html#using-boot-devtools-restart">link</a></p>
<p>Triggering a restart</p>
<p>As DevTools monitors classpath resources, the only way to trigger a restart is to update the classpath. The way in which you cause the classpath to be updated depends on the IDE that you are using:</p>
<ul>
<li>In Eclipse, saving a modified file causes the classpath to be updated and triggers a restart.</li>
<li>In IntelliJ IDEA, building the project (<code>Build -&gt; Build Project</code>)(shortcut: Ctrl+F9) has the same effect.</li>
</ul>
</blockquote>
<p>添加依赖即可使用：</p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<blockquote>
<p>實際上還是restart，但比較快，若要真正的熱更新，要使用付費的<code>JRebel</code>。</p>
</blockquote>
<h3 id="4-3-Spring-Initailizr"><a href="#4-3-Spring-Initailizr" class="headerlink" title="4.3 Spring Initailizr"></a>4.3 Spring Initailizr</h3><p><a target="_blank" rel="noopener" href="https://start.spring.io/">Spring Initailizr</a>是创建Spring Boot工程向导。</p>
<p>在IDEA中，菜单栏New -&gt; Project -&gt; Spring Initailizr。</p>
<h5 id="4-3-1-选择我们需要的开发场景"><a href="#4-3-1-选择我们需要的开发场景" class="headerlink" title="4.3.1 选择我们需要的开发场景"></a>4.3.1 选择我们需要的开发场景</h5><img src=" 20230315_164729.jpg" alt="在这里插入图片描述" style="zoom:67%;" />



<h5 id="4-3-2-自动依赖引入"><a href="#4-3-2-自动依赖引入" class="headerlink" title="4.3.2 自动依赖引入"></a>4.3.2 自动依赖引入</h5><img src=" 20230315_165127.jpg" style="zoom:67%;" />

<h5 id="4-3-3-自动创建项目结构"><a href="#4-3-3-自动创建项目结构" class="headerlink" title="4.3.3 自动创建项目结构"></a>4.3.3 自动创建项目结构</h5><img src=" 20230315_165234.jpg" style="zoom:67%;" />

<h5 id="4-3-4-自动编写好主配置类"><a href="#4-3-4-自动编写好主配置类" class="headerlink" title="4.3.4 自动编写好主配置类"></a>4.3.4 自动编写好主配置类</h5><img src=" 20230315_165303.jpg" style="zoom:67%;" />



<h1 id="SpringBoot2核心技术-核心功能"><a href="#SpringBoot2核心技术-核心功能" class="headerlink" title="SpringBoot2核心技术-核心功能"></a><strong>SpringBoot2核心技术-核心功能</strong></h1><img src=" 20230315_223830.jpg" style="zoom: 67%;" />

<h1 id="04、配置文件"><a href="#04、配置文件" class="headerlink" title="04、配置文件"></a>04、配置文件</h1><h2 id="1-文件類型"><a href="#1-文件類型" class="headerlink" title="1. 文件類型"></a>1. 文件類型</h2><h3 id="1-1-properties"><a href="#1-1-properties" class="headerlink" title="1.1 properties"></a>1.1 properties</h3><p>同以前的properties用法</p>
<h3 id="1-2-yaml"><a href="#1-2-yaml" class="headerlink" title="1.2 yaml"></a>1.2 yaml</h3><h5 id="1-2-1-簡介"><a href="#1-2-1-簡介" class="headerlink" title="1.2.1 簡介"></a>1.2.1 簡介</h5><p>YAML 是 “YAML Ain’t Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）。</p>
<p><strong>非常适合用来做以数据为中心的配置文件</strong>。</p>
<h5 id="1-2-1-基本语法"><a href="#1-2-1-基本语法" class="headerlink" title="1.2.1 基本语法"></a>1.2.1 基本语法</h5><ul>
<li>key: value；kv之间有空格</li>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进不允许使用tab，只允许空格</li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li>‘#’表示注释</li>
<li>字符串无需加引号，如果要加，单引号’’、双引号””表示字符串内容会被 转义、不转义</li>
</ul>
<blockquote>
<p>單引號：会轉義特殊字符，特殊字符终只是一个普通的字符串数据</p>
<p>雙引號：不会轉義字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p>
</blockquote>
<h5 id="1-2-3-数据类型"><a href="#1-2-3-数据类型" class="headerlink" title="1.2.3 数据类型"></a>1.2.3 数据类型</h5><ul>
<li>字面量：单个的、不可再分的值。date、boolean、string、number、null</li>
</ul>
<pre><code class="yaml">k: v
</code></pre>
<ul>
<li>对象：键值对的集合。map、hash、set、object</li>
</ul>
<pre><code class="yaml">#行内写法：  

k: &#123;k1:v1,k2:v2,k3:v3&#125;

#或

k: 
  k1: v1
  k2: v2
  k3: v3
</code></pre>
<ul>
<li>数组：一组按次序排列的值。array、list、queue</li>
</ul>
<pre><code class="yaml">#行内写法：  

k: [v1,v2,v3]

#或者

k:
 - v1
 - v2
 - v3
</code></pre>
<h5 id="1-2-4-实例"><a href="#1-2-4-实例" class="headerlink" title="1.2.4 实例"></a>1.2.4 实例</h5><pre><code class="java">@Data
public class Person &#123;
    private String userName;
    private Boolean boss;
    private Date birth;
    private Integer age;
    private Pet pet;
    private String[] interests;
    private List&lt;String&gt; animal;
    private Map&lt;String, Object&gt; score;
    private Set&lt;Double&gt; salarys;
    private Map&lt;String, List&lt;Pet&gt;&gt; allPets;
&#125;

@Data
public class Pet &#123;
    private String name;
    private Double weight;
&#125;
</code></pre>
<p>用yaml表示以上对象</p>
<pre><code class="yaml">person:
  userName: zhangsan
  boss: false
  birth: 2019/12/12 20:12:33
  age: 18
  pet: 
    name: tomcat
    weight: 23.4
  interests: [篮球,游泳]
  animal: 
    - jerry
    - mario
  score:
    english: 
      first: 30
      second: 40
      third: 50
    math: [131,140,148]
    chinese: &#123;first: 128,second: 136&#125;
  salarys: [3999,4999.98,5999.99]
  allPets:
    sick:
      - &#123;name: tom&#125;
      - &#123;name: jerry,weight: 47&#125;
    health: [&#123;name: mario,weight: 47&#125;]
</code></pre>
<h2 id="2-配置提示"><a href="#2-配置提示" class="headerlink" title="2. 配置提示"></a>2. 配置提示</h2><blockquote>
<p>You can easily generate your own configuration metadata file from items annotated with <code>@ConfigurationProperties</code> by using the <code>spring-boot-configuration-processor</code> jar. The jar includes a Java annotation processor which is invoked as your project is compiled.——<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#configuration-metadata-annotation-processor">link</a></p>
</blockquote>
<p>自定义的类和配置文件绑定一般没有提示。若要提示，添加如下依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;!--使自定義的類，在配置文件中也有提示--&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;

&lt;!-- 下面插件作用是工程打包时，不将spring-boot-configuration-processor打进包内，让其只在编码的时候有用 --&gt;
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;excludes&gt;
                    &lt;exclude&gt;
                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                        &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
                    &lt;/exclude&gt;
                &lt;/excludes&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<h1 id="05、web开发"><a href="#05、web开发" class="headerlink" title="05、web开发"></a>05、web开发</h1><img src=" 20230315_235928.jpg" alt="img" style="zoom:67%;" />



<h2 id="1-SpringMVC自动配置概览"><a href="#1-SpringMVC自动配置概览" class="headerlink" title="1. SpringMVC自动配置概览"></a>1. SpringMVC自动配置概览</h2><p>Spring Boot provides auto-configuration for Spring MVC that <strong>works well with most applications.(大多场景我们都无需自定义配置)</strong></p>
<p>The auto-configuration adds the following features on top of Spring’s defaults:</p>
<ul>
<li><p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p>
<ul>
<li>内容协商视图解析器和BeanName视图解析器</li>
</ul>
</li>
<li><p>Support for serving static resources, including support for WebJars (covered <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-static-content">later in this document</a>)).</p>
<ul>
<li>静态资源（包括webjars）</li>
</ul>
</li>
<li><p>Automatic registration of <code>Converter</code>, <code>GenericConverter</code>, and <code>Formatter</code> beans.</p>
<ul>
<li>自动注册 <code>Converter，GenericConverter，Formatter </code></li>
</ul>
</li>
<li><p>Support for <code>HttpMessageConverters</code> (covered <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-message-converters">later in this document</a>).</p>
<ul>
<li>支持 <code>HttpMessageConverters</code> （后来我们配合内容协商理解原理）</li>
</ul>
</li>
<li><p>Automatic registration of <code>MessageCodesResolver</code> (covered <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-message-codes">later in this document</a>).</p>
<ul>
<li>自动注册 <code>MessageCodesResolver</code> （国际化用）</li>
</ul>
</li>
<li><p>Static <code>index.html</code> support.</p>
<ul>
<li>静态index.html 页支持</li>
</ul>
</li>
<li><p>Custom <code>Favicon</code> support (covered <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-favicon">later in this document</a>).</p>
<ul>
<li>自定义 <code>Favicon</code></li>
</ul>
</li>
<li><p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (covered <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-web-binding-initializer">later in this document</a>).</p>
<ul>
<li>自动使用 <code>ConfigurableWebBindingInitializer</code> ，（DataBinder负责将请求数据绑定到JavaBean上）</li>
<li></li>
</ul>
</li>
</ul>
<blockquote>
<p>If you want to keep those Spring Boot MVC customizations and make more <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/web.html#mvc">MVC customizations</a> (interceptors, formatters, view controllers, and other features), you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurer</code> but <strong>without</strong> <code>@EnableWebMvc</code>.</p>
<p><strong>不用@EnableWebMvc注解。使用</strong> <strong><code>@Configuration</code></strong> <strong>+</strong> <strong><code>WebMvcConfigurer</code></strong> <strong>自定义规则</strong></p>
</blockquote>
<blockquote>
<p>If you want to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code>, or <code>ExceptionHandlerExceptionResolver</code>, and still keep the Spring Boot MVC customizations, you can declare a bean of type <code>WebMvcRegistrations</code> and use it to provide custom instances of those components.</p>
<p><strong>声明</strong> <strong><code>WebMvcRegistrations</code></strong> <strong>改变默认底层组件</strong></p>
</blockquote>
<blockquote>
<p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>, or alternatively add your own <code>@Configuration</code>-annotated <code>DelegatingWebMvcConfiguration</code> as described in the Javadoc of <code>@EnableWebMvc</code>.</p>
<p><strong>使用</strong> <strong><code>@EnableWebMvc+@Configuration+DelegatingWebMvcConfiguration 全面接管SpringMVC</code></strong></p>
</blockquote>
<h2 id="2-简单功能分析"><a href="#2-简单功能分析" class="headerlink" title="2. 简单功能分析"></a>2. 简单功能分析</h2><h3 id="2-1-靜態資源訪問"><a href="#2-1-靜態資源訪問" class="headerlink" title="2.1 靜態資源訪問"></a>2.1 靜態資源訪問</h3><h5 id="2-1-1-静态资源目录"><a href="#2-1-1-静态资源目录" class="headerlink" title="2.1.1 静态资源目录"></a>2.1.1 静态资源目录</h5><ul>
<li>默認靜態資源目錄</li>
</ul>
<p>只要静态资源放在类路径下： called <code>/static</code> (or <code>/public</code> or <code>/resources</code> or <code>/META-INF/resources</code></p>
<p>访问 ： 当前项目根路径/ + 静态资源名</p>
<p>原理： 静态映射/**。</p>
<p>请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面。</p>
<ul>
<li>自定義靜態資源目錄</li>
</ul>
<p>也可以改变默认的静态资源路径，<code>/static</code>，<code>/public</code>,<code>/resources</code>, <code>/META-INF/resources</code>失效，在application.yaml 配置代碼如下</p>
<pre><code class="yaml">resources:
  static-locations: [classpath:/haha/]
</code></pre>
<h5 id="2-1-2-静态资源访问前缀"><a href="#2-1-2-静态资源访问前缀" class="headerlink" title="2.1.2 静态资源访问前缀"></a>2.1.2 静态资源访问前缀</h5><p>一般來說，我們會在訪問靜態資源前加上前綴，可設定filter在看到此前綴時，直接放行</p>
<pre><code class="yaml">spring:
  mvc:
    static-path-pattern: /res/**
</code></pre>
<p>当前项目 + static-path-pattern + 静态资源名 = 静态资源文件夹下找</p>
<h5 id="2-1-3-webjar"><a href="#2-1-3-webjar" class="headerlink" title="2.1.3 webjar"></a>2.1.3 webjar</h5><p>webjar將css，js等资源文件打包成jar包，添加至依賴後可自動導入</p>
<p><a target="_blank" rel="noopener" href="https://www.webjars.org/">https://www.webjars.org/</a></p>
<p>例如，添加jquery</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.webjars&lt;/groupId&gt;
    &lt;artifactId&gt;jquery&lt;/artifactId&gt;
    &lt;version&gt;3.5.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>访问地址：<a target="_blank" rel="noopener" href="http://localhost:8080/webjars/jquery/3.5.1/jquery.js">http://localhost:8080/webjars/<strong>jquery/3.5.1/jquery.js</strong></a>  后面地址要按照依赖里面的包路径。</p>
<h3 id="2-2-欢迎页支持"><a href="#2-2-欢迎页支持" class="headerlink" title="2.2 欢迎页支持"></a>2.2 欢迎页支持</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-welcome-page">官方文档</a></p>
<ul>
<li><p>静态资源路径下  index.html。</p>
<ul>
<li>可以配置静态资源路径</li>
<li>但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问</li>
</ul>
</li>
</ul>
<pre><code class="yaml">spring:
#  mvc:
#    static-path-pattern: /res/**   这个会导致welcome page功能失效
  resources:
    static-locations: [classpath:/haha/]
</code></pre>
<ul>
<li>controller能处理/index。</li>
</ul>
<h3 id="2-3-自定义Favicon"><a href="#2-3-自定义Favicon" class="headerlink" title="2.3 自定义Favicon"></a>2.3 自定义Favicon</h3><p>指网页标签上的小图标。</p>
<ul>
<li>使用說明：</li>
</ul>
<p>將favicon.ico 放在静态资源目录下即可。</p>
<pre><code class="yaml">spring:
#  mvc:
#    static-path-pattern: /res/**   这个会导致 Favicon 功能失效
</code></pre>
<h3 id="2-4-静态资源配置原理-–-原碼解析"><a href="#2-4-静态资源配置原理-–-原碼解析" class="headerlink" title="2.4 静态资源配置原理 – (原碼解析)"></a>2.4 静态资源配置原理 – (原碼解析)</h3><ul>
<li>SpringBoot启动默认加载  xxxAutoConfiguration 类（自动配置类）</li>
</ul>
<ul>
<li>SpringMVC功能的自动配置类<code>WebMvcAutoConfiguration</code>，生效</li>
</ul>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,
        ValidationAutoConfiguration.class &#125;)
public class WebMvcAutoConfiguration &#123;
    ...
&#125;
</code></pre>
<ul>
<li><p>给容器中配置的内容：</p>
<ul>
<li>配置文件的相关属性的绑定：WebMvcProperties與前綴”spring.mvc”綁定；ResourceProperties與前綴”spring.resources”綁定</li>
</ul>
</li>
</ul>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
@Import(EnableWebMvcConfiguration.class)
@EnableConfigurationProperties(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)
@Order(0)
public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer &#123;  //WebMvcAutoConfiguration的內部類
    ...
&#125;
</code></pre>
<h5 id="2-4-1-配置类只有一个有参构造器"><a href="#2-4-1-配置类只有一个有参构造器" class="headerlink" title="2.4.1 配置类只有一个有参构造器"></a>2.4.1 配置类只有一个有参构造器</h5><pre><code class="java">//WebMvcAutoConfigurationAdapter這個內部配置類，只有一個有參構造器
//有参构造器所有参数的值都会从容器中确定
public WebMvcAutoConfigurationAdapter(WebProperties webProperties, WebMvcProperties mvcProperties,
        ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider,
        ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider,
        ObjectProvider&lt;DispatcherServletPath&gt; dispatcherServletPath,
        ObjectProvider&lt;ServletRegistrationBean&lt;?&gt;&gt; servletRegistrations) &#123;
    this.mvcProperties = mvcProperties;
    this.beanFactory = beanFactory;
    this.messageConvertersProvider = messageConvertersProvider;
    this.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();
    this.dispatcherServletPath = dispatcherServletPath;
    this.servletRegistrations = servletRegistrations;
    this.mvcProperties.checkConfiguration();
&#125;
</code></pre>
<p>此有參構造器的所有參數如下：</p>
<ul>
<li>ResourceProperties resourceProperties：获取前綴為<code>spring.resources</code>所有的值的对象</li>
<li>WebMvcProperties mvcProperties：获取前綴為<code>spring.mvc</code>所有的值的对象</li>
<li>ListableBeanFactory beanFactory：Spring的beanFactory</li>
<li>HttpMessageConverters：找到所有的HttpMessageConverters</li>
<li>ResourceHandlerRegistrationCustomizer：找到 资源处理器的自定义器。</li>
<li>DispatcherServletPath</li>
<li>ServletRegistrationBean   给应用注册Servlet、Filter….</li>
</ul>
<p>以上的值都會從容器中取得</p>
<h5 id="2-4-2-资源处理的默认规则"><a href="#2-4-2-资源处理的默认规则" class="headerlink" title="2.4.2 资源处理的默认规则"></a>2.4.2 资源处理的默认规则</h5><pre><code class="java">...
public class WebMvcAutoConfiguration &#123;
    ...
    public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware &#123;
        ...
        @Override
        protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;
            super.addResourceHandlers(registry);
            if (!this.resourceProperties.isAddMappings()) &#123;
                logger.debug(&quot;Default resource handling disabled&quot;);
                return;
            &#125;
            ServletContext servletContext = getServletContext();
            addResourceHandler(registry, &quot;/webjars/**&quot;, &quot;classpath:/META-INF/resources/webjars/&quot;);
            addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;
                registration.addResourceLocations(this.resourceProperties.getStaticLocations());
                if (servletContext != null) &#123;
                    registration.addResourceLocations(new ServletContextResource(servletContext, SERVLET_LOCATION));
                &#125;
            &#125;);
        &#125;
        ...
        
    &#125;
    ...
&#125;
</code></pre>
<p>根据上述代码，會先判斷<code>resourceProperties.isAddMappings()</code>是否為true，為true才進行resourceHandler的添加，因此我们可以通过配置來禁止所有静态资源规则。</p>
<pre><code class="yaml">spring:
  resources:
    add-mappings: false   #禁用所有静态资源规则
</code></pre>
<p>静态资源规则：</p>
<pre><code class="java">@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)
public class ResourceProperties &#123;

    private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;,
            &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;;

    /**
     * Locations of static resources. Defaults to classpath:[/META-INF/resources/,
     * /resources/, /static/, /public/].
     */
    private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;
    ...
&#125;
</code></pre>
<h5 id="2-4-3-欢迎页的处理规则"><a href="#2-4-3-欢迎页的处理规则" class="headerlink" title="2.4.3 欢迎页的处理规则"></a>2.4.3 欢迎页的处理规则</h5><pre><code class="java">...
public class WebMvcAutoConfiguration &#123;
    ...
    public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware &#123;
        ...
        @Bean
        public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,
                FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123;
            WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(
                    new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),
                    this.mvcProperties.getStaticPathPattern());
            welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));
            welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());
            return welcomePageHandlerMapping;
        &#125;
    
</code></pre>
<p><code>WelcomePageHandlerMapping</code>的构造方法如下：</p>
<pre><code class="java">WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders,
                          ApplicationContext applicationContext, Resource welcomePage, String staticPathPattern) &#123;
    if (welcomePage != null &amp;&amp; &quot;/**&quot;.equals(staticPathPattern)) &#123;
        //要用欢迎页功能，必须是/**
        logger.info(&quot;Adding welcome page: &quot; + welcomePage);
        setRootViewName(&quot;forward:index.html&quot;);
    &#125;
    else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;
        //调用Controller /index
        logger.info(&quot;Adding welcome page template: index&quot;);
        setRootViewName(&quot;index&quot;);
    &#125;
&#125;
</code></pre>
<p>这构造方法内的代码也解释了<a href="#">web场景-welcome与favicon功能</a>中配置<code>static-path-pattern</code>了，welcome页面和小图标失效的问题。</p>
<blockquote>
<p>由于favicon.ico图标是由浏览器自动发送请求/favicon.ico获取并保存在session域中的。因此，如果我们在配置文件中设置了静态资源访问前缀，那么浏览器发送的/favicon.ico由于不符合访问前缀要求，就会获取不到相对应的图标了(图标也是静态资源的一种)。</p>
</blockquote>
<h2 id="3-請求參數處理"><a href="#3-請求參數處理" class="headerlink" title="3. 請求參數處理"></a>3. 請求參數處理</h2><h3 id="3-1-请求映射"><a href="#3-1-请求映射" class="headerlink" title="3.1 请求映射"></a>3.1 请求映射</h3><h5 id="3-1-1-rest使用與原理"><a href="#3-1-1-rest使用與原理" class="headerlink" title="3.1.1 rest使用與原理"></a>3.1.1 rest使用與原理</h5><ul>
<li><p>@xxxMapping;</p>
<ul>
<li>@GetMapping</li>
<li>@PostMapping</li>
<li>@PutMapping</li>
<li>@DeleteMapping</li>
</ul>
</li>
<li><p>Rest风格支持（使用<strong>HTTP</strong>请求方式动词来表示对资源的操作）</p>
<ul>
<li>以前：<ul>
<li>/getUser 获取用户</li>
<li>/deleteUser 删除用户</li>
<li>/editUser 修改用户</li>
<li>/saveUser保存用户</li>
</ul>
</li>
<li>现在： /user<ul>
<li>GET-获取用户</li>
<li>DELETE-删除用户</li>
<li>PUT-修改用户</li>
<li>POST-保存用户</li>
</ul>
</li>
<li>核心Filter；<code>HiddenHttpMethodFilter</code><ul>
<li><strong>用法</strong>：表单method=post，隐藏域 _method=put、delete等（如果直接get或post，无需隐藏域）</li>
<li>SpringBoot中手動開啟(默認為關閉)</li>
</ul>
</li>
<li>擴展：如何把_method 这个名字换成我们自己喜欢的。</li>
</ul>
</li>
</ul>
<pre><code class="yaml">spring:
  mvc:
    hiddenmethod:
      filter:
        enabled: true   #开启页面表单的Rest功能
</code></pre>
<pre><code class="html">&lt;form action=&quot;/user&quot; method=&quot;get&quot;&gt;
    &lt;input value=&quot;REST-GET提交&quot; type=&quot;submit&quot; /&gt;
&lt;/form&gt;

&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt;
    &lt;input value=&quot;REST-POST提交&quot; type=&quot;submit&quot; /&gt;
&lt;/form&gt;

&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt;
    &lt;input name=&quot;_method&quot; type=&quot;hidden&quot; value=&quot;DELETE&quot;/&gt;
    &lt;input value=&quot;REST-DELETE 提交&quot; type=&quot;submit&quot;/&gt;
&lt;/form&gt;

&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt;
    &lt;input name=&quot;_method&quot; type=&quot;hidden&quot; value=&quot;PUT&quot; /&gt;
    &lt;input value=&quot;REST-PUT提交&quot;type=&quot;submit&quot; /&gt;
&lt;form&gt;
</code></pre>
<pre><code class="java">@GetMapping(&quot;/user&quot;)
//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.GET)
public String getUser()&#123;
    return &quot;GET-张三&quot;;
&#125;

@PostMapping(&quot;/user&quot;)
//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST)
public String saveUser()&#123;
    return &quot;POST-张三&quot;;
&#125;

@PutMapping(&quot;/user&quot;)
//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.PUT)
public String putUser()&#123;
    return &quot;PUT-张三&quot;;
&#125;

@DeleteMapping(&quot;/user&quot;)
//@RequestMapping(value = &quot;/user&quot;,method = RequestMethod.DELETE)
public String deleteUser()&#123;
    return &quot;DELETE-张三&quot;;
&#125;
</code></pre>
<pre><code class="java">    @Bean
    @ConditionalOnMissingBean(HiddenHttpMethodFilter.class)
    // SpringBoot底層默認hiddenmethod.filter為關閉
    @ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;, matchIfMissing = false)    
    public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() &#123;
        return new OrderedHiddenHttpMethodFilter();
    &#125;
</code></pre>
<pre><code class="java">//自定义filter
    @Bean
    public HiddenHttpMethodFilter hiddenHttpMethodFilter()&#123;
        HiddenHttpMethodFilter methodFilter = new HiddenHttpMethodFilter();
        methodFilter.setMethodParam(&quot;_m&quot;); //把_method 这个名字换成我们自己喜欢的。
        return methodFilter;
    &#125;
</code></pre>
<ul>
<li>Rest原理（表单提交要使用REST的时候）<ul>
<li>表单提交会带上<code>_method=PUT</code></li>
<li><strong>请求过来被</strong><code>HiddenHttpMethodFilter</code>拦截<ul>
<li>请求是否正常，并且是POST<ul>
<li>获取到<code>_method</code>的值。</li>
<li>兼容以下请求；<strong>PUT</strong>.<strong>DELETE</strong>.<strong>PATCH</strong></li>
<li><strong>原生request（post），包装模式requesWrapper重写了getMethod方法，返回的是传入的值。</strong></li>
<li><strong>过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requesWrapper重寫後的。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Rest使用客户端工具。<ul>
<li>如PostMan可直接发送put、delete等方式请求，此時不需開啟<code>HiddenHttpMethodFilter</code>。</li>
</ul>
</li>
</ul>
<pre><code class="java">public class HiddenHttpMethodFilter extends OncePerRequestFilter &#123;

    private static final List&lt;String&gt; ALLOWED_METHODS =
            Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(),
                    HttpMethod.DELETE.name(), HttpMethod.PATCH.name()));

    /** Default method parameter: &#123;@code _method&#125;. */
    public static final String DEFAULT_METHOD_PARAM = &quot;_method&quot;;

    private String methodParam = DEFAULT_METHOD_PARAM;


    /**
     * Set the parameter name to look for HTTP methods.
     * @see #DEFAULT_METHOD_PARAM
     */
    public void setMethodParam(String methodParam) &#123;
        Assert.hasText(methodParam, &quot;&#39;methodParam&#39; must not be empty&quot;);
        this.methodParam = methodParam;
    &#125;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException &#123;

        HttpServletRequest requestToUse = request;

        if (&quot;POST&quot;.equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) &#123;
            String paramValue = request.getParameter(this.methodParam);
            if (StringUtils.hasLength(paramValue)) &#123;
                String method = paramValue.toUpperCase(Locale.ENGLISH);
                if (ALLOWED_METHODS.contains(method)) &#123;
                    requestToUse = new HttpMethodRequestWrapper(request, method);
                &#125;
            &#125;
        &#125;

        filterChain.doFilter(requestToUse, response);
    &#125;


    /**
     * Simple &#123;@link HttpServletRequest&#125; wrapper that returns the supplied method for
     * &#123;@link HttpServletRequest#getMethod()&#125;.
     */
    private static class HttpMethodRequestWrapper extends HttpServletRequestWrapper &#123;

        private final String method;

        public HttpMethodRequestWrapper(HttpServletRequest request, String method) &#123;
            super(request);
            this.method = method;
        &#125;

        @Override
        public String getMethod() &#123;
            return this.method;
        &#125;
    &#125;

&#125;
</code></pre>
<ul>
<li>改变默认的_method</li>
</ul>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,
        ValidationAutoConfiguration.class &#125;)
public class WebMvcAutoConfiguration &#123;

    ...
    
    @Bean
    @ConditionalOnMissingBean(HiddenHttpMethodFilter.class)
    @ConditionalOnProperty(prefix = &quot;spring.mvc.hiddenmethod.filter&quot;, name = &quot;enabled&quot;, matchIfMissing = false)
    public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() &#123;
        return new OrderedHiddenHttpMethodFilter();
    &#125;
    
    ...
&#125;
    
</code></pre>
<p><code>@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)</code>意味着在没有<code>HiddenHttpMethodFilter</code>时，才执行<code>hiddenHttpMethodFilter()</code>。因此，我们可以自定义filter，改变默认的<code>_method</code>。例如：</p>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
public class WebConfig&#123;
    //自定义filter
    @Bean
    public HiddenHttpMethodFilter hiddenHttpMethodFilter()&#123;
        HiddenHttpMethodFilter methodFilter = new HiddenHttpMethodFilter();
        methodFilter.setMethodParam(&quot;_m&quot;);
        return methodFilter;
    &#125;    
&#125;
</code></pre>
<p>将<code>_method</code>改成<code>_m</code>。</p>
<pre><code class="html">&lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt;
    &lt;input name=&quot;_m&quot; type=&quot;hidden&quot; value=&quot;DELETE&quot;/&gt;
    &lt;input value=&quot;REST-DELETE 提交&quot; type=&quot;submit&quot;/&gt;
&lt;/form&gt;
</code></pre>
<h5 id="3-1-2-请求映射原理"><a href="#3-1-2-请求映射原理" class="headerlink" title="3.1.2 请求映射原理"></a>3.1.2 请求映射原理</h5><p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20210205005703527.png" alt="在这里插入图片描述"></p>
<ul>
<li>SpringMVC功能分析都从 <code>org.springframework.web.servlet.DispatcherServlet</code> -&gt; <code>doDispatch()</code></li>
</ul>
<pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    boolean multipartRequestParsed = false;

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    try &#123;
        ModelAndView mv = null;
        Exception dispatchException = null;

        try &#123;
            processedRequest = checkMultipart(request);
            multipartRequestParsed = (processedRequest != request);

            // 找到当前请求使用哪个Handler（Controller的方法）处理
            mappedHandler = getHandler(processedRequest);

            //HandlerMapping：处理器映射。/xxx-&gt;&gt;xxxx
    ...
&#125;
</code></pre>
<ul>
<li><code>getHandler()</code>方法如下：</li>
</ul>
<pre><code class="java">@Nullable
protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;
    if (this.handlerMappings != null) &#123;
        for (HandlerMapping mapping : this.handlerMappings) &#123;
            HandlerExecutionChain handler = mapping.getHandler(request);
            if (handler != null) &#123;
                return handler;
            &#125;
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
<ul>
<li><code>this.handlerMappings</code>在包含了下面幾個handler：</li>
</ul>
<p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20210205005802305.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>RequestMappingHandlerMapping</strong>：保存了所有@RequestMapping 和handler的映射规则。</li>
</ul>
<p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20210205005926474.png" alt="在这里插入图片描述"></p>
<p>總結：</p>
<ul>
<li>所有的请求映射都在HandlerMapping中：</li>
</ul>
<ul>
<li><p>SpringBoot自动配置欢迎页的 WelcomePageHandlerMapping 。访问 /能访问到index.html；</p>
</li>
<li><p>SpringBoot自动配置了默认 的 RequestMappingHandlerMapping</p>
</li>
<li><p>请求进来，挨个尝试所有的HandlerMapping看是否有请求信息。</p>
<ul>
<li>如果有就找到这个请求对应的handler</li>
<li>如果没有就是下一个 HandlerMapping</li>
</ul>
</li>
<li><p>我们需要一些自定义的映射处理，我们也可以自己给容器中放<strong>HandlerMapping</strong>。自定义 <strong>HandlerMapping</strong></p>
</li>
</ul>
<hr>
<p>IDEA快捷键：</p>
<ul>
<li>Ctrl + Alt + U : 以UML的类图展现类有哪些继承类，派生类以及实现哪些接口。</li>
<li>Crtl + Alt + Shift + U : 同上，区别在于上条快捷键结果在新页展现，而本条快捷键结果在弹窗展现。</li>
<li>Ctrl + H : 以树形方式展现类层次结构图。</li>
<li>Ctrl + F12：打開類的結構。</li>
<li>Ctrl + N：看內容。</li>
<li>Alt + F8：在Debug模式下，evalute選取的代碼計算結果。</li>
</ul>
<h3 id="3-2-普通参数与基本注解"><a href="#3-2-普通参数与基本注解" class="headerlink" title="3.2 普通参数与基本注解"></a>3.2 普通参数与基本注解</h3><h5 id="3-2-1-注解："><a href="#3-2-1-注解：" class="headerlink" title="3.2.1 注解："></a>3.2.1 注解：</h5><ul>
<li><code>@PathVariable</code> 路径变量</li>
<li><code>@RequestHeader</code> 获取请求头</li>
<li><code>@RequestParam</code> 获取请求参数（指问号后的参数，url?a=1&amp;b=2）</li>
<li><code>@CookieValue</code> 获取Cookie值</li>
<li><code>@RequestAttribute</code> 获取request域属性</li>
<li><code>@RequestBody</code> 获取请求体[POST]</li>
<li><code>@MatrixVariable</code> 矩阵变量</li>
<li><code>@ModelAttribute</code></li>
</ul>
<p><code>@PathVariable</code> 、<code>@RequestHeader</code> 、<code>@RequestParam</code> 、<code>@CookieValue</code>使用用例：</p>
<pre><code class="java">@RestController
public class ParameterTestController &#123;


    //  car/2/owner/zhangsan
    @GetMapping(&quot;/car/&#123;id&#125;/owner/&#123;username&#125;&quot;)
    public Map&lt;String,Object&gt; getCar(@PathVariable(&quot;id&quot;) Integer id,
                                     @PathVariable(&quot;username&quot;) String name,
                                     @PathVariable Map&lt;String,String&gt; pv,
                                     @RequestHeader(&quot;User-Agent&quot;) String userAgent,
                                     @RequestHeader Map&lt;String,String&gt; header,
                                     @RequestParam(&quot;age&quot;) Integer age,
                                     @RequestParam(&quot;inters&quot;) List&lt;String&gt; inters,
                                     @RequestParam Map&lt;String,String&gt; params,
                                     @CookieValue(&quot;_ga&quot;) String _ga,
                                     @CookieValue(&quot;_ga&quot;) Cookie cookie)&#123;

        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();

//        map.put(&quot;id&quot;,id);
//        map.put(&quot;name&quot;,name);
//        map.put(&quot;pv&quot;,pv);
//        map.put(&quot;userAgent&quot;,userAgent);
//        map.put(&quot;headers&quot;,header);
        map.put(&quot;age&quot;,age);
        map.put(&quot;inters&quot;,inters);
        map.put(&quot;params&quot;,params);
        map.put(&quot;_ga&quot;,_ga);
        System.out.println(cookie.getName()+&quot;===&gt;&quot;+cookie.getValue());
        return map;
    &#125;


    @PostMapping(&quot;/save&quot;)
    public Map postMethod(@RequestBody String content)&#123;
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;content&quot;,content);
        return map;
    &#125;
&#125;
</code></pre>
<p><code>@RequestAttribute</code>使用用例：</p>
<pre><code class="java">@Controller
public class RequestController &#123;

    @GetMapping(&quot;/goto&quot;)
    public String goToPage(HttpServletRequest request)&#123;

        request.setAttribute(&quot;msg&quot;,&quot;成功了...&quot;);
        request.setAttribute(&quot;code&quot;,200);
        return &quot;forward:/success&quot;;  //转发到  /success请求
    &#125;

    @GetMapping(&quot;/params&quot;)
    public String testParam(Map&lt;String,Object&gt; map,
                            Model model,
                            HttpServletRequest request,
                            HttpServletResponse response)&#123;
        map.put(&quot;hello&quot;,&quot;world666&quot;);
        model.addAttribute(&quot;world&quot;,&quot;hello666&quot;);
        request.setAttribute(&quot;message&quot;,&quot;HelloWorld&quot;);

        Cookie cookie = new Cookie(&quot;c1&quot;,&quot;v1&quot;);
        response.addCookie(cookie);
        return &quot;forward:/success&quot;;
    &#125;

    ///&lt;-----------------主角@RequestAttribute在这个方法
    @ResponseBody
    @GetMapping(&quot;/success&quot;)
    public Map success(@RequestAttribute(value = &quot;msg&quot;,required = false) String msg,
                       @RequestAttribute(value = &quot;code&quot;,required = false)Integer code,
                       HttpServletRequest request)&#123;
        Object msg1 = request.getAttribute(&quot;msg&quot;);

        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        Object hello = request.getAttribute(&quot;hello&quot;);
        Object world = request.getAttribute(&quot;world&quot;);
        Object message = request.getAttribute(&quot;message&quot;);

        map.put(&quot;reqMethod_msg&quot;,msg1);
        map.put(&quot;annotation_msg&quot;,msg);
        map.put(&quot;hello&quot;,hello);
        map.put(&quot;world&quot;,world);
        map.put(&quot;message&quot;,message);

        return map;
    &#125;
&#125;
</code></pre>
<p>@MatrixVariable</p>
<ol>
<li><p>语法： 请求路径：<code>/cars/sell;low=34;brand=byd,audi,yd</code></p>
</li>
<li><p>SpringBoot默认是禁用了矩阵变量的功能</p>
<ul>
<li>手动开启：原理。对于路径的处理。UrlPathHelper的removeSemicolonContent设置为false，让其支持矩阵变量的。</li>
</ul>
</li>
<li><p>矩阵变量<strong>必须</strong>有url路径变量才能被解析</p>
</li>
</ol>
<ul>
<li><p><strong>手动开启矩阵变量</strong>：共有兩個方法如下</p>
<ul>
<li><p>方法一：实现<code>WebMvcConfigurer</code></p>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
public class WebConfig implements WebMvcConfigurer &#123;
    @Override
    public void configurePathMatch(PathMatchConfigurer configurer) &#123;

        UrlPathHelper urlPathHelper = new UrlPathHelper();
        // 不移除；后面的内容。矩阵变量功能就可以生效
        urlPathHelper.setRemoveSemicolonContent(false);
        configurer.setUrlPathHelper(urlPathHelper);
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li>方法二：创建返回<code>WebMvcConfigurer</code>Bean</li>
</ul>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
public class WebConfig&#123;
    @Bean
    public WebMvcConfigurer webMvcConfigurer()&#123;
        return new WebMvcConfigurer() &#123;
                        @Override
            public void configurePathMatch(PathMatchConfigurer configurer) &#123;
                UrlPathHelper urlPathHelper = new UrlPathHelper();
                // 不移除；后面的内容。矩阵变量功能就可以生效
                urlPathHelper.setRemoveSemicolonContent(false);
                configurer.setUrlPathHelper(urlPathHelper);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><code>@MatrixVariable</code>的使用用例：</p>
<pre><code class="java">@RestController
public class ParameterTestController &#123;

    ///cars/sell;low=34;brand=byd,audi,yd
    @GetMapping(&quot;/cars/&#123;path&#125;&quot;)
    public Map carsSell(@MatrixVariable(&quot;low&quot;) Integer low,
                        @MatrixVariable(&quot;brand&quot;) List&lt;String&gt; brand,
                        @PathVariable(&quot;path&quot;) String path)&#123;
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();

        map.put(&quot;low&quot;,low);
        map.put(&quot;brand&quot;,brand);
        map.put(&quot;path&quot;,path);
        return map;
    &#125;

    // /boss/1;age=20/2;age=10

    @GetMapping(&quot;/boss/&#123;bossId&#125;/&#123;empId&#125;&quot;)
    public Map boss(@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;bossId&quot;) Integer bossAge,
                    @MatrixVariable(value = &quot;age&quot;,pathVar = &quot;empId&quot;) Integer empAge)&#123;
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();

        map.put(&quot;bossAge&quot;,bossAge);
        map.put(&quot;empAge&quot;,empAge);
        return map;

    &#125;

&#125;
</code></pre>
<h5 id="3-2-2-Servlet-API："><a href="#3-2-2-Servlet-API：" class="headerlink" title="3.2.2 Servlet API："></a>3.2.2 Servlet API：</h5><p>WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId</p>
<p><strong>ServletRequestMethodArgumentResolver  用來處理以上的部分参数</strong></p>
<pre><code class="java">@Override
    public boolean supportsParameter(MethodParameter parameter) &#123;
        Class&lt;?&gt; paramType = parameter.getParameterType();
        return (WebRequest.class.isAssignableFrom(paramType) ||
                ServletRequest.class.isAssignableFrom(paramType) ||
                MultipartRequest.class.isAssignableFrom(paramType) ||
                HttpSession.class.isAssignableFrom(paramType) ||
                (pushBuilder != null &amp;&amp; pushBuilder.isAssignableFrom(paramType)) ||
                Principal.class.isAssignableFrom(paramType) ||
                InputStream.class.isAssignableFrom(paramType) ||
                Reader.class.isAssignableFrom(paramType) ||
                HttpMethod.class == paramType ||
                Locale.class == paramType ||
                TimeZone.class == paramType ||
                ZoneId.class == paramType);
    &#125;
</code></pre>
<p>[原碼解析詳見參數處理原理](# 3.4 參數處理原理)</p>
<h5 id="3-2-3-复杂参数："><a href="#3-2-3-复杂参数：" class="headerlink" title="3.2.3 复杂参数："></a>3.2.3 复杂参数：</h5><p><strong>Map</strong>、<strong>Model（map、model里面的数据会被放在request的请求域  request.setAttribute）、</strong>Errors/BindingResult、<strong>RedirectAttributes（ 重定向携带数据）</strong>、<strong>ServletResponse（response）</strong>、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder</p>
<pre><code class="java">Map&lt;String,Object&gt; map,  Model model, HttpServletRequest request 都是可以给request域中放数据，
使用request.getAttribute()取得數據;
</code></pre>
<ul>
<li><strong>Map、Model类型的参数</strong>，<ul>
<li>会返回 <strong>mavContainer.getModel（）</strong>；—&gt; <strong>BindingAwareModelMap</strong> 是Model 也是Map</li>
<li><strong>mavContainer</strong>.getModel(); 获取到值的</li>
</ul>
</li>
</ul>
<p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20230316_202906.jpg" alt="img"></p>
<p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20230316_203029.jpg" alt="img"></p>
<p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20230316_203124.jpg" alt="img"></p>
<p>[原碼解析詳見參數處理原理](# 3.4 參數處理原理)</p>
<h5 id="3-2-4-自定义对象参数："><a href="#3-2-4-自定义对象参数：" class="headerlink" title="3.2.4 自定义对象参数："></a>3.2.4 自定义对象参数：</h5><p>可以自动类型转换与格式化，可以级联封装。</p>
<pre><code class="java">/**
 *     姓名： &lt;input name=&quot;userName&quot;/&gt; &lt;br/&gt;
 *     年龄： &lt;input name=&quot;age&quot;/&gt; &lt;br/&gt;
 *     生日： &lt;input name=&quot;birth&quot;/&gt; &lt;br/&gt;
 *     宠物姓名：&lt;input name=&quot;pet.name&quot;/&gt;&lt;br/&gt;
 *     宠物年龄：&lt;input name=&quot;pet.age&quot;/&gt;
 */
@Data
public class Person &#123;
    
    private String userName;
    private Integer age;
    private Date birth;
    private Pet pet;
    
&#125;

@Data
public class Pet &#123;

    private String name;
    private String age;

&#125;

result
</code></pre>
<p>[原碼解析詳見參數處理原理](# 3.4 參數處理原理)</p>
<h3 id="3-3-POJO封装过程"><a href="#3-3-POJO封装过程" class="headerlink" title="3.3 POJO封装过程"></a>3.3 POJO封装过程</h3><ul>
<li><strong>ServletModelAttributeMethodProcessor</strong></li>
</ul>
<p>[原碼解析詳見參數處理原理](# 3.4 參數處理原理)</p>
<h3 id="3-4-參數處理原理"><a href="#3-4-參數處理原理" class="headerlink" title="3.4 參數處理原理"></a>3.4 參數處理原理</h3><ul>
<li>HandlerMapping中找到能处理请求的Handler（Controller.method()）</li>
<li>为当前Handler 找一个适配器 HandlerAdapter； <strong>RequestMappingHandlerAdapter</strong></li>
<li>适配器执行目标方法并确定方法参数的每一个值</li>
</ul>
<h5 id="3-4-1-HandlerAdapter"><a href="#3-4-1-HandlerAdapter" class="headerlink" title="3.4.1 HandlerAdapter"></a>3.4.1 HandlerAdapter</h5><p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20230317_005401.jpg" alt="img"></p>
<ol start="0">
<li><p>支持方法上标注<code>@RequestMapping</code> 的adapter</p>
</li>
<li><p>支持函数式编程的adapter</p>
</li>
<li><p>…其他</p>
</li>
<li><p>…其他</p>
</li>
</ol>
<h5 id="3-4-2-执行目标方法"><a href="#3-4-2-执行目标方法" class="headerlink" title="3.4.2 执行目标方法"></a>3.4.2 执行目标方法</h5><pre><code class="java">// Actually invoke the handler.
//DispatcherServlet -- doDispatch
mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
mav = invokeHandlerMethod(request, response, handlerMethod); //执行目标方法


//ServletInvocableHandlerMethod
Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
//获取方法的参数值
Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);
</code></pre>
<h5 id="3-4-3-参数解析器-HandlerMethodArgumentResolver"><a href="#3-4-3-参数解析器-HandlerMethodArgumentResolver" class="headerlink" title="3.4.3 参数解析器-HandlerMethodArgumentResolver"></a>3.4.3 参数解析器-HandlerMethodArgumentResolver</h5><p>确定将要执行的目标方法的每一个参数的值是什么;</p>
<p>SpringMVC目标方法能写多少种参数类型。取决于参数解析器。</p>
<p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20230317_005622.jpg" alt="img"></p>
<p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20230317_005701.jpg" alt="img"></p>
<ul>
<li>当前解析器是否支持解析这种参数</li>
<li>支持就调用 resolveArgument</li>
</ul>
<h5 id="3-4-4-返回值处理器"><a href="#3-4-4-返回值处理器" class="headerlink" title="3.4.4 返回值处理器"></a>3.4.4 返回值处理器</h5><p><img src="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/20230317_005744.jpg" alt="img"></p>
<h5 id="3-4-5-如何确定目标方法每一个参数的值"><a href="#3-4-5-如何确定目标方法每一个参数的值" class="headerlink" title="3.4.5 如何确定目标方法每一个参数的值"></a>3.4.5 如何确定目标方法每一个参数的值</h5><pre><code class="java">============InvocableHandlerMethod==========================
protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,
            Object... providedArgs) throws Exception &#123;

        MethodParameter[] parameters = getMethodParameters();
        if (ObjectUtils.isEmpty(parameters)) &#123;
            return EMPTY_ARGS;
        &#125;

        Object[] args = new Object[parameters.length];
        for (int i = 0; i &lt; parameters.length; i++) &#123;
            MethodParameter parameter = parameters[i];
            parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
            args[i] = findProvidedArgument(parameter, providedArgs);
            if (args[i] != null) &#123;
                continue;
            &#125;
            if (!this.resolvers.supportsParameter(parameter)) &#123;
                throw new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;));
            &#125;
            try &#123;
                args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);
            &#125;
            catch (Exception ex) &#123;
                // Leave stack trace for later, exception may actually be resolved and handled...
                if (logger.isDebugEnabled()) &#123;
                    String exMsg = ex.getMessage();
                    if (exMsg != null &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) &#123;
                        logger.debug(formatArgumentError(parameter, exMsg));
                    &#125;
                &#125;
                throw ex;
            &#125;
        &#125;
        return args;
    &#125;
</code></pre>
<h6 id="3-4-5-1、挨个判断所有参数解析器那个支持解析这个参数"><a href="#3-4-5-1、挨个判断所有参数解析器那个支持解析这个参数" class="headerlink" title="3.4.5.1、挨个判断所有参数解析器那个支持解析这个参数"></a>3.4.5.1、挨个判断所有参数解析器那个支持解析这个参数</h6><pre><code class="java">    @Nullable
    private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) &#123;
        HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);
        if (result == null) &#123;
            for (HandlerMethodArgumentResolver resolver : this.argumentResolvers) &#123;
                if (resolver.supportsParameter(parameter)) &#123;
                    result = resolver;
                    this.argumentResolverCache.put(parameter, result);
                    break;
                &#125;
            &#125;
        &#125;
        return result;
    &#125;
</code></pre>
<h6 id="3-4-5-2、解析这个参数的值"><a href="#3-4-5-2、解析这个参数的值" class="headerlink" title="3.4.5.2、解析这个参数的值"></a>3.4.5.2、解析这个参数的值</h6><pre><code class="java">调用各自 HandlerMethodArgumentResolver 的 resolveArgument 方法即可
</code></pre>
<h6 id="3-4-5-3、自定义类型参数-封装POJO"><a href="#3-4-5-3、自定义类型参数-封装POJO" class="headerlink" title="3.4.5.3、自定义类型参数 封装POJO"></a>3.4.5.3、自定义类型参数 封装POJO</h6><p><strong>ServletModelAttributeMethodProcessor  这个参数处理器支持</strong></p>
<p><strong>是否为简单类型。</strong></p>
<pre><code class="java">public static boolean isSimpleValueType(Class&lt;?&gt; type) &#123;
        return (Void.class != type &amp;&amp; void.class != type &amp;&amp;
                (ClassUtils.isPrimitiveOrWrapper(type) ||
                Enum.class.isAssignableFrom(type) ||
                CharSequence.class.isAssignableFrom(type) ||
                Number.class.isAssignableFrom(type) ||
                Date.class.isAssignableFrom(type) ||
                Temporal.class.isAssignableFrom(type) ||
                URI.class == type ||
                URL.class == type ||
                Locale.class == type ||
                Class.class == type));
    &#125;
@Override
    @Nullable
    public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
            NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception &#123;

        Assert.state(mavContainer != null, &quot;ModelAttributeMethodProcessor requires ModelAndViewContainer&quot;);
        Assert.state(binderFactory != null, &quot;ModelAttributeMethodProcessor requires WebDataBinderFactory&quot;);

        String name = ModelFactory.getNameForParameter(parameter);
        ModelAttribute ann = parameter.getParameterAnnotation(ModelAttribute.class);
        if (ann != null) &#123;
            mavContainer.setBinding(name, ann.binding());
        &#125;

        Object attribute = null;
        BindingResult bindingResult = null;

        if (mavContainer.containsAttribute(name)) &#123;
            attribute = mavContainer.getModel().get(name);
        &#125;
        else &#123;
            // Create attribute instance
            try &#123;
                attribute = createAttribute(name, parameter, binderFactory, webRequest);
            &#125;
            catch (BindException ex) &#123;
                if (isBindExceptionRequired(parameter)) &#123;
                    // No BindingResult parameter -&gt; fail with BindException
                    throw ex;
                &#125;
                // Otherwise, expose null/empty value and associated BindingResult
                if (parameter.getParameterType() == Optional.class) &#123;
                    attribute = Optional.empty();
                &#125;
                bindingResult = ex.getBindingResult();
            &#125;
        &#125;

        if (bindingResult == null) &#123;
            // Bean property binding and validation;
            // skipped in case of binding failure on construction.
            WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);
            if (binder.getTarget() != null) &#123;
                if (!mavContainer.isBindingDisabled(name)) &#123;
                    bindRequestParameters(binder, webRequest);
                &#125;
                validateIfApplicable(binder, parameter);
                if (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;
                    throw new BindException(binder.getBindingResult());
                &#125;
            &#125;
            // Value type adaptation, also covering java.util.Optional
            if (!parameter.getParameterType().isInstance(attribute)) &#123;
                attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);
            &#125;
            bindingResult = binder.getBindingResult();
        &#125;

        // Add resolved attribute and BindingResult at the end of the model
        Map&lt;String, Object&gt; bindingResultModel = bindingResult.getModel();
        mavContainer.removeAttributes(bindingResultModel);
        mavContainer.addAllAttributes(bindingResultModel);

        return attribute;
    &#125;
</code></pre>
<p><strong>WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);</strong></p>
<p><strong>WebDataBinder :web数据绑定器，将请求参数的值绑定到指定的JavaBean里面</strong></p>
<p><strong>WebDataBinder 利用它里面的 Converters 将请求数据转成指定的数据类型。再次封装到JavaBean中</strong></p>
<p><strong>GenericConversionService：在设置每一个值的时候，找它里面的所有converter那个可以将这个数据类型（request带来参数的字符串）转换到指定的类型（JavaBean – Integer）</strong></p>
<p><strong>byte – &gt; file</strong></p>
<p>@FunctionalInterface<strong>public interface</strong> Converter&lt;S, T&gt;</p>
<img src=" 20230317_005947.jpg" alt="img" style="zoom:67%;" />





<img src=" 20230317_010032.jpg" alt="img" style="zoom:67%;" />





<p>未来我们可以给WebDataBinder里面放自己的Converter；</p>
<p><strong>private static final class</strong> StringToNumber&lt;T **extends** Number&gt; <strong>implements</strong> Converter&lt;String, T&gt;</p>
<p>自定义 Converter：下面演示将字符串<code>“啊猫,3”</code>转换成<code>Pet</code>对象。</p>
<pre><code class="java">    //1、WebMvcConfigurer定制化SpringMVC的功能
    @Bean
    public WebMvcConfigurer webMvcConfigurer()&#123;
        return new WebMvcConfigurer() &#123;
            @Override
            public void configurePathMatch(PathMatchConfigurer configurer) &#123;
                UrlPathHelper urlPathHelper = new UrlPathHelper();
                // 不移除；后面的内容。矩阵变量功能就可以生效
                urlPathHelper.setRemoveSemicolonContent(false);
                configurer.setUrlPathHelper(urlPathHelper);
            &#125;

            @Override
            public void addFormatters(FormatterRegistry registry) &#123;
                registry.addConverter(new Converter&lt;String, Pet&gt;() &#123;

                    @Override
                    public Pet convert(String source) &#123;
                        // 啊猫,3
                        if(!StringUtils.isEmpty(source))&#123;
                            Pet pet = new Pet();
                            String[] split = source.split(&quot;,&quot;);
                            pet.setName(split[0]);
                            pet.setAge(Integer.parseInt(split[1]));
                            return pet;
                        &#125;
                        return null;
                    &#125;
                &#125;);
            &#125;
        &#125;;
    &#125;
</code></pre>
<h5 id="3-4-6-目标方法执行完成"><a href="#3-4-6-目标方法执行完成" class="headerlink" title="3.4.6 目标方法执行完成"></a>3.4.6 目标方法执行完成</h5><p>将所有的数据都放在 <strong>ModelAndViewContainer</strong>；包含要去的页面地址View。还包含Model数据。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1354552/1603272018605-1bce3142-bdd9-4834-a028-c753e91c52ac.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_16,text_YXRndWlndS5jb20g5bCa56GF6LC3,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="img"></p>
<h5 id="3-4-7-处理派发结果"><a href="#3-4-7-处理派发结果" class="headerlink" title="3.4.7 处理派发结果"></a>3.4.7 处理派发结果</h5><p><strong>processDispatchResult</strong>(processedRequest, response, mappedHandler, mv, dispatchException);</p>
<p>renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);</p>
<pre><code class="java">InternalResourceView：
@Override
    protected void renderMergedOutputModel(
            Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;

        // Expose the model object as request attributes.
        exposeModelAsRequestAttributes(model, request);

        // Expose helpers as request attributes, if any.
        exposeHelpers(request);

        // Determine the path for the request dispatcher.
        String dispatcherPath = prepareForRendering(request, response);

        // Obtain a RequestDispatcher for the target resource (typically a JSP).
        RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);
        if (rd == null) &#123;
            throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() +
                    &quot;]: Check that the corresponding file exists within your web application archive!&quot;);
        &#125;

        // If already included or response already committed, perform include, else forward.
        if (useInclude(request, response)) &#123;
            response.setContentType(getContentType());
            if (logger.isDebugEnabled()) &#123;
                logger.debug(&quot;Including [&quot; + getUrl() + &quot;]&quot;);
            &#125;
            rd.include(request, response);
        &#125;

        else &#123;
            // Note: The forwarded resource is supposed to determine the content type itself.
            if (logger.isDebugEnabled()) &#123;
                logger.debug(&quot;Forwarding to [&quot; + getUrl() + &quot;]&quot;);
            &#125;
            rd.forward(request, response);
        &#125;
    &#125;
</code></pre>
<pre><code class="java">暴露模型作为请求域属性
// Expose the model object as request attributes.
        exposeModelAsRequestAttributes(model, request);
</code></pre>
<pre><code class="java">protected void exposeModelAsRequestAttributes(Map&lt;String, Object&gt; model,
            HttpServletRequest request) throws Exception &#123;

    //model中的所有数据遍历挨个放在请求域中
        model.forEach((name, value) -&gt; &#123;
            if (value != null) &#123;
                request.setAttribute(name, value);
            &#125;
            else &#123;
                request.removeAttribute(name);
            &#125;
        &#125;);
    &#125;
</code></pre>
<h2 id="4-数据响应与内容协商"><a href="#4-数据响应与内容协商" class="headerlink" title="4. 数据响应与内容协商"></a>4. 数据响应与内容协商</h2><img src=" 20210205010403920.jpg" alt="在这里插入图片描述" style="zoom:67%;" />

<blockquote>
<ul>
<li><p>響應頁面：通常用在開發單體項目</p>
</li>
<li><p>響應數據：通常使用在前後分離的項目</p>
</li>
</ul>
</blockquote>
<h3 id="4-1-響應JSON"><a href="#4-1-響應JSON" class="headerlink" title="4.1 響應JSON"></a>4.1 響應JSON</h3><h5 id="4-1-1-jackson-jar-ResponseBody"><a href="#4-1-1-jackson-jar-ResponseBody" class="headerlink" title="4.1.1 jackson.jar+@ResponseBody"></a>4.1.1 jackson.jar+@ResponseBody</h5><p><code>spring-boot-starter-web</code>的開發環境中，已經自動引入了jason場景 =&gt; 可以使用<code>@ResponseBody</code>给前端自动返回json数据</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- web场景自动引入了json场景 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;
    &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>jason場景包含主要的jackson依賴</p>
<img src=" 20230317_012214.jpg" style="zoom:67%;" />

<p>控制层代码如下：</p>
<pre><code class="java">@Controller
public class ResponseTestController &#123;
    
    @ResponseBody  //利用返回值处理器里面的消息转换器进行处理
    @GetMapping(value = &quot;/test/person&quot;)
    public Person getPerson()&#123;
        Person person = new Person();
        person.setAge(28);
        person.setBirth(new Date());
        person.setUserName(&quot;zhangsan&quot;);
        return person;
    &#125;

&#125;
</code></pre>
<h6 id="1-返回值解析器"><a href="#1-返回值解析器" class="headerlink" title="1. 返回值解析器"></a>1. 返回值解析器</h6><img src=" 20230317_104635.jpg" alt="img" style="zoom:67%;" />



<pre><code class="java">try &#123;
            this.returnValueHandlers.handleReturnValue(
                    returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
        &#125;
</code></pre>
<pre><code class="java">    @Override
    public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
            ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123;

        HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);
        if (handler == null) &#123;
            throw new IllegalArgumentException(&quot;Unknown return value type: &quot; + returnType.getParameterType().getName());
        &#125;
        handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);
    &#125;
</code></pre>
<pre><code class="java">//RequestResponseBodyMethodProcessor      
@Override
    public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
            ModelAndViewContainer mavContainer, NativeWebRequest webRequest)
            throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException &#123;

        mavContainer.setRequestHandled(true);
        ServletServerHttpRequest inputMessage = createInputMessage(webRequest);
        ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);

        // Try even with null return value. ResponseBodyAdvice could get involved.
        // 使用消息转换器进行写出操作
        writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);
    &#125;
</code></pre>
<h6 id="2、返回值解析器原理"><a href="#2、返回值解析器原理" class="headerlink" title="2、返回值解析器原理"></a>2、返回值解析器原理</h6> <img src=" 20230317_104914.jpg" alt="img" style="zoom:67%;" />



<ul>
<li><p>1、返回值处理器判断是否支持这种类型返回值 -&gt;  <code>supportsReturnType</code></p>
</li>
<li><p>2、返回值处理器调用 <code>handleReturnValue </code>进行处理</p>
</li>
<li><p>3、<code>RequestResponseBodyMethodProcessor </code>可以处理返回值标了<code>@ResponseBody</code> 注解的。</p>
</li>
<li><ul>
<li>利用 MessageConverters 进行处理 将数据写为json</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>3.1、内容协商（浏览器默认会以请求头的方式告诉服务器他能接受什么样的内容类型）</li>
</ul>
</li>
</ul>
</li>
<li><p>3.2、服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据，</p>
</li>
<li><p>3.3、根據上述3.1&amp;3.2，SpringMVC会挨个遍历所有容器底层的 HttpMessageConverter 進行匹配，看谁能处理？</p>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>1、得到MappingJackson2HttpMessageConverter可以将对象写为json</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2、利用MappingJackson2HttpMessageConverter将对象转为json再写出去。</p>
</li>
</ul>
<p>内容协商：</p>
 <img src=" 20230317_105117.jpg" alt="img" style="zoom: 80%;" />





<h5 id="4-1-2、SpringMVC到底支持哪些返回值"><a href="#4-1-2、SpringMVC到底支持哪些返回值" class="headerlink" title="4.1.2、SpringMVC到底支持哪些返回值"></a>4.1.2、SpringMVC到底支持哪些返回值</h5><pre><code class="java">ModelAndView
Model
View
ResponseEntity 
ResponseBodyEmitter
StreamingResponseBody
HttpEntity
HttpHeaders
Callable
DeferredResult
ListenableFuture
CompletionStage
WebAsyncTask
有 @ModelAttribute 且为对象类型的
有 @ResponseBody 注解 ---&gt; 會使用RequestResponseBodyMethodProcessor返回json數據；
</code></pre>
<blockquote>
<ul>
<li>使用@ResponseBody 注解時，返回值會經由RequestResponseBodyMethodProcessor處理，會使用各種MessageConverter來看誰能處理</li>
</ul>
</blockquote>
<h5 id="4-1-3、HTTPMessageConverter原理"><a href="#4-1-3、HTTPMessageConverter原理" class="headerlink" title="4.1.3、HTTPMessageConverter原理"></a>4.1.3、HTTPMessageConverter原理</h5><h6 id="1、MessageConverter规范"><a href="#1、MessageConverter规范" class="headerlink" title="1、MessageConverter规范"></a>1、MessageConverter规范</h6> <img src=" 20230317_105750.jpg" alt="img" style="zoom: 50%;" />

<p>HttpMessageConverter: 看是否支持将 此 Class类型的对象，转为MediaType类型的数据。</p>
<p>例子：Person对象转为JSON。或者 JSON转为Person</p>
<h6 id="2、默认的MessageConverter"><a href="#2、默认的MessageConverter" class="headerlink" title="2、默认的MessageConverter"></a>2、默认的MessageConverter</h6> <img src=" 20230317_110003.jpg" alt="img" style="zoom: 80%;" />

<p>0 - 只支持Byte类型的</p>
<p>1 - String</p>
<p>2 - String</p>
<p>3 - Resource</p>
<p>4 - ResourceRegion</p>
<p>5 - DOMSource.*<em>class *</em> SAXSource.<strong>class</strong>) \ StAXSource.**class **StreamSource.**class **Source.<strong>class</strong></p>
<p><strong>6 -</strong> MultiValueMap</p>
<p>7 - <strong>true</strong></p>
<p><strong>8 - true</strong></p>
<p><strong>9 - 支持注解方式xml处理的。</strong></p>
<p>最终 MappingJackson2HttpMessageConverter  把对象转为JSON（利用底层的jackson的objectMapper转换的）</p>
 <img src=" 20230317_110147.jpg" alt="img" style="zoom: 67%;" />



<h3 id="4-2-内容协商"><a href="#4-2-内容协商" class="headerlink" title="4.2 内容协商"></a>4.2 内容协商</h3><p>根据客户端接收能力不同，返回不同媒体类型的数据。</p>
<h5 id="4-2-1-引入XML依赖："><a href="#4-2-1-引入XML依赖：" class="headerlink" title="4.2.1 引入XML依赖："></a>4.2.1 引入XML依赖：</h5><pre><code class="xml">&lt;!--jackson裡面支持xml的依賴--&gt;
&lt;dependency&gt;
     &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;
     &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h5 id="4-2-2-postman分别测试返回json和xml"><a href="#4-2-2-postman分别测试返回json和xml" class="headerlink" title="4.2.2 postman分别测试返回json和xml"></a>4.2.2 postman分别测试返回json和xml</h5><p>只需要改变请求头中Accept字段。Http协议中规定的，告诉服务器本客户端可以接收的数据类型。</p>
<img src=" 20230317_135844.jpg" alt="img" style="zoom: 50%;" />



<h5 id="4-2-3-开启浏览器参数方式内容协商功能"><a href="#4-2-3-开启浏览器参数方式内容协商功能" class="headerlink" title="4.2.3 开启浏览器参数方式内容协商功能"></a>4.2.3 开启浏览器参数方式内容协商功能</h5><p><code>post man</code>可以簡單修改請求頭裡面的accept，以決定需要的返回參數類型，但瀏覽器無法修改，只能使用默認的請求頭，或使用ajax發起異步請求時定義返回參數類型，为了方便内容协商，SpringBoot裡可以開啟基於请求参数的内容协商功能。</p>
<pre><code class="yaml">spring:
    contentnegotiation:
      favor-parameter: true  #开启请求参数内容协商模式
</code></pre>
<ul>
<li>如何使用：</li>
</ul>
<p>在請求後面增加參數format=xxx即可，如下 ：</p>
<p><code>http://localhost:8080/test/person?format=json</code> =&gt; 返回JSON</p>
<p><code>http://localhost:8080/test/person?format=xml</code> =&gt; 返回xml</p>
<ul>
<li>原碼解析：</li>
</ul>
<p>開啟请求参数内容协商模式後，協商管理器內會新增一組參數協商策略<code>ParameterContentNegotiationStrategy </code>，</p>
 <img src=" 20230317_150001.jpg" alt="img" style="zoom: 67%;border: 5px solid orange;" />

<p>确定客户端接收什么样的内容类型；</p>
<p>1、Parameter策略优先确定是要返回json数据（获取请求头中的format的值）</p>
  <img src=" 20230317_150047.jpg" alt="img" style="zoom: 80%;border: 4px solid orange;;" />

<p>2、最终进行内容协商返回给客户端json即可。</p>
<h5 id="4-2-4-内容协商原理"><a href="#4-2-4-内容协商原理" class="headerlink" title="4.2.4 内容协商原理"></a>4.2.4 内容协商原理</h5><ul>
<li><p>1、判断当前响应头中是否已经有确定的媒体类型。MediaType</p>
</li>
<li><p>2、获取客户端（PostMan、浏览器）支持接收的内容类型。（获取客户端Accept请求头字段）【application/xml】</p>
</li>
<li><ul>
<li><p><strong>2.1、contentNegotiationManager 内容协商管理器</strong>：默认使用基于请求头的策略 -&gt; 取得客戶端支持的接收內容</p>
<pre><code>&lt;img src=&quot; 20230317_150132.jpg&quot; alt=&quot;img&quot; style=&quot;zoom: 67%;border: 5px solid orange;&quot; /&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>2.2、HeaderContentNegotiationStrategy 請求頭協商策略</strong>： 确定客户端可以接收的内容类型</p>
<pre><code>&lt;img src=&quot; 20230317_150229.jpg&quot; alt=&quot;img&quot; style=&quot;zoom: 67%;border: 5px solid orange;&quot; /&gt;
</code></pre>
</li>
<li><p>3、遍历循环所有当前系统的 <strong>MessageConverter</strong>，看谁支持操作这个对象（Person）</p>
</li>
<li><p>4、找到支持操作Person的converter，把converter支持的媒体类型统计出来。</p>
</li>
<li><p>5、客户端需要【application/xml】。服务端能力【10种、json、xml】</p>
<pre><code>&lt;img src=&quot; 20230317_150326.jpg&quot; alt=&quot;img&quot; style=&quot;zoom: 67%;border: 5px solid orange;&quot; /&gt;
</code></pre>
</li>
<li><p>6、进行内容协商找出<font color=red><strong>最佳匹配媒体类型</strong></font> (並非完全匹配)</p>
</li>
<li><p>7、用支持最佳匹配媒体类型的converter，调用它将对象转为最佳匹配媒体类型 。</p>
</li>
</ul>
 <img src=" 20230317_150403.jpg" alt="img" style="zoom: 67%;border: 5px solid orange;" />



<ul>
<li>擴展</li>
</ul>
<p>源碼底層默認導入了上述default converter，並且判斷若导入了jackson处理xml的包，則xml的converter就会自动进来，代碼如下：</p>
<pre><code class="java">//WebMvcConfigurationSupport
jackson2XmlPresent = ClassUtils.isPresent(&quot;com.fasterxml.jackson.dataformat.xml.XmlMapper&quot;, classLoader);

if (jackson2XmlPresent) &#123;
            Jackson2ObjectMapperBuilder builder = Jackson2ObjectMapperBuilder.xml();
            if (this.applicationContext != null) &#123;
                builder.applicationContext(this.applicationContext);
            &#125;
            messageConverters.add(new MappingJackson2XmlHttpMessageConverter(builder.build()));
        &#125;
</code></pre>
<h5 id="4-2-5-自定义-MessageConverter"><a href="#4-2-5-自定义-MessageConverter" class="headerlink" title="4.2.5 自定义 MessageConverter"></a>4.2.5 自定义 MessageConverter</h5><p><strong>实现多协议数据兼容。json、xml、x-guigu</strong></p>
<p><strong>0、</strong>@ResponseBody 响应数据出去 调用 <strong>RequestResponseBodyMethodProcessor</strong> 处理</p>
<p>1、Processor 处理方法返回值。通过 <strong>MessageConverter</strong> 处理</p>
<p>2、所有 <strong>MessageConverter</strong> 合起来可以支持各种媒体类型数据的操作（读、写）</p>
<p>3、内容协商找到最终的 <strong>messageConverter</strong>；</p>
<ul>
<li>無論要改SpringMVC的什么功能。都是通過一个入口進行修改，就是给容器中添加一个  WebMvcConfigurer，並在裡面添加要修改的內容</li>
</ul>
<pre><code class="java"> @Bean
    public WebMvcConfigurer webMvcConfigurer()&#123;
        return new WebMvcConfigurer() &#123;

            @Override
            public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;

            &#125;
        &#125;
    &#125;
</code></pre>
<ul>
<li>內容協商管理器支持參數協商策略及請求頭協商策略，參數協商策略默認只支持xml、JSON格式。</li>
</ul>
 <img src=" 20230320_010653.jpg" alt="img" style="zoom:67%;" />



<ul>
<li> 若要自訂義支持格式，需自訂義內容協商策略 ( 给容器中添加一个  WebMvcConfigurer，並在裡面添加要修改的內容)</li>
</ul>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
public class WebConfig /*implements WebMvcConfigurer*/ &#123;

    //1、WebMvcConfigurer定制化SpringMVC的功能
    @Bean
    public WebMvcConfigurer webMvcConfigurer()&#123;
        return new WebMvcConfigurer() &#123;

            /**
             * 自定义内容协商策略
             * @param configurer
             */
            @Override
            public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;
                //Map&lt;String, MediaType&gt; mediaTypes
                Map&lt;String, MediaType&gt; mediaTypes = new HashMap&lt;&gt;();
                mediaTypes.put(&quot;json&quot;,MediaType.APPLICATION_JSON);
                mediaTypes.put(&quot;xml&quot;,MediaType.APPLICATION_XML);
                //自定义媒体类型
                mediaTypes.put(&quot;gg&quot;,MediaType.parseMediaType(&quot;application/x-guigu&quot;));
                //指定支持解析哪些参数对应的哪些媒体类型
                ParameterContentNegotiationStrategy parameterStrategy = new ParameterContentNegotiationStrategy(mediaTypes);
//                parameterStrategy.setParameterName(&quot;ff&quot;); =&gt;將路徑帶參數的format改為自訂義名稱ff

                //还需添加请求头处理策略，否则accept:application/json、application/xml则会失效
                HeaderContentNegotiationStrategy headeStrategy = new HeaderContentNegotiationStrategy();

                configurer.strategies(Arrays.asList(parameterStrategy, headeStrategy));
            &#125;
        &#125;
    &#125;
    
    ...
    
&#125;
</code></pre>
<p>自訂義的內容協商策略支持格式如下</p>
 <img src=" 20230320_010745.jpg" alt="img" style="zoom:67%;" />

<blockquote>
<p>注意：自訂義內容協商策略若只添加<code>ParameterContentNegotiationStrategy</code>，則沒有請求頭協商策略。此時只能接受請求路徑帶參數格式format過來的請求，若瀏覽器發送以請求頭格式發送請求過來，無論發送什麼請求格式，都會匹配到*/*，最終都會回傳json格式，因此必須將請求頭策略<code>HeaderContentNegotiationStrategy</code>也新增進去才可。</p>
</blockquote>
<p><strong>有可能我们添加的自定义的功能会覆盖默认很多功能，导致一些默认的功能失效。</strong></p>
<p><strong>大家考虑，上述功能除了我们完全自定义外？SpringBoot有没有为我们提供基于配置文件的快速修改媒体类型功能？怎么配置呢？【提示：参照SpringBoot官方文档web开发内容协商章节】</strong></p>
<h2 id="5-视图解析与模板引擎"><a href="#5-视图解析与模板引擎" class="headerlink" title="5. 视图解析与模板引擎"></a>5. 视图解析与模板引擎</h2><p>视图解析：<strong>SpringBoot默认不支持 JSP，需要引入第三方模板引擎技术实现页面渲染。</strong></p>
<h3 id="5-1-視圖解析"><a href="#5-1-視圖解析" class="headerlink" title="5.1 視圖解析"></a>5.1 視圖解析</h3><img src=" 20230320_153109.jpg" alt="img" style="zoom:67%;" />



<h5 id="5-1-1视图解析原理流程-【源碼解析】"><a href="#5-1-1视图解析原理流程-【源碼解析】" class="headerlink" title="5.1.1视图解析原理流程 【源碼解析】"></a>5.1.1视图解析原理流程 【源碼解析】</h5><p>1、目标方法处理的过程中，所有数据都会被放在 <strong>ModelAndViewContainer 里面。包括数据和视图地址</strong></p>
<p><strong>2、方法的参数是一个自定义类型对象（从请求参数中确定的），把他重新放在</strong> <strong>ModelAndViewContainer</strong></p>
<p><strong>3、任何目标方法执行完成以后都会返回 ModelAndView（数据和视图地址）。</strong></p>
<p><strong>4、processDispatchResult  处理派发结果（页面該如何响应）</strong></p>
<ul>
<li><p><strong>render</strong>(<strong>mv</strong>, request, response); 进行页面渲染逻辑</p>
</li>
<li><ul>
<li>根据方法的String返回值得到 <strong>View</strong> 对象【定义了页面的渲染逻辑】</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>1、所有的视图解析器尝试是否能根据当前返回值得到<strong>View</strong>对象</li>
</ul>
</li>
</ul>
</li>
<li><p>2、根據返回值得到了RedirectView  ：<strong>redirect:/main.html</strong> –&gt; Thymeleaf new <strong>RedirectView</strong>()</p>
</li>
<li><p>3、ContentNegotiationViewResolver 里面包含了下面所有的视图解析器，内部还是利用下面所有视图解析器得到视图对象。</p>
</li>
<li><p>4、view.render(mv.getModelInternal(), request, response);   视图对象调用自定义的render进行页面渲染工作</p>
</li>
<li><ul>
<li><ul>
<li><ul>
<li><strong>RedirectView 如何渲染【重定向到一个页面】</strong></li>
</ul>
</li>
<li><strong>1、获取目标url地址</strong></li>
<li><strong>2、response.sendRedirect(encodedURL);</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>视图解析按照不同的規則，返回不同的視圖：</strong></li>
</ul>
<ul>
<li><ul>
<li><strong>返回值以 forward: 开始： new InternalResourceView(forwardUrl); –&gt;  转发request.getRequestDispatcher(path).forward(request, response);</strong></li>
</ul>
</li>
<li><strong>返回值以</strong> <strong>redirect: 开始：</strong> <strong>new RedirectView() –》 render就是重定向</strong></li>
<li><strong>返回值是普通字符串： new ThymeleafView（）—&gt;</strong></li>
</ul>
<p>自定义视图解析器+自定义视图； <strong>詳見大厂学院。</strong></p>
<ul>
<li>所有的視圖解析器如下：</li>
</ul>
 <img src=" 20230320_153446.jpg" alt="img" style="zoom:67%;" />



<ul>
<li>ContentNegotiationViewResolver 里面包含了下面所有的视图解析器</li>
</ul>
 <img src=" 20230320_153517.jpg" alt="img" style="zoom:67%;" />



<ul>
<li>视图对象调用自定义的render进行页面渲染工作</li>
</ul>
 <img src=" 20230320_153420.jpg" alt="img" style="zoom:67%;" />





<h3 id="5-2-模板引擎-Thymeleaf"><a href="#5-2-模板引擎-Thymeleaf" class="headerlink" title="5.2 模板引擎-Thymeleaf"></a>5.2 模板引擎-Thymeleaf</h3><h5 id="5-2-1-thymeleaf简介"><a href="#5-2-1-thymeleaf简介" class="headerlink" title="5.2.1 thymeleaf简介"></a>5.2.1 thymeleaf简介</h5><p>Thymeleaf is a modern server-side Java template engine for both web and standalone environments, capable of processing HTML, XML, JavaScript, CSS and even plain text.</p>
<p><strong>现代化、服务端Java模板引擎</strong></p>
<h5 id="5-2-2-基本语法"><a href="#5-2-2-基本语法" class="headerlink" title="5.2.2 基本语法"></a>5.2.2 基本语法</h5><h6 id="1、表达式"><a href="#1、表达式" class="headerlink" title="1、表达式"></a>1、表达式</h6><table>
<thead>
<tr>
<th>表达式名字</th>
<th>语法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>变量取值</td>
<td>${…}</td>
<td>获取请求域、session域、对象等值</td>
</tr>
<tr>
<td>选择变量</td>
<td>*{…}</td>
<td>获取上下文对象值</td>
</tr>
<tr>
<td>消息</td>
<td>#{…}</td>
<td>获取国际化等值</td>
</tr>
<tr>
<td>链接</td>
<td>@{…}</td>
<td>生成链接</td>
</tr>
<tr>
<td>片段表达式</td>
<td>~{…}</td>
<td>jsp:include 作用，引入公共页面片段</td>
</tr>
</tbody></table>
<h6 id="2、字面量"><a href="#2、字面量" class="headerlink" title="2、字面量"></a>2、字面量</h6><ul>
<li><p>文本值: <strong>‘one text’</strong> <strong>,</strong> <strong>‘Another one!’</strong></p>
</li>
<li><p>数字: <strong>0</strong> <strong>,</strong> <strong>34</strong> <strong>,</strong> <strong>3.0</strong> <strong>,</strong> <strong>12.3</strong> ****</p>
</li>
<li><p>布尔值: <strong>true</strong> <strong>,</strong> <strong>false</strong></p>
</li>
<li><p>空值: <strong>null</strong></p>
</li>
<li><p>变量： one，two，…. 变量不能有空格</p>
</li>
</ul>
<h6 id="3、文本操作"><a href="#3、文本操作" class="headerlink" title="3、文本操作"></a>3、文本操作</h6><ul>
<li><p>字符串拼接: <strong>+</strong></p>
</li>
<li><p>变量替换: <strong>|The name is ${name}|</strong></p>
</li>
</ul>
<h6 id="4、数学运算"><a href="#4、数学运算" class="headerlink" title="4、数学运算"></a>4、数学运算</h6><ul>
<li>运算符: + , - , * , / , %</li>
</ul>
<h6 id="5、布尔运算"><a href="#5、布尔运算" class="headerlink" title="5、布尔运算"></a>5、布尔运算</h6><ul>
<li><p>运算符:  <strong>and</strong> <strong>,</strong> <strong>or</strong></p>
</li>
<li><p>一元运算: <strong>!</strong> <strong>,</strong> <strong>not</strong></p>
</li>
</ul>
<h6 id="6、比较运算"><a href="#6、比较运算" class="headerlink" title="6、比较运算"></a>6、比较运算</h6><ul>
<li>比较: <strong>&gt;</strong> <strong>,</strong> <strong>&lt;** **,** **&gt;=</strong> <strong>,</strong> <strong>&lt;=</strong> <strong>(</strong> <strong>gt</strong> <strong>,</strong> <strong>lt</strong> <strong>,</strong> <strong>ge</strong> <strong>,</strong> <strong>le</strong> <strong>)</strong></li>
<li>等式: <strong>==</strong> <strong>,</strong> <strong>!=</strong> <strong>(</strong> <strong>eq</strong> <strong>,</strong> <strong>ne</strong> <strong>)</strong></li>
</ul>
<h6 id="7、条件运算"><a href="#7、条件运算" class="headerlink" title="7、条件运算"></a>7、条件运算</h6><ul>
<li><p>If-then: <strong>(if) ? (then)</strong></p>
</li>
<li><p>If-then-else: <strong>(if) ? (then) : (else)</strong></p>
</li>
<li><p>Default: (value) <strong>?: (defaultvalue)</strong></p>
</li>
</ul>
<h6 id="8、特殊操作"><a href="#8、特殊操作" class="headerlink" title="8、特殊操作"></a>8、特殊操作</h6><ul>
<li>无操作： _</li>
</ul>
<blockquote>
<p>thymeleaf内联写法：</p>
<pre><code class="html">&lt;p&gt;Hello, [[$&#123;session.user.name&#125;]]!&lt;/p&gt;
</code></pre>
</blockquote>
<h5 id="5-2-3-设置属性值-th-attr"><a href="#5-2-3-设置属性值-th-attr" class="headerlink" title="5.2.3 设置属性值-th:attr"></a>5.2.3 设置属性值-th:attr</h5><p>设置单个值</p>
<pre><code class="html">&lt;form action=&quot;subscribe.html&quot; th:attr=&quot;action=@&#123;/subscribe&#125;&quot;&gt;
  &lt;fieldset&gt;
    &lt;input type=&quot;text&quot; name=&quot;email&quot; /&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Subscribe!&quot; th:attr=&quot;value=#&#123;subscribe.submit&#125;&quot;/&gt;
  &lt;/fieldset&gt;
&lt;/form&gt;
</code></pre>
<p>设置多个值</p>
<pre><code class="html">&lt;img src=&quot;../../images/gtvglogo.png&quot;  th:attr=&quot;src=@&#123;/images/gtvglogo.png&#125;,title=#&#123;logo&#125;,alt=#&#123;logo&#125;&quot; /&gt;
</code></pre>
<p>以上两个的代替写法 th:xxxx</p>
<pre><code class="html">&lt;input type=&quot;submit&quot; value=&quot;Subscribe!&quot; th:value=&quot;#&#123;subscribe.submit&#125;&quot;/&gt;
&lt;form action=&quot;subscribe.html&quot; th:action=&quot;@&#123;/subscribe&#125;&quot;&gt;
</code></pre>
<p>所有h5兼容的标签写法</p>
<p><a target="_blank" rel="noopener" href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#setting-value-to-specific-attributes">https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#setting-value-to-specific-attributes</a></p>
<h5 id="5-2-4-迭代"><a href="#5-2-4-迭代" class="headerlink" title="5.2.4 迭代"></a>5.2.4 迭代</h5><pre><code class="html">&lt;tr th:each=&quot;prod : $&#123;prods&#125;&quot;&gt;
        &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;/td&gt;
        &lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;/td&gt;
        &lt;td th:text=&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;/td&gt;
&lt;/tr&gt;
</code></pre>
<pre><code class="html">&lt;tr th:each=&quot;prod,iterStat : $&#123;prods&#125;&quot; th:class=&quot;$&#123;iterStat.odd&#125;? &#39;odd&#39;&quot;&gt;
  &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Onions&lt;/td&gt;
  &lt;td th:text=&quot;$&#123;prod.price&#125;&quot;&gt;2.41&lt;/td&gt;
  &lt;td th:text=&quot;$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;&quot;&gt;yes&lt;/td&gt;
&lt;/tr&gt;
</code></pre>
<h5 id="5-2-5-条件运算"><a href="#5-2-5-条件运算" class="headerlink" title="5.2.5 条件运算"></a>5.2.5 条件运算</h5><pre><code class="html">&lt;a href=&quot;comments.html&quot;
th:href=&quot;@&#123;/product/comments(prodId=$&#123;prod.id&#125;)&#125;&quot;
th:if=&quot;$&#123;not #lists.isEmpty(prod.comments)&#125;&quot;&gt;view&lt;/a&gt;
</code></pre>
<pre><code class="html">&lt;div th:switch=&quot;$&#123;user.role&#125;&quot;&gt;
  &lt;p th:case=&quot;&#39;admin&#39;&quot;&gt;User is an administrator&lt;/p&gt;
  &lt;p th:case=&quot;#&#123;roles.manager&#125;&quot;&gt;User is a manager&lt;/p&gt;
  &lt;p th:case=&quot;*&quot;&gt;User is some other thing&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<h5 id="5-2-6-属性优先级"><a href="#5-2-6-属性优先级" class="headerlink" title="5.2.6 属性优先级"></a>5.2.6 属性优先级</h5><table>
<thead>
<tr>
<th align="left">Order</th>
<th align="left">Feature</th>
<th align="left">Attributes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">Fragment inclusion</td>
<td align="left"><code>th:insert</code> <code>th:replace</code></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Fragment iteration</td>
<td align="left"><code>th:each</code></td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Conditional evaluation</td>
<td align="left"><code>th:if</code> <code>th:unless</code> <code>th:switch</code> <code>th:case</code></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">Local variable definition</td>
<td align="left"><code>th:object</code> <code>th:with</code></td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">General attribute modification</td>
<td align="left"><code>th:attr</code> <code>th:attrprepend</code> <code>th:attrappend</code></td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">Specific attribute modification</td>
<td align="left"><code>th:value</code> <code>th:href</code> <code>th:src</code> <code>...</code></td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">Text (tag body modification)</td>
<td align="left"><code>th:text</code> <code>th:utext</code></td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">Fragment specification</td>
<td align="left"><code>th:fragment</code></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">Fragment removal</td>
<td align="left"><code>th:remove</code></td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#attribute-precedence">官方文档 - 10 Attribute Precedence</a></p>
<h3 id="5-3-thymeleaf使用"><a href="#5-3-thymeleaf使用" class="headerlink" title="5.3 thymeleaf使用"></a>5.3 thymeleaf使用</h3><h5 id="5-3-1-引入Starter"><a href="#5-3-1-引入Starter" class="headerlink" title="5.3.1 引入Starter"></a>5.3.1 引入Starter</h5><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h5 id="5-3-2-自动配置好了thymeleaf"><a href="#5-3-2-自动配置好了thymeleaf" class="headerlink" title="5.3.2 自动配置好了thymeleaf"></a>5.3.2 自动配置好了thymeleaf</h5><pre><code class="java">@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(ThymeleafProperties.class)
@ConditionalOnClass(&#123; TemplateMode.class, SpringTemplateEngine.class &#125;)
@AutoConfigureAfter(&#123; WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class &#125;)
public class ThymeleafAutoConfiguration &#123;
    ...
&#125;
</code></pre>
<p>自动配好的策略</p>
<ol>
<li><p>所有thymeleaf的配置值都在 ThymeleafProperties</p>
</li>
<li><p>配置好了 <strong>SpringTemplateEngine</strong></p>
</li>
<li><p>配好了 <strong>ThymeleafViewResolver</strong></p>
</li>
<li><p>我们只需要直接开发页面</p>
</li>
</ol>
<pre><code class="java">public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;//模板放置处
public static final String DEFAULT_SUFFIX = &quot;.html&quot;;//文件的后缀名
</code></pre>
<h5 id="5-3-3-頁面開發"><a href="#5-3-3-頁面開發" class="headerlink" title="5.3.3 頁面開發"></a>5.3.3 頁面開發</h5><p>编写一个控制层：</p>
<pre><code class="java">@Controller
public class ViewTestController &#123;
    @GetMapping(&quot;/hello&quot;)
    public String hello(Model model)&#123;
        //model中的数据会被放在请求域中 request.setAttribute(&quot;a&quot;,aa)
        model.addAttribute(&quot;msg&quot;,&quot;一定要大力发展工业文化&quot;);
        model.addAttribute(&quot;link&quot;,&quot;http://www.baidu.com&quot;);
        return &quot;success&quot;;
    &#125;
&#125;
</code></pre>
<p><code>/templates/success.html</code>：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1 th:text=&quot;$&#123;msg&#125;&quot;&gt;nice&lt;/h1&gt;
&lt;h2&gt;
    &lt;a href=&quot;www.baidu.com&quot; th:href=&quot;$&#123;link&#125;&quot;&gt;去百度&lt;/a&gt;  &lt;br/&gt;
    &lt;a href=&quot;www.google.com&quot; th:href=&quot;@&#123;/link&#125;&quot;&gt;去百度&lt;/a&gt;
&lt;/h2&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<hr>
<pre><code class="yaml">server:
  servlet:
    context-path: /app #设置应用名
</code></pre>
<p>配置了context-path後，執行的URL前面要插入<code>/app</code>,  如要訪問/hello時，要訪問<code>http://localhost:8080/app/hello</code>。</p>
<h3 id="5-4-構建后台管理系统"><a href="#5-4-構建后台管理系统" class="headerlink" title="5.4 構建后台管理系统"></a>5.4 構建后台管理系统</h3><h5 id="5-4-1-项目创建"><a href="#5-4-1-项目创建" class="headerlink" title="5.4.1 项目创建"></a>5.4.1 项目创建</h5><p>使用IDEA的Spring Initializr。</p>
<ul>
<li>thymeleaf、</li>
<li>web-starter、</li>
<li>devtools、</li>
<li>lombok</li>
</ul>
<h5 id="5-4-2-靜態資源處理"><a href="#5-4-2-靜態資源處理" class="headerlink" title="5.4.2 靜態資源處理"></a>5.4.2 靜態資源處理</h5><p>自动配置好，我们只需要把所有静态资源放到 static 文件夹下</p>
<h5 id="5-4-3-路徑構建"><a href="#5-4-3-路徑構建" class="headerlink" title="5.4.3 路徑構建"></a>5.4.3 路徑構建</h5><p>th:action=”@{/login}”</p>
<h5 id="5-4-4-模板抽取"><a href="#5-4-4-模板抽取" class="headerlink" title="5.4.4 模板抽取"></a>5.4.4 模板抽取</h5><p>th:insert/replace/include</p>
<h5 id="5-4-5-頁面跳轉"><a href="#5-4-5-頁面跳轉" class="headerlink" title="5.4.5 頁面跳轉"></a>5.4.5 頁面跳轉</h5><ul>
<li>Login控制层</li>
</ul>
<pre><code class="java">@Controller
public class IndexController &#123;
    /**
     * 来登录页
     * @return
     */
    @GetMapping(value = &#123;&quot;/&quot;,&quot;/login&quot;&#125;)
    public String loginPage()&#123;

        return &quot;login&quot;;
    &#125;

    @PostMapping(&quot;/login&quot;)
    public String main(User user, HttpSession session, Model model)&#123; //RedirectAttributes

        if(StringUtils.hasLength(user.getUserName()) &amp;&amp; &quot;123456&quot;.equals(user.getPassword()))&#123;
            //把登陆成功的用户保存起来
            session.setAttribute(&quot;loginUser&quot;,user);
            //登录成功重定向到main.html;  重定向防止表单重复提交
            return &quot;redirect:/main.html&quot;;
        &#125;else &#123;
            model.addAttribute(&quot;msg&quot;,&quot;账号密码错误&quot;);
            //回到登录页面
            return &quot;login&quot;;
        &#125;
    &#125;
    
     /**
     * 去main页面
     * @return
     */
    @GetMapping(&quot;/main.html&quot;)
    public String mainPage(HttpSession session, Model model)&#123;
        
        //最好用拦截器,过滤器
        Object loginUser = session.getAttribute(&quot;loginUser&quot;);
        if(loginUser != null)&#123;
            return &quot;main&quot;;
        &#125;else &#123;
            //session过期，没有登陆过
            //回到登录页面
            model.addAttribute(&quot;msg&quot;,&quot;请重新登录&quot;);
            return &quot;login&quot;;
        &#125;
    &#125;
    
&#125;
</code></pre>
<h5 id="5-4-6-數據渲染"><a href="#5-4-6-數據渲染" class="headerlink" title="5.4.6 數據渲染"></a>5.4.6 數據渲染</h5><ul>
<li><code>/templates/login.html</code> 登录页</li>
</ul>
<pre><code class="html">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;!-- 要加这玩意thymeleaf才能用 --&gt;

&lt;form class=&quot;form-signin&quot; action=&quot;index.html&quot; method=&quot;post&quot; th:action=&quot;@&#123;/login&#125;&quot;&gt;

    ...
    
    &lt;!-- 消息提醒 --&gt;
    &lt;label style=&quot;color: red&quot; th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/label&gt;
    
    &lt;input type=&quot;text&quot; name=&quot;userName&quot; class=&quot;form-control&quot; placeholder=&quot;User ID&quot; autofocus&gt;
    &lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot;&gt;
    
    &lt;button class=&quot;btn btn-lg btn-login btn-block&quot; type=&quot;submit&quot;&gt;
        &lt;i class=&quot;fa fa-check&quot;&gt;&lt;/i&gt;
    &lt;/button&gt;
    
    ...
    
&lt;/form&gt;
</code></pre>
<ul>
<li><code>/templates/main.html</code> 主页</li>
</ul>
<pre><code class="html">&lt;table class=&quot;display table table-bordered&quot; id=&quot;hidden-table-info&quot;&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;#&lt;/th&gt;
            &lt;th&gt;用户名&lt;/th&gt;
            &lt;th&gt;密码&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr class=&quot;gradeX&quot; th:each=&quot;user,stats:$&#123;users&#125;&quot;&gt;
            &lt;td th:text=&quot;$&#123;stats.count&#125;&quot;&gt;Trident&lt;/td&gt;
            &lt;td th:text=&quot;$&#123;user.userName&#125;&quot;&gt;Internet&lt;/td&gt;
            &lt;td &gt;[[$&#123;user.password&#125;]]&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
</code></pre>
<h2 id="6-拦截器"><a href="#6-拦截器" class="headerlink" title="6. 拦截器"></a>6. 拦截器</h2><p>使用方法：</p>
<ul>
<li>1、编写一个拦截器实现HandlerInterceptor接口</li>
<li>2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors）</li>
<li>3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】</li>
</ul>
<h3 id="6-1-HandlerInterceptor-接口"><a href="#6-1-HandlerInterceptor-接口" class="headerlink" title="6.1 HandlerInterceptor 接口"></a>6.1 HandlerInterceptor 接口</h3><pre><code class="java">/**
 * 登录检查
 * 1、配置好拦截器要拦截哪些请求
 * 2、把这些配置放在容器中
 */
@Slf4j
public class LoginInterceptor implements HandlerInterceptor &#123;

    /**
     * 目标方法执行之前
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;

        String requestURI = request.getRequestURI();
        log.info(&quot;preHandle拦截的请求路径是&#123;&#125;&quot;,requestURI);

        //登录检查逻辑
        HttpSession session = request.getSession();

        Object loginUser = session.getAttribute(&quot;loginUser&quot;);

        if(loginUser != null)&#123;
            //放行
            return true;
        &#125;

        //拦截住。未登录。跳转到登录页
        request.setAttribute(&quot;msg&quot;,&quot;请先登录&quot;);
//        re.sendRedirect(&quot;/&quot;);
        request.getRequestDispatcher(&quot;/&quot;).forward(request,response);
        return false;
    &#125;

    /**
     * 目标方法执行完成以后
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        log.info(&quot;postHandle执行&#123;&#125;&quot;,modelAndView);
    &#125;

    /**
     * 页面渲染以后
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;
        log.info(&quot;afterCompletion执行异常&#123;&#125;&quot;,ex);
    &#125;
&#125;
</code></pre>
<h3 id="6-2-配置拦截器"><a href="#6-2-配置拦截器" class="headerlink" title="6.2 配置拦截器"></a>6.2 配置拦截器</h3><pre><code class="java">/**
 * 1、编写一个拦截器实现HandlerInterceptor接口
 * 2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors）
 * 3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】
 */
@Configuration
public class AdminWebConfig implements WebMvcConfigurer &#123;

    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        registry.addInterceptor(new LoginInterceptor())
                .addPathPatterns(&quot;/**&quot;)  //所有请求都被拦截包括静态资源
                .excludePathPatterns(&quot;/&quot;,&quot;/login&quot;,&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/images/**&quot;,&quot;/js/**&quot;); //放行的请求
    &#125;
&#125;
</code></pre>
<h3 id="6-3-拦截器原理"><a href="#6-3-拦截器原理" class="headerlink" title="6.3 拦截器原理"></a>6.3 拦截器原理</h3><p>1、根据当前请求，找到<strong>HandlerExecutionChain【</strong>可以处理请求的handler以及handler的所有拦截器】</p>
<p>2、在執行目標方法前，會先**<font color=red>順序執行</font>**所有拦截器的 <strong>preHandle</strong>方法</p>
<ul>
<li>1、如果当前拦截器prehandler返回为true。则执行下一个拦截器的<strong>preHandle</strong></li>
<li>2、如果当前拦截器返回为false。直接<font color=red><strong>倒序執行</strong></font>所有<font color=red><strong>已經執行</strong></font>了的拦截器的  <strong>afterCompletion</strong>；</li>
</ul>
<p>3、如果任何一个拦截器返回false。直接跳出不执行目标方法</p>
<p>4、所有拦截器都返回True。执行目标方法</p>
<p>5、<font color=red><strong>倒序執行</strong></font>所有拦截器的<strong>postHandle</strong>方法</p>
<p>6、前面的步骤有任何异常都会直接<font color=red><strong>倒序觸發</strong></font> <strong>afterCompletion</strong></p>
<p>7、页面成功渲染完成以后，也会<font color=red><strong>倒序觸發</strong></font> <strong>afterCompletion</strong></p>
<ul>
<li>根据当前请求，找到<strong>HandlerExecutionChain【</strong>可以处理请求的handler以及handler的所有拦截器】</li>
</ul>
<img src=" 20230321_123818.jpg" alt="img" style="zoom:67%;" />



<ul>
<li>攔截器流程控制圖解</li>
</ul>
<img src=" 20230321_123919.jpg" alt="img" style="zoom:67%;" />



<h2 id="7-文件上传"><a href="#7-文件上传" class="headerlink" title="7. 文件上传"></a>7. 文件上传</h2><h3 id="7-1-页面表单"><a href="#7-1-页面表单" class="headerlink" title="7.1 页面表单"></a>7.1 页面表单</h3><pre><code class="html">&lt;form method=&quot;post&quot; action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
</code></pre>
<h3 id="7-2-文件上传代码"><a href="#7-2-文件上传代码" class="headerlink" title="7.2 文件上传代码"></a>7.2 文件上传代码</h3><pre><code class="java">    /**
     * MultipartFile 自动封装上传过来的文件
     * @param email
     * @param username
     * @param headerImg
     * @param photos
     * @return
     */
    @PostMapping(&quot;/upload&quot;)
    public String upload(@RequestParam(&quot;email&quot;) String email,
                         @RequestParam(&quot;username&quot;) String username,
                         @RequestPart(&quot;headerImg&quot;) MultipartFile headerImg,
                         @RequestPart(&quot;photos&quot;) MultipartFile[] photos) throws IOException &#123;

        log.info(&quot;上传的信息：email=&#123;&#125;，username=&#123;&#125;，headerImg=&#123;&#125;，photos=&#123;&#125;&quot;,
                email,username,headerImg.getSize(),photos.length);

        if(!headerImg.isEmpty())&#123;
            //保存到文件服务器，OSS服务器
            String originalFilename = headerImg.getOriginalFilename();
            headerImg.transferTo(new File(&quot;H:\\cache\\&quot;+originalFilename));
        &#125;

        if(photos.length &gt; 0)&#123;
            for (MultipartFile photo : photos) &#123;
                if(!photo.isEmpty())&#123;
                    String originalFilename = photo.getOriginalFilename();
                    photo.transferTo(new File(&quot;H:\\cache\\&quot;+originalFilename));
                &#125;
            &#125;
        &#125;


        return &quot;main&quot;;
    &#125;
</code></pre>
<h3 id="7-3-自动配置原理【源碼解析】"><a href="#7-3-自动配置原理【源碼解析】" class="headerlink" title="7.3 自动配置原理【源碼解析】"></a>7.3 自动配置原理【源碼解析】</h3><p>**文件上传自动配置类-MultipartAutoConfiguration-**<strong>MultipartProperties</strong></p>
<ul>
<li><p>SpringBoot中自动配置好了 <strong>StandardServletMultipartResolver   【文件上传解析器】</strong></p>
</li>
<li><p>原理步骤</p>
</li>
<li><ul>
<li>1、请求进来使用文件上传解析器判断是否為Multipart（<strong>isMultipart</strong>），并調用<strong>resolveMultipart() ** 方法解析封装請求，返回</strong>MultipartHttpServletRequest**類的文件上传请求</li>
</ul>
</li>
<li><p>2、参数解析器来解析请求中的文件内容封装成MultipartFile</p>
</li>
<li><p>3、将request中 文件信息封装为一个Map；MultiValueMap&lt;String, MultipartFile&gt;</p>
</li>
<li><p>4、使用<strong>FileCopyUtils</strong> 实现文件流的拷贝</p>
</li>
</ul>
<ul>
<li>使用RequestPartMethodArgumentResolver解析器進行解析</li>
</ul>
 <img src=" 20230321_150158.jpg" alt="img" style="zoom: 80%;border: 4px solid orange;" />



<ul>
<li>在解析文件上傳請求時，已經將下面參數封裝到Map中；MultiValueMap&lt;String, MultipartFile&gt;</li>
</ul>
<pre><code class="java">    @PostMapping(&quot;/upload&quot;)
    public String upload(@RequestParam(&quot;email&quot;) String email,
                         @RequestParam(&quot;username&quot;) String username,
                         @RequestPart(&quot;headerImg&quot;) MultipartFile headerImg,
                         @RequestPart(&quot;photos&quot;) MultipartFile[] photos)
</code></pre>
<h2 id="8-异常处理"><a href="#8-异常处理" class="headerlink" title="8. 异常处理"></a>8. 异常处理</h2><h3 id="8-1-默认规则"><a href="#8-1-默认规则" class="headerlink" title="8.1 默认规则"></a>8.1 默认规则</h3><ul>
<li><p>默认情况下，Spring Boot提供<code>/error</code>处理所有错误的映射</p>
</li>
<li><p>对于机器客户端 (如：postman)，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息</p>
<pre><code>&lt;img src=&quot; 20230321_161130.jpg&quot; alt=&quot;img&quot; style=&quot;zoom: 80%;border: 4px solid orange;&quot; /&gt;
</code></pre>
</li>
<li><p>对于浏览器客户端，响应一个“ whitelabel”错误视图，以HTML格式呈现相同的数据</p>
<pre><code>&lt;img src=&quot; 20230321_161202.jpg&quot; alt=&quot;img&quot; style=&quot;zoom: 67%;border: 5px solid orange;&quot; /&gt;
</code></pre>
</li>
<li><p>要对其进行自定义，添加**<code>View</code><strong>解析为</strong><code>error</code>**</p>
</li>
<li><p>要完全替换默认行为，可以实现 <strong><code>ErrorController</code></strong> 并注册该类型的Bean定义，或添加**<code>ErrorAttributes</code>**类型的组件以使用现有机制但替换其内容。</p>
</li>
<li><p>error/下的4xx，5xx页面会被自动解析；</p>
<pre><code>&lt;img src=&quot; 20230321_161629.jpg&quot; alt=&quot;img&quot; style=&quot;zoom: 80%;border: 4px solid orange;&quot; /&gt;
</code></pre>
</li>
</ul>
<h3 id="8-2-定制错误处理逻辑"><a href="#8-2-定制错误处理逻辑" class="headerlink" title="8.2 定制错误处理逻辑"></a>8.2 定制错误处理逻辑</h3><ul>
<li><p>自定义错误页：</p>
<p>error/404.html   error/5xx.html；有精确的错误状态码页面就**<font color=red>精确匹配</font>**，没有就找 4xx.html；如果都没有就触发白页</p>
</li>
</ul>
<ul>
<li><p>@ControllerAdvice+@ExceptionHandler处理全局异常：</p>
<p>底层是 <strong>ExceptionHandlerExceptionResolver 這個異常解析器支持的</strong></p>
<pre><code class="java">@Slf4j
@ControllerAdvice
public class GlobalExceptionHandler &#123;

    @ExceptionHandler(&#123;ArithmeticException.class,NullPointerException.class&#125;)  //处理异常
    public String handleArithException(Exception e)&#123;

        log.error(&quot;异常是：&#123;&#125;&quot;,e);
        return &quot;login&quot;; //视图地址
    &#125;
&#125;
</code></pre>
</li>
</ul>
<ul>
<li><p>@ResponseStatus+自定义异常：</p>
<p>底层是 <strong>ResponseStatusExceptionResolver 這個異常解析器支持的</strong>，解析responsestatus注解的信息，取得信息後调用 **response.sendError(statusCode, resolvedReason)**來sendError，相當於tomcat发送的/error</p>
</li>
</ul>
<ul>
<li><p>Spring底层的异常 (如参数类型转换异常)：</p>
<p><strong>DefaultHandlerExceptionResolver 用來处理框架底层的异常</strong>。取得異常信息後調用response.sendError(HttpServletResponse.SC_BAD_REQUEST, ex.getMessage())來sendError，相當於tomcat发送的/error</p>
</li>
</ul>
<ul>
<li><p>自定义实现 HandlerExceptionResolver 处理异常；可以作为默认的全局异常处理规则</p>
<pre><code class="java">@Order(value= Ordered.HIGHEST_PRECEDENCE)  //优先级，数字越小优先级越高
@Component
public class CustomerHandlerExceptionResolver implements HandlerExceptionResolver &#123;
    @Override
    public ModelAndView resolveException(HttpServletRequest request,
                                         HttpServletResponse response,
                                         Object handler, Exception ex) &#123;

        try &#123;
            response.sendError(511,&quot;我喜欢的错误&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        return new ModelAndView();
    &#125;
&#125;
</code></pre>
</li>
</ul>
   <img src=" 20230322_002035.jpg" alt="img" style="zoom:67%;border: 5px solid orange;" />



<ul>
<li><p><strong>ErrorViewResolver</strong>  实现自定义处理异常：(一般不去自定義，理由如下)</p>
<ul>
<li><p>response.sendError 。error请求就会转给controller</p>
</li>
<li><p>你的异常没有任何異常解析器能处理。tomcat底层 response.sendError。error请求就会转给controller</p>
</li>
<li><p>由上述兩點得知，默認的error請求都會發送到controlloer ‘’<strong><font color=red>basicErrorController</font></strong>‘’，最終跳轉的页面地址是 <strong>ErrorViewResolver</strong>  進行解析的，</p>
<p>因此一般我們不自定義ErrorViewResolver</p>
</li>
</ul>
</li>
</ul>
<h3 id="8-3-异常处理自动配置原理"><a href="#8-3-异常处理自动配置原理" class="headerlink" title="8.3 异常处理自动配置原理"></a>8.3 异常处理自动配置原理</h3><ul>
<li><p><strong>ErrorMvcAutoConfiguration  自动配置异常处理规则</strong></p>
<ul>
<li>容器中的组件：类型：<strong>DefaultErrorAttributes</strong> -&gt; id：<strong>errorAttributes</strong><ul>
<li>方法：public class <strong><font color=red>DefaultErrorAttributes</font></strong> implements <strong>ErrorAttributes</strong>, <strong>HandlerExceptionResolver</strong></li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>DefaultErrorAttributes</strong>：定义错误页面中可以包含哪些数据。</p>
<ul>
<li>錯誤頁面可以包含exception、trace、message、errors、timestamp、status、errordetails、path</li>
</ul>
 <img src=" 20230321_205510.jpg" alt="img" style="zoom:67%;border: 5px solid orange;" />

 <img src=" 20230321_205553.jpg" alt="img" style="zoom:67%;border: 5px solid orange;" /></li>
</ul>
</li>
</ul>
<ul>
<li><p>容器中的组件：类型：<strong>BasicErrorController</strong> –&gt; id：<strong>basicErrorController</strong>（json+白页 适配响应）</p>
<ul>
<li>处理默认 <strong>/error</strong> 路径的请求；页面响应 **new ModelAndView(“error”, model)**；</li>
</ul>
<ul>
<li><p>容器中有组件 <strong>View</strong>-&gt;id是<strong>error</strong>；（响应默认错误页<code>whitelable error page</code>）</p>
</li>
<li><p>容器中放组件 <strong>BeanNameViewResolver（视图解析器）；按照返回的视图名作为组件的id去容器中找View对象。</strong></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>容器中的组件：类型：<strong>DefaultErrorViewResolver</strong> -&gt; id：<strong>conventionErrorViewResolver</strong></p>
<ul>
<li>如果发生错误，会以HTTP的状态码 作为视图页地址（viewName），找到真正的页面</li>
</ul>
<ul>
<li>真正的页面：地址為 error/ + viewName (404、5xx)</li>
</ul>
</li>
</ul>
<blockquote>
<p> 如果想要返回页面；就会找error视图【<strong>StaticView</strong>】。(默认是一个白页<code>whitelable error page</code>)</p>
</blockquote>
<ul>
<li>DefaultErrorAttributes類中，響應jason數據的方法<code>ResponseEntity()</code></li>
</ul>
 <img src=" 20230321_173805.jpg" alt="img" style="zoom:67%;border: 5px solid orange;" />



<ul>
<li>DefaultErrorAttributes類中，響應html頁面的方法<code>errorHtml()</code></li>
</ul>
<img src=" 20230321_173901.jpg" alt="img" style="zoom:67%;border: 5px solid orange;" /> 





<h3 id="8-4-异常处理步骤流程"><a href="#8-4-异常处理步骤流程" class="headerlink" title="8.4 异常处理步骤流程"></a>8.4 异常处理步骤流程</h3><p>1、执行目标方法，目标方法运行期间有任何异常都会被catch、並且标志当前请求结束；同時將異常用 <strong>dispatchException</strong>封裝</p>
<p>2、进入视图解析流程（页面渲染？）</p>
<p>processDispatchResult(processedRequest, response, mappedHandler, <strong>mv</strong>, <strong><font color=red>dispatchException</font></strong>);</p>
<p>3、<strong>mv</strong> = <strong>processHandlerException</strong>：处理handler发生的异常，处理完成返回ModelAndView；</p>
<ul>
<li><p>1、遍历所有的 <strong>handlerExceptionResolvers</strong>，看谁能处理当前异常<strong>【HandlerExceptionResolver处理器异常解析器】</strong></p>
<img src=" 20230321_231141.jpg" alt="img" style="zoom:67%;border: 5px solid orange;" /></li>
<li><p>2、系统默认的  异常解析器；</p>
<img src=" 20230321_231216.jpg" alt="img" style="zoom:67%;border: 5px solid orange;" />

<ul>
<li><p>1、DefaultErrorAttributes先来处理异常。把异常信息保存到request域，并且返回null；</p>
</li>
<li><p>2、默认没有任何人能处理此异常，所以异常会被抛出</p>
<ul>
<li>1、如果没有任何人能处理最终底层就会发送 <strong>/error</strong> 请求(Servlet規範)。会被底层的<strong>BasicErrorController</strong>处理</li>
<li>2、解析错误视图；遍历所有的  <strong>ErrorViewResolver</strong>  看谁能解析。</li>
</ul>
 <img src=" 20230321_231834.jpg" alt="img" style="zoom:67%;border: 5px solid orange;" /></li>
<li><p>3、默认的 DefaultErrorViewResolver ,作用是把响应状态码作为错误页的地址，error/500.html</p>
</li>
<li><p>4、模板引擎最终响应这个页面  error/500.html</p>
</li>
</ul>
</li>
</ul>
<h2 id="9-Web原生组件注入（Servlet、Filter、Listener）"><a href="#9-Web原生组件注入（Servlet、Filter、Listener）" class="headerlink" title="9. Web原生组件注入（Servlet、Filter、Listener）"></a>9. Web原生组件注入（Servlet、Filter、Listener）</h2><h3 id="9-1-使用Servlet-API-推薦使用"><a href="#9-1-使用Servlet-API-推薦使用" class="headerlink" title="9.1 使用Servlet API (推薦使用)"></a>9.1 使用Servlet API (推薦使用)</h3><p>【原生的註解方式】：</p>
<ul>
<li><p>主程式類中須配置</p>
<ul>
<li>@ServletComponentScan(basePackages = <strong>“com.atguigu.admin”</strong>) ：指定原生Servlet组件都放在那里</li>
</ul>
</li>
<li><p>自定義Servlet、Filter、Listener中配置</p>
<ul>
<li><p>@WebServlet(urlPatterns = <strong>“/my”</strong>)：效果：直接响应，**<font color=red>没有经过Spring的拦截器</font>**(原因詳見擴展部分)</p>
</li>
<li><p>@WebFilter(urlPatterns={<strong>“/css/*“</strong>,<strong>“/images/*“</strong>})</p>
<blockquote>
<p><code>/*</code> 是servlet家的寫法，<code>/**</code>是spring家的寫法，此處要使用<code>/*</code></p>
</blockquote>
</li>
<li><p>@WebListener</p>
</li>
</ul>
</li>
</ul>
<p>範例如下：</p>
<pre><code class="java">@WebServlet(urlPatterns = &quot;/my&quot;)
public class MyServlet extends HttpServlet &#123;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;
        resp.getWriter().write(&quot;66666&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">@Slf4j
@WebFilter(urlPatterns=&#123;&quot;/css/*&quot;,&quot;/images/*&quot;&#125;) //my
public class MyFilter implements Filter &#123;
    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;
        log.info(&quot;MyFilter初始化完成&quot;);
    &#125;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;
        log.info(&quot;MyFilter工作&quot;);
        chain.doFilter(request,response);
    &#125;

    @Override
    public void destroy() &#123;
        log.info(&quot;MyFilter销毁&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">@Slf4j
@WebListener
public class MyServletContextListener implements ServletContextListener &#123;


    @Override
    public void contextInitialized(ServletContextEvent sce) &#123;
        log.info(&quot;MySwervletContextListener监听到项目初始化完成&quot;);
    &#125;

    @Override
    public void contextDestroyed(ServletContextEvent sce) &#123;
        log.info(&quot;MySwervletContextListener监听到项目销毁&quot;);
    &#125;
&#125;
</code></pre>
<p>最后还要在主启动类添加注解<code>@ServletComponentScan</code></p>
<pre><code class="java">@ServletComponentScan(basePackages = &quot;com.lun&quot;)//
@SpringBootApplication(exclude = RedisAutoConfiguration.class)
public class Boot05WebAdminApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(Boot05WebAdminApplication.class, args);
    &#125;
&#125;
</code></pre>
<p>:bulb:<strong>扩展：DispatchServlet 如何注册进来</strong></p>
<ul>
<li>容器中自动配置了  DispatcherServlet  属性绑定到 WebMvcProperties；对应的配置文件配置项是前綴為 <strong>spring.mvc。</strong></li>
<li><strong>通过</strong> <strong>ServletRegistrationBean</strong><DispatcherServlet> 把 DispatcherServlet  配置进来。</li>
<li>默认映射的是 / 路径。</li>
</ul>
 <img src=" 20230322_161214.jpg" alt="img" style="zoom:67%;border: 5px solid orange;" />



<ul>
<li>Tomcat-Servlet(自定義的servlet)：<ul>
<li>若多个Servlet都能处理到同一层路径，以精确优选為原则</li>
</ul>
</li>
</ul>
<blockquote>
<p>因精確匹配原則，若請求路徑為/my，則匹配到我們自定義的servlet，自定義的servlet不包含DispatchServlet 內的filter…等方法，因此攔截器不作用</p>
</blockquote>
<h3 id="9-2-使用RegistrationBean"><a href="#9-2-使用RegistrationBean" class="headerlink" title="9.2 使用RegistrationBean"></a>9.2 使用RegistrationBean</h3><p>【Spring提供的方式】：</p>
<p>在config類中配置@bean將配置類裝到容器中：使用<code>ServletRegistrationBean</code>, <code>FilterRegistrationBean</code>, and <code>ServletListenerRegistrationBean</code>這三個類，將自定義的Servlet、Filter、Listener配置到容器中</p>
<pre><code class="java">ServletRegistrationBean`, `FilterRegistrationBean`, and `ServletListenerRegistrationBean
@Configuration(proxyBeanMethods = true)
public class MyRegistConfig &#123;

    @Bean
    public ServletRegistrationBean myServlet()&#123;
        MyServlet myServlet = new MyServlet();

        return new ServletRegistrationBean(myServlet,&quot;/my&quot;,&quot;/my02&quot;);
    &#125;


    @Bean
    public FilterRegistrationBean myFilter()&#123;

        MyFilter myFilter = new MyFilter();
//        return new FilterRegistrationBean(myFilter,myServlet());
        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(myFilter);
        filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/my&quot;,&quot;/css/*&quot;));
        return filterRegistrationBean;
    &#125;

    @Bean
    public ServletListenerRegistrationBean myListener()&#123;
        MySwervletContextListener mySwervletContextListener = new MySwervletContextListener();
        return new ServletListenerRegistrationBean(mySwervletContextListener);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>@Configuration(proxyBeanMethods = true) –&gt; 配置為單實例模式，避免產生壟餘的myServlet、myFilter、mySwervletContextListener對象</p>
</blockquote>
<h2 id="10-嵌入式Servlet容器"><a href="#10-嵌入式Servlet容器" class="headerlink" title="10. 嵌入式Servlet容器"></a>10. 嵌入式Servlet容器</h2><h3 id="10-1-切换嵌入式Servlet容器"><a href="#10-1-切换嵌入式Servlet容器" class="headerlink" title="10.1 切换嵌入式Servlet容器"></a>10.1 切换嵌入式Servlet容器</h3><ul>
<li>默认支持的webServer如下：<ul>
<li><code>Tomcat</code>, <code>Jetty</code>, or <code>Undertow</code></li>
</ul>
</li>
</ul>
 <img src=" 20230322_170237.jpg" alt="img" style="zoom:67%;border: 5px solid orange;" />



<ul>
<li>切换服务器方法如下：</li>
</ul>
<p>在SpringBoot的pom.xml中，將tomcat從spring-boot-starter-web導入依賴中排除，並另外新增要配置的服務器依賴</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;&lt;!--將tomcat從spring-boot-starter-web導入依賴中排除--&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;!--要配置的依賴--&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li><p>原理</p>
<ul>
<li><p>SpringBoot应用启动发现当前是Web应用。web场景包-导入tomcat</p>
</li>
<li><p>web应用会创建一个web版的ioc容器 <code>ServletWebServerApplicationContext</code></p>
</li>
<li><p><code>ServletWebServerApplicationContext</code> 启动的时候寻找 **<code>ServletWebServerFactory</code>**（Servlet 的web服务器工厂—&gt; 產生Servlet 的web服务器）</p>
<ul>
<li><p>SpringBoot底层默认有很多的WebServer工厂，如<code>TomcatServletWebServerFactory</code>, <code>JettyServletWebServerFactory</code>, or <code>UndertowServletWebServerFactory</code></p>
</li>
<li><p>底层直接会有一个自动配置类。ServletWebServerFactoryAutoConfiguration</p>
</li>
<li><p>ServletWebServerFactoryAutoConfiguration导入了ServletWebServerFactoryConfiguration（配置类）</p>
</li>
<li><p>ServletWebServerFactoryConfiguration 配置类 根据动态判断系统中到底导入了那个Web服务器的包。（默认是web-starter导入tomcat包，因此容器中就有 TomcatServletWebServerFactory）</p>
<blockquote>
<p>若找到多個Web服务器的包，會報錯</p>
</blockquote>
</li>
</ul>
</li>
<li><p>TomcatServletWebServerFactory 创建出Tomcat服务器并启动；TomcatWebServer 的构造器拥有初始化方法initialize —&gt; this.tomcat.start();</p>
</li>
<li><p>内嵌服务器，就是把手动启动服务器改為使用代码调用（前提是tomcat核心jar包存在）</p>
</li>
</ul>
</li>
</ul>
<h3 id="10-2-定制Servlet容器"><a href="#10-2-定制Servlet容器" class="headerlink" title="10.2 定制Servlet容器"></a>10.2 定制Servlet容器</h3><p>官方文檔提供下面三種方法：</p>
<ul>
<li><p>修改配置文件application.properties中，前綴為server.xxx的配置    <font color=blue>【推薦】</font></p>
</li>
<li><p>直接自定义 ConfigurableServletWebServerFactory</p>
</li>
<li><p>实现  WebServerFactoryCustomizer<ConfigurableServletWebServerFactory></p>
</li>
</ul>
<p>:bulb:Spring的某種設計模式：使用定制化器</p>
<p><strong>xxxxxCustomizer</strong>：定制化器，可以改变xxxx的默认规则**</p>
<pre><code class="java">import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
import org.springframework.stereotype.Component;

@Component
public class CustomizationBean implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; &#123;

    @Override
    public void customize(ConfigurableServletWebServerFactory server) &#123;
        server.setPort(9000);
    &#125;

&#125;
</code></pre>
<h2 id="11-定制化原理"><a href="#11-定制化原理" class="headerlink" title="11 定制化原理"></a>11 定制化原理</h2><h3 id="11-1-定制化的常见方式"><a href="#11-1-定制化的常见方式" class="headerlink" title="11.1 定制化的常见方式"></a>11.1 定制化的常见方式</h3><p>總結共有下面幾種定制化方式：</p>
<ol>
<li><p>修改配置文件</p>
</li>
<li><p><strong>xxxxxCustomizer</strong> 定制化器</p>
</li>
<li><p>编写自定义的配置类： 使用  <strong>xxxConfiguration</strong> + <strong>@Bean</strong>替换、增加容器中默认组件。ex：视图解析器</p>
</li>
<li><p>编写一个配置类实现 <strong>WebMvcConfigurer</strong>：即可定制化web功能，可使用@Bean给容器中再扩展一些组件 <strong><font color=red>【Web應用推薦】</font></strong></p>
</li>
</ol>
<pre><code class="java">@Configuration
public class AdminWebConfig implements WebMvcConfigurer
</code></pre>
<ol start="5">
<li><p><strong>@EnableWebMvc</strong> + WebMvcConfigurer —— @Bean  可以<strong>全面接管</strong>SpringMVC，所有规则全部自己重新配置； 实现定制和扩展功能</p>
<ul>
<li><p>原理</p>
</li>
<li><p>1、WebMvcAutoConfiguration  默认的SpringMVC的自动配置功能类。静态资源、欢迎页…..</p>
</li>
<li><p>2、一旦使用 @EnableWebMvc ，会 @Import(DelegatingWebMvcConfiguration.class)</p>
</li>
<li><p>3、<strong>DelegatingWebMvcConfiguration</strong> 的作用，只保证SpringMVC最基本的使用</p>
<ul>
<li><p>把所有系统中的 WebMvcConfigurer 拿过来。所有功能的定制都是这些 WebMvcConfigurer  合起来一起生效</p>
</li>
<li><p>只自动配置了一些非常底层的组件。如<strong>RequestMappingHandlerMapping</strong>…..等等，这些组件依赖的组件都是从容器中获取</p>
<blockquote>
<p>public class <strong>DelegatingWebMvcConfiguration</strong> extends <strong>WebMvcConfigurationSupport</strong></p>
<p>DelegatingWebMvcConfiguration繼承了WebMvcConfigurationSupport</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ul>
<li>4、<strong>WebMvcAutoConfiguration</strong> 里面的配置要能生效 必须  @ConditionalOnMissingBean(<strong>WebMvcConfigurationSupport</strong>.<strong>class</strong>)</li>
</ul>
<ul>
<li><p>5、@EnableWebMvc  导致了 <strong>WebMvcAutoConfiguration  没有生效。</strong></p>
<blockquote>
<p>因 @EnableWebMvc 導入了DelegatingWebMvcConfiguration，而DelegatingWebMvcConfiguration又繼承了WebMvcAutoConfiguration ，因此容器中包含了WebMvcAutoConfiguration 這個bean，造成WebMvcAutoConfiguration裡面的配置失效，必須全部自己重新配置</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="11-2-原理分析套路"><a href="#11-2-原理分析套路" class="headerlink" title="11.2 原理分析套路"></a>11.2 原理分析套路</h3><p><strong><font color=red>场景starter</font></strong> <strong>–&gt; xxxxAutoConfiguration –&gt;@Bean导入xxx组件 –&gt;绑定xxxProperties –&gt;</strong> <strong>绑定配置文件项</strong></p>
<blockquote>
<p>我們常規使用時只需選擇導入場景，並修改配置文件項即可</p>
</blockquote>
<h1 id="06、数据访问"><a href="#06、数据访问" class="headerlink" title="06、数据访问"></a>06、数据访问</h1><h2 id="1-SQL"><a href="#1-SQL" class="headerlink" title="1. SQL"></a>1. SQL</h2><h3 id="1-1-数据源的自动配置-HikariDataSource"><a href="#1-1-数据源的自动配置-HikariDataSource" class="headerlink" title="1.1 数据源的自动配置-HikariDataSource"></a>1.1 数据源的自动配置-HikariDataSource</h3><h5 id="1-1-1-导入JDBC场景"><a href="#1-1-1-导入JDBC场景" class="headerlink" title="1.1.1 导入JDBC场景"></a>1.1.1 导入JDBC场景</h5><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>JDBC場景導入了下面依賴</li>
</ul>
 <img src=" 20230322_232116.jpg" alt="image.png" style="zoom:67%;border: 5px solid orange;" /> 



<p>:bulb:数据库驱动呢？</p>
<p>为什么导入JDBC场景，官方不导入驱动？因為官方不知道我们接下要操作什么数据库。下面以使用MySql數據庫為例</p>
<ul>
<li>数据库版本必須和驱动版本对应，修改版本有下面兩種方法<ul>
<li>直接依赖引入具体版本（maven的就近依赖原则）</li>
<li>使用<properties>重新声明版本（maven的属性的就近优先原则）</li>
</ul>
</li>
</ul>
<pre><code class="xml">&lt;!--默认版本：--&gt;
&lt;mysql.version&gt;8.0.22&lt;/mysql.version&gt;

&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;!--&lt;version&gt;5.1.49&lt;/version&gt;--&gt;   &lt;!--直接依赖引入具体版本--&gt;
&lt;/dependency&gt;

&lt;!--
想要修改版本
1、直接依赖引入具体版本（maven的就近依赖原则）
2、重新声明版本（maven的属性的就近优先原则）
--&gt;
&lt;properties&gt;&lt;!--使用&lt;properties&gt;重新声明版本--&gt;
    &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;mysql.version&gt;5.1.49&lt;/mysql.version&gt;
&lt;/properties&gt;
</code></pre>
<h5 id="1-1-2-分析自动配置"><a href="#1-1-2-分析自动配置" class="headerlink" title="1.1.2 分析自动配置"></a>1.1.2 分析自动配置</h5><ul>
<li><p>JDBC中自动配置的类有下面幾種</p>
<ul>
<li><p><strong>DataSourceAutoConfiguration</strong> ： 数据源的自动配置</p>
</li>
<li><p>修改数据源相关的配置：綁定前綴為 <code>spring.datasource</code></p>
</li>
<li><p>数据库连接池的配置：若容器中没有DataSource才自动配置的</p>
</li>
<li><p>底层默認配置的连接池是：HikariDataSource</p>
</li>
</ul>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
@Conditional(PooledDataSourceCondition.class)
@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)
@Import(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,
         DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class,
         DataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class &#125;)
protected static class PooledDataSourceConfiguration
</code></pre>
</li>
</ul>
<ul>
<li><strong>DataSourceTransactionManagerAutoConfiguration</strong>： 事务管理器的自动配置</li>
<li><strong>JdbcTemplateAutoConfiguration</strong>： JdbcTemplate的自动配置，可以来对数据库进行crud<ul>
<li>可以修改这个配置项@ConfigurationProperties(prefix = “spring.jdbc”) 来修改JdbcTemplate</li>
<li>@Bean@Primary    JdbcTemplate；容器中有这个组件，使用@Autowire自動注入即可使用</li>
</ul>
</li>
<li><strong>JndiDataSourceAutoConfiguration</strong>： jndi的自动配置</li>
<li><strong>XADataSourceAutoConfiguration</strong>： 分布式事务相关的</li>
</ul>
<h5 id="1-1-3-修改配置项"><a href="#1-1-3-修改配置项" class="headerlink" title="1.1.3 修改配置项"></a>1.1.3 修改配置项</h5><p>在配置項中，設置數據庫相關配置</p>
<pre><code class="yaml">spring:
  datasource:
    url: jdbc:mysql://localhost:3306/db_account
    username: root
    password: 123456
    driver-class-name: com.mysql.jdbc.Driver
</code></pre>
<h5 id="1-1-4-單元测试"><a href="#1-1-4-單元测试" class="headerlink" title="1.1.4 單元测试"></a>1.1.4 單元测试</h5><p>測試是否可操作數據庫</p>
<pre><code class="java">@Slf4j
@SpringBootTest
class Boot05WebAdminApplicationTests &#123;

    @Autowired
    JdbcTemplate jdbcTemplate;


    @Test
    void contextLoads() &#123;

//        jdbcTemplate.queryForObject(&quot;select * from account_tbl&quot;)
//        jdbcTemplate.queryForList(&quot;select * from account_tbl&quot;,)
        Long aLong = jdbcTemplate.queryForObject(&quot;select count(*) from account_tbl&quot;, Long.class);
        log.info(&quot;记录总数：&#123;&#125;&quot;,aLong);
    &#125;

&#125;
</code></pre>
<h3 id="1-2-使用Druid数据源"><a href="#1-2-使用Druid数据源" class="headerlink" title="1.2 使用Druid数据源"></a>1.2 使用Druid数据源</h3><h5 id="1-2-1-druid官方github地址"><a href="#1-2-1-druid官方github地址" class="headerlink" title="1.2.1 druid官方github地址"></a>1.2.1 druid官方github地址</h5><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/druid">https://github.com/alibaba/druid</a></p>
<p>整合第三方技术的两种方式</p>
<ul>
<li><p>自定义</p>
</li>
<li><p>找starter</p>
</li>
</ul>
<h5 id="1-2-2-自定义方式"><a href="#1-2-2-自定义方式" class="headerlink" title="1.2.2 自定义方式"></a>1.2.2 自定义方式</h5><h6 id="1、创建数据源"><a href="#1、创建数据源" class="headerlink" title="1、创建数据源"></a>1、创建数据源</h6><ul>
<li>添加依賴</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>配置數據源</li>
</ul>
<pre><code class="java">@Configuration
public class MyConfig &#123;

    @Bean
    @ConfigurationProperties(&quot;spring.datasource&quot;)//复用配置文件的数据源配置
    public DataSource dataSource() throws SQLException &#123;
        DruidDataSource druidDataSource = new DruidDataSource();

//        druidDataSource.setUrl();
//        druidDataSource.setUsername();
//        druidDataSource.setPassword();

        return druidDataSource;
    &#125;
&#125;
</code></pre>
<h6 id="2、配置Druid的监控页功能："><a href="#2、配置Druid的监控页功能：" class="headerlink" title="2、配置Druid的监控页功能："></a>2、<strong>配置Druid的监控页功能</strong>：</h6><ul>
<li><p>StatViewServlet ：Druid内置提供了一个<code>StatViewServlet</code>用于展示Druid的统计信息。<a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatViewServlet%E9%85%8D%E7%BD%AE">官方文档 - 配置_StatViewServlet配置</a>。这个<code>StatViewServlet</code>的用途包括：</p>
<ul>
<li><p>提供监控信息展示的html页面</p>
</li>
<li><p>提供监控信息的JSON API</p>
</li>
</ul>
</li>
<li><p>StatFilter：Druid内置提供一个<code>StatFilter</code>，用于统计监控信息，如SQL监控、URI监控。<a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatFilter">官方文档 - 配置_StatFilter</a></p>
</li>
</ul>
<ul>
<li>WebStatFilter：用于采集web-jdbc关联监控的数据，如SQL监控、URI监控。<a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_%E9%85%8D%E7%BD%AEWebStatFilter">官方文档 - 配置_配置WebStatFilter</a></li>
<li>WallFilter：它是基于SQL语义分析来实现防御SQL注入攻击的。<a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE-wallfilter">官方文档 - 配置 wallfilter</a></li>
</ul>
<p>系统中所有filter：</p>
<table>
<thead>
<tr>
<th>别名</th>
<th>Filter类名</th>
</tr>
</thead>
<tbody><tr>
<td>default</td>
<td>com.alibaba.druid.filter.stat.StatFilter</td>
</tr>
<tr>
<td>stat</td>
<td>com.alibaba.druid.filter.stat.StatFilter</td>
</tr>
<tr>
<td>mergeStat</td>
<td>com.alibaba.druid.filter.stat.MergeStatFilter</td>
</tr>
<tr>
<td>encoding</td>
<td>com.alibaba.druid.filter.encoding.EncodingConvertFilter</td>
</tr>
<tr>
<td>log4j</td>
<td>com.alibaba.druid.filter.logging.Log4jFilter</td>
</tr>
<tr>
<td>log4j2</td>
<td>com.alibaba.druid.filter.logging.Log4j2Filter</td>
</tr>
<tr>
<td>slf4j</td>
<td>com.alibaba.druid.filter.logging.Slf4jLogFilter</td>
</tr>
<tr>
<td>commonlogging</td>
<td>com.alibaba.druid.filter.logging.CommonsLogFilter</td>
</tr>
</tbody></table>
<p>以下為配置範例：</p>
<pre><code class="java">@Configuration
public class MyConfig &#123;

    @Bean
    @ConfigurationProperties(&quot;spring.datasource&quot;)
    public DataSource dataSource() throws SQLException &#123;
        DruidDataSource druidDataSource = new DruidDataSource();

        //加入监控和防火墙功能功能
        druidDataSource.setFilters(&quot;stat,wall&quot;);
        
        return druidDataSource;
    &#125;
    
    /**
     * 配置 druid的监控页功能
     * @return
     */
    @Bean
    public ServletRegistrationBean statViewServlet()&#123;
        StatViewServlet statViewServlet = new StatViewServlet();
        ServletRegistrationBean&lt;StatViewServlet&gt; registrationBean = 
            new ServletRegistrationBean&lt;&gt;(statViewServlet, &quot;/druid/*&quot;);

        //监控页账号密码：
        registrationBean.addInitParameter(&quot;loginUsername&quot;,&quot;admin&quot;);
        registrationBean.addInitParameter(&quot;loginPassword&quot;,&quot;123456&quot;);

        return registrationBean;
    &#125;
    
     /**
     * WebStatFilter 用于采集web-jdbc关联监控的数据。
     */
    @Bean
    public FilterRegistrationBean webStatFilter()&#123;
        WebStatFilter webStatFilter = new WebStatFilter();

        FilterRegistrationBean&lt;WebStatFilter&gt; filterRegistrationBean = new FilterRegistrationBean&lt;&gt;(webStatFilter);
        filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));
        filterRegistrationBean.addInitParameter(&quot;exclusions&quot;,&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;);

        return filterRegistrationBean;
    &#125;
    
&#125;
</code></pre>
<h5 id="1-2-3-使用官方starter方式"><a href="#1-2-3-使用官方starter方式" class="headerlink" title="1.2.3 使用官方starter方式"></a>1.2.3 使用官方starter方式</h5><h6 id="1、引入druid-starter"><a href="#1、引入druid-starter" class="headerlink" title="1、引入druid-starter"></a>1、引入druid-starter</h6><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.1.17&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h6 id="2、分析自动配置"><a href="#2、分析自动配置" class="headerlink" title="2、分析自动配置"></a>2、分析自动配置</h6><p>除了前綴為 <code>spring.datasource</code>的配置項，還有一些前綴為 <code>spring.datasource.druid</code>的擴展配置項如下：</p>
<ul>
<li><code>DruidSpringAopConfiguration.class</code>,  监控SpringBean的。配置项：<code>spring.datasource.druid.aop-patterns</code></li>
<li><code>DruidStatViewServletConfiguration.class</code>, 监控页的配置。配置项：<code>spring.datasource.druid.stat-view-servlet</code>默认开启。</li>
<li><code>DruidWebStatFilterConfiguration.class</code>，web监控配置。配置项：<code>spring.datasource.druid.web-stat-filter</code>默认开启。</li>
<li><code>DruidFilterConfiguration.class</code>所有Druid的filter的配置。配置項如下：</li>
</ul>
<pre><code class="java">private static final String FILTER_STAT_PREFIX = &quot;spring.datasource.druid.filter.stat&quot;;
private static final String FILTER_CONFIG_PREFIX = &quot;spring.datasource.druid.filter.config&quot;;
private static final String FILTER_ENCODING_PREFIX = &quot;spring.datasource.druid.filter.encoding&quot;;
private static final String FILTER_SLF4J_PREFIX = &quot;spring.datasource.druid.filter.slf4j&quot;;
private static final String FILTER_LOG4J_PREFIX = &quot;spring.datasource.druid.filter.log4j&quot;;
private static final String FILTER_LOG4J2_PREFIX = &quot;spring.datasource.druid.filter.log4j2&quot;;
private static final String FILTER_COMMONS_LOG_PREFIX = &quot;spring.datasource.druid.filter.commons-log&quot;;
private static final String FILTER_WALL_PREFIX = &quot;spring.datasource.druid.filter.wall&quot;;
</code></pre>
<h6 id="3、配置示例"><a href="#3、配置示例" class="headerlink" title="3、配置示例"></a>3、配置示例</h6><pre><code class="yaml">spring:
  datasource:
    url: jdbc:mysql://localhost:3306/db_account
    username: root
    password: 123456
    driver-class-name: com.mysql.jdbc.Driver

    druid:
      aop-patterns: com.atguigu.admin.*  #监控SpringBean
      filters: stat,wall     # 底层开启功能，stat（sql监控），wall（防火墙）

      stat-view-servlet:   # 配置监控页功能
        enabled: true
        login-username: admin
        login-password: admin
        resetEnable: false

      web-stat-filter:  # 监控web
        enabled: true
        urlPattern: /*
        exclusions: &#39;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#39;


      filter:
        stat:    # 对上面filters里面的stat的详细配置
          slow-sql-millis: 1000
          logSlowSql: true
          enabled: true
        wall:
          enabled: true
          config:
            drop-table-allow: false
</code></pre>
<p>SpringBoot配置示例</p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter">https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</a></p>
<p>配置项列表</p>
<p><a target="_blank" rel="noopener" href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8">https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8</a></p>
<h3 id="1-3-整合MyBatis操作"><a href="#1-3-整合MyBatis操作" class="headerlink" title="1.3 整合MyBatis操作"></a>1.3 整合MyBatis操作</h3><p><a target="_blank" rel="noopener" href="https://github.com/mybatis">MyBatis的GitHub仓库</a></p>
<p><a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/index.html">MyBatis官方</a></p>
<p>思路：尋找starter –&gt; Springboot裡面找不到Mybatis (因Mybatis屬於第三方) –&gt; 到Mybatis的Github尋找</p>
<blockquote>
<p>其他方式：在Spring initializr可選配mybatis</p>
</blockquote>
<p><strong>starter的命名方式</strong>：</p>
<ol>
<li>SpringBoot官方的Starter：<code>spring-boot-starter-*</code></li>
<li>第三方的： <code>*-spring-boot-starter</code></li>
</ol>
<ul>
<li>引入依賴</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.4&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
 <img src=" 20230323_094327.jpg" alt="image.png" style="zoom:80%;border: 5px solid orange;" />



<h5 id="1-3-1-配置模式"><a href="#1-3-1-配置模式" class="headerlink" title="1.3.1 配置模式"></a>1.3.1 配置模式</h5><p>思路：按照以前使用Mybatis時的配置方法，逐一確認</p>
<p>●<strong>全局配置文件</strong>：可不寫，已自動配置。要修改可到配置文件 application.yaml 中修改 <font color=red>【推薦不寫】</font></p>
<blockquote>
<p>若要將配置寫到application.yaml ，則全局配置文件中不可填寫配置，兩者只能擇一</p>
</blockquote>
<p>●<strong>SqlSessionFactory</strong>: 自动配置好了</p>
<p>●<strong>SqlSession</strong>：自动配置了 SqlSessionTemplate，SqlSessionTemplate屬性裡面包含SqlSession</p>
<p>●**@Import(AutoConfiguredMapperScannerRegistrar.class）**：自動導入了掃描Mapper</p>
<p>●<strong>Mapper</strong>： 只要我们写的操作MyBatis的接口標註了 @Mapper 就会被自动扫描进来</p>
<p>Mybatis綁定配置源碼如下：綁定的前綴為mybatis</p>
<pre><code class="java">@EnableConfigurationProperties(MybatisProperties.class) ： MyBatis配置项绑定类。
@AutoConfigureAfter(&#123; DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class &#125;)
public class MybatisAutoConfiguration&#123;
    ...
&#125;

@ConfigurationProperties(prefix = &quot;mybatis&quot;)
public class MybatisProperties&#123;
    ...
&#125;
</code></pre>
<p>————————————————–以下為配置範例———————————————————-</p>
<ul>
<li>配置文件 application.yaml</li>
</ul>
<pre><code class="yaml">spring:
  datasource:
    username: root
    password: 1234
    url: jdbc:mysql://localhost:3306/my
    driver-class-name: com.mysql.jdbc.Driver

# 配置mybatis规则
mybatis:
  config-location: classpath:mybatis/mybatis-config.xml  #全局配置文件位置
  mapper-locations: classpath:mybatis/*.xml  #sql映射文件位置
</code></pre>
<ul>
<li>全局配置文件mybatis-config.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    
    &lt;!-- 由于Spring Boot自动配置缘故，此处不必配置，只用来做做样。--&gt;
&lt;/configuration&gt;
</code></pre>
<ul>
<li>Mapper接口</li>
</ul>
<pre><code class="java">import com.lun.boot.bean.User;
import org.apache.ibatis.annotations.Mapper;

@Mapper //需標註@Mapper註解
public interface UserMapper &#123;
    public User getUser(Integer id);
&#125;
</code></pre>
<ul>
<li>Mapper接口的xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.lun.boot.mapper.UserMapper&quot;&gt;

    &lt;select id=&quot;getUser&quot; resultType=&quot;com.lun.boot.bean.User&quot;&gt;
        select * from user where id=#&#123;id&#125;
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<ul>
<li>POJO</li>
</ul>
<pre><code class="java">public class User &#123;
    private Integer id;
    private String name;
    
    //getters and setters...
&#125;
</code></pre>
<ul>
<li>Controller</li>
</ul>
<pre><code class="java">@Controller
public class UserController &#123;

    @Autowired
    private UserService userService;

    @ResponseBody
    @GetMapping(&quot;/user/&#123;id&#125;&quot;)
    public User getUser(@PathVariable(&quot;id&quot;) Integer id)&#123;

        return userService.getUser(id);
    &#125;

&#125;
</code></pre>
<ul>
<li>Service</li>
</ul>
<pre><code class="java">@Service
public class UserService &#123;

    @Autowired
    private UserMapper userMapper;//IDEA下标红线，可忽视这红线

    public User getUser(Integer id)&#123;
        return userMapper.getUser(id);
    &#125;

&#125;
</code></pre>
<p>:bulb:Mybatis已提供配置類 <code>private Configuration configuration</code>將大部分的配置封裝到類中，可經由修改配置文件 application.yaml，相当于改mybatis全局配置文件中的值</p>
<blockquote>
<p>:heavy_exclamation_mark:configuration寫在 <code>全局配置文件</code> 或 <code>application.yaml</code> ，兩者只能擇一，否則報錯</p>
</blockquote>
<pre><code class="yaml"># 配置mybatis规则
mybatis:
  mapper-locations: classpath:mybatis/mapper/*.xml
  # 可以不写全局配置文件，所有全局配置文件的配置都放在configuration配置项中了。
  # config-location: classpath:mybatis/mybatis-config.xml
  configuration:
    map-underscore-to-camel-case: true  #開啟駝峰式映射
</code></pre>
<p>:large_orange_diamond:<strong>小結：</strong></p>
<p>●导入mybatis官方starter</p>
<p>●编写mapper接口：需標註@Mapper注解</p>
<p>●编写sql映射文件并绑定mapper接口</p>
<p>●在application.yaml中指定Mapper配置文件的位置，以及指定全局配置文件的信息 （<strong>建议配置在application.yaml 中 mybatis.configuration</strong>）</p>
<h5 id="1-3-2-注解模式"><a href="#1-3-2-注解模式" class="headerlink" title="1.3.2 注解模式"></a>1.3.2 注解模式</h5><pre><code class="java">@Mapper
public interface UserMapper &#123;
    public User getUser(Integer id);

    @Select(&quot;select * from user where id=#&#123;id&#125;&quot;)
    public User getUser2(Integer id);

    public void saveUser(User user);

    @Insert(&quot;insert into user(`name`) values(#&#123;name&#125;)&quot;)
    @Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;) //新增user後，可將主鍵&quot;id&quot;存回user對象中
    public void saveUser2(User user);

&#125;
</code></pre>
<h5 id="1-3-3-混合模式"><a href="#1-3-3-混合模式" class="headerlink" title="1.3.3 混合模式"></a>1.3.3 混合模式</h5><ul>
<li>Mapper接口</li>
</ul>
<pre><code class="java">@Mapper
public interface CityMapper &#123;

    @Select(&quot;select * from city where id=#&#123;id&#125;&quot;)
    public City getById(Long id);  //簡單方法用註解方式

    public void insert(City city); //複雜方法編寫mapper.xml進行綁定映射

&#125;
</code></pre>
<ul>
<li>CityMapper.xml</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.atguigu.boot.mapper.UserMapper&quot;&gt;


    &lt;insert id=&quot;saveUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; &lt;!--新增user後，可將主鍵&quot;id&quot;存回user對象中--&gt;
        insert into user(`name`) values(#&#123;name&#125;)
    &lt;/insert&gt;

&lt;/mapper&gt;
</code></pre>
<p>:large_orange_diamond:最佳实战：</p>
<ol>
<li><p>引入mybatis-starter</p>
</li>
<li><p>配置application.yaml中，指定mapper-location位置即可 (混合版需有xxxmaper.xml)</p>
</li>
<li><p>编写Mapper接口并标注@Mapper注解</p>
</li>
<li><p>简单方法直接注解方式</p>
</li>
<li><p>复杂方法编写mapper.xml进行绑定映射</p>
</li>
</ol>
<blockquote>
<p> 可在主程序中添加註解@MapperScan(“com.atguigu.admin.mapper”) 简化，mapper接口就可以不用标注@Mapper注解</p>
</blockquote>
<h3 id="1-4-整合-MyBatis-Plus-完成CRUD"><a href="#1-4-整合-MyBatis-Plus-完成CRUD" class="headerlink" title="1.4 整合 MyBatis-Plus 完成CRUD"></a>1.4 整合 MyBatis-Plus 完成CRUD</h3><h5 id="1-4-1-什么是MyBatis-Plus"><a href="#1-4-1-什么是MyBatis-Plus" class="headerlink" title="1.4.1 什么是MyBatis-Plus"></a>1.4.1 什么是MyBatis-Plus</h5><p><a target="_blank" rel="noopener" href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>（简称 MP）是一个 <a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/">MyBatis</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<p><a target="_blank" rel="noopener" href="https://baomidou.com/">mybatis plus 官网</a></p>
<p>建议安装 MybatisX 插件 ：一款全免费且强大的 IDEA 插件，支持跳转，自动补全生成 SQL，代码生成。</p>
<h5 id="1-4-2-整合MyBatis-Plus"><a href="#1-4-2-整合MyBatis-Plus" class="headerlink" title="1.4.2 整合MyBatis-Plus"></a>1.4.2 整合MyBatis-Plus</h5><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.4.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<blockquote>
<p>MyBatis-Plus 依賴包含了mybatis、mybatis整合spring、spring的JDBC，這三個依賴不用另外再添加</p>
</blockquote>
<p>自动配置</p>
<ul>
<li><strong>MybatisPlusAutoConfiguration</strong> 配置类：MybatisPlusProperties 配置项绑定，前綴為 mybatis-plus</li>
<li><strong>SqlSessionFactory</strong>：自动配置好。底层是容器中默认的数据源</li>
<li><strong>mapperLocations</strong>：自动配置好的。有默认值。classpath*:/mapper/**/*.xml；任意包的类路径下的所有mapper文件夹下任意路径下的所有xml都是sql映射文件。  建议以后sql映射文件，放在 mapper下</li>
<li><strong>SqlSessionTemplate</strong>：容器中也自动配置好了</li>
<li><strong>Mapper</strong>：@Mapper 标注的接口也会被自动扫描；建议直接 @MapperScan(“com.atguigu.admin.mapper”) 批量扫描就行</li>
</ul>
<p>优点：</p>
<ul>
<li>只需要我们的Mapper继承 BaseMapper 就可以拥有crud能力</li>
</ul>
<h5 id="1-4-3-CRUD功能"><a href="#1-4-3-CRUD功能" class="headerlink" title="1.4.3 CRUD功能"></a>1.4.3 CRUD功能</h5><p><a target="_blank" rel="noopener" href="https://baomidou.com/guide/crud-interface.html">官方文档 - CRUD接口</a></p>
<p>使用MyBatis Plus提供的<code>IService</code>，<code>ServiceImpl</code>，减轻Service层开发工作。</p>
<ul>
<li><p>Service</p>
<p>繼承 IService<T></p>
</li>
</ul>
<pre><code class="java">import com.lun.hellomybatisplus.model.User;
import com.baomidou.mybatisplus.extension.service.IService;

import java.util.List;

/**
 *  Service 的CRUD也不用写了
 */
public interface UserService extends IService&lt;User&gt; &#123;
    //此处故意为空
&#125;
</code></pre>
<ul>
<li>ServiceImpl</li>
<li>繼承 ServiceImpl<T></li>
</ul>
<pre><code class="java">import com.lun.hellomybatisplus.model.User;
import com.lun.hellomybatisplus.mapper.UserMapper;
import com.lun.hellomybatisplus.service.UserService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService &#123;
    //此处故意为空
&#125;
</code></pre>
<h5 id="1-4-4-添加分页插件："><a href="#1-4-4-添加分页插件：" class="headerlink" title="1.4.4 添加分页插件："></a>1.4.4 添加分页插件：</h5><p>MybatisPlus提供的分頁插件<code>MybatisPlusInterceptor</code>配置方法如下</p>
<ul>
<li>Configuration</li>
</ul>
<pre><code class="java">@Configuration
public class MyBatisConfig &#123;


    /**
     * MybatisPlusInterceptor
     * @return
     */
    @Bean
    public MybatisPlusInterceptor paginationInterceptor() &#123;
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
        // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false
        // paginationInterceptor.setOverflow(false);
        // 设置最大单页限制数量，默认 500 条，-1 不受限制
        // paginationInterceptor.setLimit(500);
        // 开启 count 的 join 优化,只针对部分 left join

        //这是分页拦截器
        PaginationInnerInterceptor paginationInnerInterceptor = new PaginationInnerInterceptor();
        paginationInnerInterceptor.setOverflow(true);
        paginationInnerInterceptor.setMaxLimit(500L);
        mybatisPlusInterceptor.addInnerInterceptor(paginationInnerInterceptor);

        return mybatisPlusInterceptor;
    &#125;
&#125;
</code></pre>
<ul>
<li>Html頁面</li>
</ul>
<pre><code class="html">&lt;table class=&quot;display table table-bordered table-striped&quot; id=&quot;dynamic-table&quot;&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;#&lt;/th&gt;
            &lt;th&gt;name&lt;/th&gt;
            &lt;th&gt;age&lt;/th&gt;
            &lt;th&gt;email&lt;/th&gt;
            &lt;th&gt;操作&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
        &lt;tr class=&quot;gradeX&quot; th:each=&quot;user: $&#123;users.records&#125;&quot;&gt;
            &lt;td th:text=&quot;$&#123;user.id&#125;&quot;&gt;&lt;/td&gt;
            &lt;td&gt;[[$&#123;user.name&#125;]]&lt;/td&gt;
            &lt;td th:text=&quot;$&#123;user.age&#125;&quot;&gt;Win 95+&lt;/td&gt;
            &lt;td th:text=&quot;$&#123;user.email&#125;&quot;&gt;4&lt;/td&gt;
            &lt;td&gt;
                &lt;a th:href=&quot;@&#123;/user/delete/&#123;id&#125;(id=$&#123;user.id&#125;,pn=$&#123;users.current&#125;)&#125;&quot; 
                   class=&quot;btn btn-danger btn-sm&quot; type=&quot;button&quot;&gt;删除&lt;/a&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tfoot&gt;
&lt;/table&gt;

&lt;div class=&quot;row-fluid&quot;&gt;
    &lt;div class=&quot;span6&quot;&gt;
        &lt;div class=&quot;dataTables_info&quot; id=&quot;dynamic-table_info&quot;&gt;
            当前第[[$&#123;users.current&#125;]]页  总计 [[$&#123;users.pages&#125;]]页  共[[$&#123;users.total&#125;]]条记录
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;span6&quot;&gt;
        &lt;div class=&quot;dataTables_paginate paging_bootstrap pagination&quot;&gt;
            &lt;ul&gt;
                &lt;li class=&quot;prev disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;← 前一页&lt;/a&gt;&lt;/li&gt;
                &lt;li th:class=&quot;$&#123;num == users.current?&#39;active&#39;:&#39;&#39;&#125;&quot; 
                    th:each=&quot;num:$&#123;#numbers.sequence(1,users.pages)&#125;&quot; &gt;
                    &lt;a th:href=&quot;@&#123;/dynamic_table(pn=$&#123;num&#125;)&#125;&quot;&gt;[[$&#123;num&#125;]]&lt;/a&gt;
                &lt;/li&gt;
                &lt;li class=&quot;next disabled&quot;&gt;&lt;a href=&quot;#&quot;&gt;下一页 → &lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<blockquote>
<p> <code>#numbers</code>表示methods for formatting numeric objects.<a target="_blank" rel="noopener" href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#expression-utility-objects">link</a></p>
</blockquote>
<ul>
<li>Controller</li>
</ul>
<pre><code class="java">@GetMapping(&quot;/user/delete/&#123;id&#125;&quot;)
public String deleteUser(@PathVariable(&quot;id&quot;) Long id,
                         @RequestParam(value = &quot;pn&quot;,defaultValue = &quot;1&quot;)Integer pn,
                         RedirectAttributes ra)&#123;

    userService.removeById(id);

    ra.addAttribute(&quot;pn&quot;,pn);
    return &quot;redirect:/dynamic_table&quot;;
&#125;

@GetMapping(&quot;/dynamic_table&quot;)
public String dynamic_table(@RequestParam(value=&quot;pn&quot;,defaultValue = &quot;1&quot;) Integer pn,Model model)&#123;
    //表格内容的遍历

    //从数据库中查出user表中的用户进行展示

    //构造分页参数
    Page&lt;User&gt; page = new Page&lt;&gt;(pn, 2);
    //调用page进行分页
    Page&lt;User&gt; userPage = userService.page(page, null);

    model.addAttribute(&quot;users&quot;,userPage);

    return &quot;table/dynamic_table&quot;;
&#125;
</code></pre>
<h2 id="2、NoSQL"><a href="#2、NoSQL" class="headerlink" title="2、NoSQL"></a>2、NoSQL</h2><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a target="_blank" rel="noopener" href="http://www.redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/replication.html">复制（replication）</a>，<a target="_blank" rel="noopener" href="http://www.redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a target="_blank" rel="noopener" href="http://www.redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a target="_blank" rel="noopener" href="http://www.redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）。</p>
<h3 id="2-1-Redis自动配置"><a href="#2-1-Redis自动配置" class="headerlink" title="2.1 Redis自动配置"></a>2.1 Redis自动配置</h3><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
 <img src=" 20230323_100539.jpg" alt="image.png" style="zoom:67%;border: 5px solid orange;" />



<p>自动配置：</p>
<ul>
<li><p><strong>RedisAutoConfiguration</strong> 自动配置类：RedisProperties 配置项绑定，前綴為spring.redis</p>
</li>
<li><p>连接工厂是准备好的：可選擇LettuceConnectionConfiguration (<strong>LettuceConnectionFactory</strong> ) 或JedisConnectionConfiguration (<strong>JedisConnectionFactory</strong>)</p>
<blockquote>
<p>Lettuce、Jedis為操作redis的框架</p>
</blockquote>
</li>
<li><p>自动注入了**RedisTemplate&lt;Object, Object&gt;**：操作Redis的，k：v都是Object</p>
<blockquote>
<p>Spring底層的xxxTemplate，就是用來操作xxx的，ex：JDBCTemplate</p>
</blockquote>
</li>
<li><p>自动注入了<strong>StringRedisTemplate</strong>：k：v都是String</p>
</li>
<li><p>底层只要我们使用 <strong>StringRedisTemplate</strong>、<strong>RedisTemplate</strong>就可以操作redis</p>
</li>
</ul>
<blockquote>
<p>Redis都是使用k：v存儲的</p>
</blockquote>
<p>redis环境搭建 (阿里雲)</p>
<p>1、阿里云按量付费redis。经典网络</p>
<p>2、申请redis的公网连接地址</p>
<p>3、修改白名单  允许0.0.0.0/0 访问 (外部連結)</p>
<h3 id="2-2-RedisTemplate与Lettuce"><a href="#2-2-RedisTemplate与Lettuce" class="headerlink" title="2.2 RedisTemplate与Lettuce"></a>2.2 RedisTemplate与Lettuce</h3><pre><code class="java">@Test
void testRedis()&#123;
    ValueOperations&lt;String, String&gt; operations = redisTemplate.opsForValue();

    operations.set(&quot;hello&quot;,&quot;world&quot;);

    String hello = operations.get(&quot;hello&quot;);
    System.out.println(hello);
&#125;
</code></pre>
<h3 id="2-3-切换至jedis"><a href="#2-3-切换至jedis" class="headerlink" title="2.3 切换至jedis"></a>2.3 切换至jedis</h3><pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!--        导入jedis--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="yaml">spring:
  redis:
      host: r-bp1nc7reqesxisgxpipd.redis.rds.aliyuncs.com
      port: 6379
      password: lfy:Lfy123456
      client-type: jedis
      jedis:
        pool:
          max-active: 10
</code></pre>
<h3 id="2-4-Redis操作示例"><a href="#2-4-Redis操作示例" class="headerlink" title="2.4 Redis操作示例"></a>2.4 Redis操作示例</h3><p>相关Redis配置：</p>
<pre><code class="java">spring:
  redis:
#   url: redis://lfy:Lfy123456@r-bp1nc7reqesxisgxpipd.redis.rds.aliyuncs.com:6379  &lt;好像帳號lfy:要去掉&gt;
    host: r-bp1nc7reqesxisgxpipd.redis.rds.aliyuncs.com //從阿里雲得到
    port: 6379
    password: lfy:Lfy123456
    client-type: jedis  //選擇jedis or lettuce
    jedis:
      pool:
        max-active: 10
#   lettuce:# 另一个用来连接redis的java框架
#      pool:
#        max-active: 10
#        min-idle: 5
</code></pre>
<p>测试Redis连接：</p>
<pre><code class="java">@SpringBootTest
public class Boot05WebAdminApplicationTests &#123;

    @Autowired
    StringRedisTemplate redisTemplate;


    @Autowired
    RedisConnectionFactory redisConnectionFactory;

    @Test
    void testRedis()&#123;
        ValueOperations&lt;String, String&gt; operations = redisTemplate.opsForValue();

        operations.set(&quot;hello&quot;,&quot;world&quot;);

        String hello = operations.get(&quot;hello&quot;);
        System.out.println(hello);

        System.out.println(redisConnectionFactory.getClass());
    &#125;

&#125;
</code></pre>
<blockquote>
<p>Redis Desktop Manager：可视化Redis管理软件。</p>
</blockquote>
<p>URL统计拦截器：</p>
<pre><code class="java">@Component
public class RedisUrlCountInterceptor implements HandlerInterceptor &#123;

    @Autowired
    StringRedisTemplate redisTemplate;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;
        String uri = request.getRequestURI();

        //默认每次访问当前uri就会计数+1
        redisTemplate.opsForValue().increment(uri);

        return true;
    &#125;
&#125;
</code></pre>
<p>注册URL统计拦截器：</p>
<pre><code class="java">@Configuration
public class AdminWebConfig implements WebMvcConfigurer&#123;

    @Autowired
    RedisUrlCountInterceptor redisUrlCountInterceptor;


    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;

        registry.addInterceptor(redisUrlCountInterceptor)
                .addPathPatterns(&quot;/**&quot;)
                .excludePathPatterns(&quot;/&quot;,&quot;/login&quot;,&quot;/css/**&quot;,&quot;/fonts/**&quot;,&quot;/images/**&quot;,
                        &quot;/js/**&quot;,&quot;/aa/**&quot;);
    &#125;
&#125;
</code></pre>
<p>:bulb:Filter、Interceptor 几乎拥有相同的功能？</p>
<ul>
<li>Filter是Servlet定义的原生组件，它的好处是脱离Spring应用也能使用。</li>
<li>Interceptor是Spring定义的接口，可以使用Spring的自动装配等功能。</li>
</ul>
<p>调用Redis内的统计数据：</p>
<pre><code class="java">@Slf4j
@Controller
public class IndexController &#123;

    @Autowired
    StringRedisTemplate redisTemplate;
    
    @GetMapping(&quot;/main.html&quot;)
    public String mainPage(HttpSession session,Model model)&#123;

        log.info(&quot;当前方法是：&#123;&#125;&quot;,&quot;mainPage&quot;);

        ValueOperations&lt;String, String&gt; opsForValue =
                redisTemplate.opsForValue();

        String s = opsForValue.get(&quot;/main.html&quot;);
        String s1 = opsForValue.get(&quot;/sql&quot;);

        model.addAttribute(&quot;mainCount&quot;,s);
        model.addAttribute(&quot;sqlCount&quot;,s1);
        //將訪問次數返回到main.html
        return &quot;main&quot;;
    &#125;
&#125;
</code></pre>
<h1 id="07、单元测试"><a href="#07、单元测试" class="headerlink" title="07、单元测试"></a>07、单元测试</h1><h2 id="1-JUnit5-的變化"><a href="#1-JUnit5-的變化" class="headerlink" title="1. JUnit5 的變化"></a>1. JUnit5 的變化</h2><p><strong><font color=red>Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库</font></strong></p>
<p><a target="_blank" rel="noopener" href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations">JUnit 5官方文档</a></p>
<p>作为最新版本的JUnit框架，JUnit5与之前版本的JUnit框架有很大的不同。由三个不同子项目的几个不同模块组成。</p>
<blockquote>
<p><strong>JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage</strong></p>
</blockquote>
<ul>
<li><p><strong>JUnit Platform</strong>: Junit Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。</p>
</li>
<li><p><strong>JUnit Jupiter</strong>: JUnit Jupiter提供了JUnit5的新的编程模型，是JUnit5新特性的核心。内部包含了一个<strong>测试引擎</strong>，用于在Junit Platform上运行。</p>
</li>
<li><p><strong>JUnit Vintage</strong>: 由于JUint已经发展多年，为了照顾老的项目，JUnit Vintage提供了兼容JUnit4.x，JUnit3.x的测试引擎。</p>
</li>
</ul>
<img src=" 20230324_161806.jpg" alt="img" style="zoom:80%;" />

<img src=" 20230324_162051.jpg" alt="img" style="zoom:80%;border: 4px solid orange;" />

<p><strong>注意</strong>：</p>
<ul>
<li><p>SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖。如果需要兼容JUnit4需要自行引入（不能使用JUnit4的功能 @Test）</p>
</li>
<li><p>JUnit 5’s Vintage已经从<code>spring-boot-starter-test</code>从移除。如果需要继续兼容Junit4需要自行引入Vintage依赖：</p>
</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.hamcrest&lt;/groupId&gt;
            &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>使用添加JUnit 5，添加对应的starter：</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>Spring的JUnit 5的基本单元测试模板（Spring的JUnit4的是<code>@SpringBootTest</code>+<code>@RunWith(SpringRunner.class)</code>）：</li>
</ul>
<pre><code class="java">import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;//注意不是org.junit.Test（这是JUnit4版本的）
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class SpringBootApplicationTests &#123;

    @Autowired
    private Component component;
    
    @Test
    //@Transactional 标注后连接数据库有回滚功能
    public void contextLoads() &#123;
        Assertions.assertEquals(5, component.getFive());
    &#125;
&#125;
</code></pre>
<blockquote>
<ul>
<li>Spring的JUnit4：@SpringBootTest + @RunWith(SpringTest.class)</li>
<li>SpringBoot整合Junit以后。<ul>
<li>编写测试方法：@Test标注（注意需要使用junit5版本的注解）</li>
<li>Junit类具有Spring的功能，@Autowired、比如 @Transactional 标注测试方法，测试完成后自动回滚</li>
</ul>
</li>
</ul>
<p>:bulb:@SpringBootTest這個標註是在測試方法要使用@Autowired、@Transactional….等等Spring的功能時才要添加</p>
</blockquote>
<h2 id="2-JUnit5-常用测试注解"><a href="#2-JUnit5-常用测试注解" class="headerlink" title="2. JUnit5 常用测试注解"></a>2. JUnit5 常用测试注解</h2><p><a target="_blank" rel="noopener" href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations">官方文档 - Annotations</a></p>
<ul>
<li><strong>@Test</strong>：表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</li>
<li><strong>@ParameterizedTest</strong>：表示方法是参数化测试。</li>
<li><strong>@RepeatedTest</strong>：表示方法可重复执行。</li>
<li><strong>@DisplayName</strong>：为测试类或者测试方法设置展示名称。</li>
<li><strong>@BeforeEach</strong>：表示在<strong>每个</strong>单元测试<strong>之前</strong>执行。</li>
<li><strong>@AfterEach</strong>：表示在<strong>每个</strong>单元测试<strong>之后</strong>执行。</li>
<li><strong>@BeforeAll</strong>：表示在<strong>所有</strong>单元测试<strong>之前</strong>执行。</li>
<li><strong>@AfterAll</strong>：表示在<strong>所有</strong>单元测试<strong>之后</strong>执行。</li>
<li><strong>@Tag</strong>：表示单元测试类别，类似于JUnit4中的@Categories。</li>
<li><strong>@Disabled</strong>：表示测试类或测试方法不执行，类似于JUnit4中的@Ignore。</li>
<li><strong>@Timeout</strong>：表示测试方法运行如果超过了指定时间将会返回错误。</li>
<li><strong>@ExtendWith</strong>：为测试类或测试方法提供扩展类引用。</li>
</ul>
<pre><code class="java">import org.junit.jupiter.api.*;

@DisplayName(&quot;junit5功能测试类&quot;)
public class Junit5Test &#123;


    @DisplayName(&quot;测试displayname注解&quot;)
    @Test
    void testDisplayName() &#123;
        System.out.println(1);
        System.out.println(jdbcTemplate);
    &#125;
    
    @ParameterizedTest
    @ValueSource(strings = &#123; &quot;racecar&quot;, &quot;radar&quot;, &quot;able was I ere I saw elba&quot; &#125;)
    void palindromes(String candidate) &#123;
        assertTrue(StringUtils.isPalindrome(candidate));
    &#125;
    

    @Disabled
    @DisplayName(&quot;测试方法2&quot;)
    @Test
    void test2() &#123;
        System.out.println(2);
    &#125;

    @RepeatedTest(5)
    @Test
    void test3() &#123;
        System.out.println(5);
    &#125;

    /**
     * 规定方法超时时间。超出时间测试出异常
     *
     * @throws InterruptedException
     */
    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)
    @Test
    void testTimeout() throws InterruptedException &#123;
        Thread.sleep(600);
    &#125;


    @BeforeEach
    void testBeforeEach() &#123;
        System.out.println(&quot;测试就要开始了...&quot;);
    &#125;

    @AfterEach
    void testAfterEach() &#123;
        System.out.println(&quot;测试结束了...&quot;);
    &#125;

    @BeforeAll
    static void testBeforeAll() &#123;
        System.out.println(&quot;所有测试就要开始了...&quot;);
    &#125;

    @AfterAll
    static void testAfterAll() &#123;
        System.out.println(&quot;所有测试以及结束了...&quot;);

    &#125;

&#125;
</code></pre>
<h2 id="3-断言机制-assertions"><a href="#3-断言机制-assertions" class="headerlink" title="3. 断言机制 ( assertions )"></a>3. 断言机制 ( assertions )</h2><p>断言Assertion是测试方法中的核心部分，用来对测试需要满足的条件进行验证。这些断言方法都是org.junit.jupiter.api.Assertions的静态方法。</p>
<ul>
<li><p>检查业务逻辑返回的数据是否合理。</p>
</li>
<li><p>所有的测试运行结束以后，会有一个详细的测试报告。</p>
</li>
</ul>
<p>JUnit 5 内置的断言可以分成如下几个类别：</p>
<h3 id="3-1-简单断言"><a href="#3-1-简单断言" class="headerlink" title="3.1 简单断言"></a>3.1 简单断言</h3><p>用来对单个值进行简单的验证。如：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>assertEquals</td>
<td>判断两个对象或两个原始类型是否相等</td>
</tr>
<tr>
<td>assertNotEquals</td>
<td>判断两个对象或两个原始类型是否不相等</td>
</tr>
<tr>
<td>assertSame</td>
<td>判断两个对象引用是否指向同一个对象</td>
</tr>
<tr>
<td>assertNotSame</td>
<td>判断两个对象引用是否指向不同的对象</td>
</tr>
<tr>
<td>assertTrue</td>
<td>判断给定的布尔值是否为 true</td>
</tr>
<tr>
<td>assertFalse</td>
<td>判断给定的布尔值是否为 false</td>
</tr>
<tr>
<td>assertNull</td>
<td>判断给定的对象引用是否为 null</td>
</tr>
<tr>
<td>assertNotNull</td>
<td>判断给定的对象引用是否不为 null</td>
</tr>
</tbody></table>
<pre><code class="java">@Test
@DisplayName(&quot;測試簡單斷言&quot;)
public void simple() &#123;
    int cal = cal(3, 2)
     assertEquals(6, cal, &quot;業務邏輯計算失敗&quot;);
     assertNotEquals(6, cal);

     assertNotSame(new Object(), new Object());
     Object obj1 = new Object();
     Object obj2 = new Object();
     assertSame(obj1, obj2, &quot;兩者對象不一樣&quot;);

     assertFalse(1 &gt; 2);
     assertTrue(1 &lt; 2);

     assertNull(null);
     assertNotNull(new Object());
    
&#125;

int cal(int i, int j)&#123;
    return i+j;
&#125;
</code></pre>
<blockquote>
<p>前面的斷言失敗後，後面的代碼都不會執行</p>
</blockquote>
<h3 id="3-2-数组断言"><a href="#3-2-数组断言" class="headerlink" title="3.2 数组断言"></a>3.2 数组断言</h3><p>通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等。</p>
<pre><code class="java">@Test
@DisplayName(&quot;array assertion&quot;)
public void array() &#123;
    assertArrayEquals(new int[]&#123;1, 2&#125;, new int[] &#123;1, 2&#125;);
&#125;
</code></pre>
<h3 id="3-3-组合断言"><a href="#3-3-组合断言" class="headerlink" title="3.3 组合断言"></a>3.3 组合断言</h3><p><code>assertAll()</code>方法接受多个 <code>org.junit.jupiter.api.Executable</code> 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言。</p>
<pre><code class="java">@Test
@DisplayName(&quot;assert all&quot;)
public void all() &#123;
 assertAll(&quot;Math&quot;,
    () -&gt; assertEquals(2, 1 + 1),
    () -&gt; assertTrue(1 &gt; 0)
 );
&#125;
</code></pre>
<blockquote>
<ul>
<li>組合斷言需全部斷言都成功，否則算失敗</li>
</ul>
</blockquote>
<h3 id="3-4-异常断言"><a href="#3-4-异常断言" class="headerlink" title="3.4 异常断言"></a>3.4 异常断言</h3><p>在JUnit4时期，想要测试方法的异常情况时，需要用<code>@Rule</code>注解的<code>ExpectedException</code>变量还是比较麻烦的。而JUnit5提供了一种新的断言方式<code>Assertions.assertThrows()</code>，配合函数式编程就可以进行使用。</p>
<pre><code class="java">@Test
@DisplayName(&quot;异常测试&quot;)
public void exceptionTest() &#123;
    ArithmeticException exception = Assertions.assertThrows(
           //扔出断言异常
            ArithmeticException.class, () -&gt; System.out.println(1 % 0));
&#125;
</code></pre>
<h3 id="3-5-超时断言"><a href="#3-5-超时断言" class="headerlink" title="3.5 超时断言"></a>3.5 超时断言</h3><p>JUnit5还提供了Assertions.assertTimeout()为测试方法设置了超时时间。</p>
<pre><code class="java">@Test
@DisplayName(&quot;超时测试&quot;)
public void timeoutTest() &#123;
    //如果测试方法时间超过1s将会异常
    Assertions.assertTimeout(Duration.ofMillis(1000), () -&gt; Thread.sleep(500));
&#125;
</code></pre>
<h3 id="3-6-快速失败"><a href="#3-6-快速失败" class="headerlink" title="3.6 快速失败"></a>3.6 快速失败</h3><p>通过 fail 方法直接使得测试失败。</p>
<pre><code class="java">@Test
@DisplayName(&quot;fail&quot;)
public void shouldFail() &#123;
    fail(&quot;This should fail&quot;);
&#125;
</code></pre>
<h2 id="4-前置条件（assumptions）"><a href="#4-前置条件（assumptions）" class="headerlink" title="4. 前置条件（assumptions）"></a>4. 前置条件（assumptions）</h2><p>Unit 5 中的前置条件（assumptions【假设】）类似于断言，不同之处在于<strong>不满足的断言assertions会使得测试方法失败</strong>，而<strong>不满足的前置条件只会使得测试方法的执行终止</strong>。</p>
<blockquote>
<ul>
<li>在測試報告中<ul>
<li>斷言失敗：歸到Error</li>
<li>前置條件失敗：歸到skipped</li>
</ul>
</li>
</ul>
</blockquote>
<p>前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。</p>
<pre><code class="java">@DisplayName(&quot;前置条件&quot;)
public class AssumptionsTest &#123;
    private final String environment = &quot;DEV&quot;;

    @Test
    @DisplayName(&quot;simple&quot;)
    public void simpleAssume() &#123;
        assumeTrue(Objects.equals(this.environment, &quot;DEV&quot;));
        assumeFalse(() -&gt; Objects.equals(this.environment, &quot;PROD&quot;));
    &#125;

    @Test
    @DisplayName(&quot;assume then do&quot;)
    public void assumeThenDo() &#123;
        assumingThat(
            Objects.equals(this.environment, &quot;DEV&quot;),
            () -&gt; System.out.println(&quot;In DEV&quot;)
        );
    &#125;
&#125;
</code></pre>
<p><code>assumeTrue</code> 和 <code>assumFalse</code> 确保给定的条件为 <code>true</code> 或 <code>false</code>，不满足条件会使得测试执行终止。</p>
<p><code>assumingThat</code> 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，<code>Executable</code> 对象才会被执行；当条件不满足时，测试执行并不会终止。</p>
<h2 id="5-嵌套测试"><a href="#5-嵌套测试" class="headerlink" title="5. 嵌套测试"></a>5. 嵌套测试</h2><p><a target="_blank" rel="noopener" href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-nested">官方文档 - Nested Tests</a></p>
<p>JUnit 5 可以通过 Java 中的内部类和<code>@Nested</code> 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用<code>@BeforeEach</code> 和<code>@AfterEach</code>注解，而且嵌套的层次没有限制。</p>
<blockquote>
<p>嵌套測試情況下</p>
<ul>
<li><p>外層的Test不能驅動內層的Before(After)Each/All 之類的方法 (提前/之後) 運行</p>
</li>
<li><p>內層的可以驅動外層的Before(After)Each/All 之類的方法 (提前/之後) 運行</p>
</li>
</ul>
</blockquote>
<pre><code class="java">@DisplayName(&quot;A stack&quot;)
class TestingAStackDemo &#123;

    Stack&lt;Object&gt; stack;

    @Test
    @DisplayName(&quot;is instantiated with new Stack()&quot;)
    void isInstantiatedWithNew() &#123;
        new Stack&lt;&gt;();
    &#125;

    @Nested
    @DisplayName(&quot;when new&quot;)
    class WhenNew &#123;

        @BeforeEach
        void createNewStack() &#123;
            stack = new Stack&lt;&gt;();
        &#125;

        @Test
        @DisplayName(&quot;is empty&quot;)
        void isEmpty() &#123;
            assertTrue(stack.isEmpty());
        &#125;

        @Test
        @DisplayName(&quot;throws EmptyStackException when popped&quot;)
        void throwsExceptionWhenPopped() &#123;
            assertThrows(EmptyStackException.class, stack::pop);
        &#125;

        @Test
        @DisplayName(&quot;throws EmptyStackException when peeked&quot;)
        void throwsExceptionWhenPeeked() &#123;
            assertThrows(EmptyStackException.class, stack::peek);
        &#125;

        @Nested
        @DisplayName(&quot;after pushing an element&quot;)
        class AfterPushing &#123;

            String anElement = &quot;an element&quot;;

            @BeforeEach
            void pushAnElement() &#123;
                stack.push(anElement);
            &#125;

            @Test
            @DisplayName(&quot;it is no longer empty&quot;)
            void isNotEmpty() &#123;
                assertFalse(stack.isEmpty());
            &#125;

            @Test
            @DisplayName(&quot;returns the element when popped and is empty&quot;)
            void returnElementWhenPopped() &#123;
                assertEquals(anElement, stack.pop());
                assertTrue(stack.isEmpty());
            &#125;

            @Test
            @DisplayName(&quot;returns the element when peeked but remains not empty&quot;)
            void returnElementWhenPeeked() &#123;
                assertEquals(anElement, stack.peek());
                assertFalse(stack.isEmpty());
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="6-参数化测试"><a href="#6-参数化测试" class="headerlink" title="6. 参数化测试"></a>6. 参数化测试</h2><p><a target="_blank" rel="noopener" href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests">官方文档 - Parameterized Tests</a></p>
<p>参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。</p>
<p>利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p>
<ul>
<li><strong>@ValueSource</strong>: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型</li>
<li><strong>@NullSource</strong>: 表示为参数化测试提供一个null的入参</li>
<li><strong>@EnumSource</strong>: 表示为参数化测试提供一个枚举入参</li>
<li><strong>@CsvFileSource</strong>：表示读取指定CSV文件内容作为参数化测试入参</li>
<li><strong>@MethodSource</strong>：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)</li>
<li></li>
</ul>
<blockquote>
<p>当然如果参数化测试仅仅只能做到指定普通的入参还达不到让我觉得惊艳的地步。让我真正感到他的强大之处的地方在于他可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现**<code>ArgumentsProvider</code>**接口，任何外部文件都可以作为它的入参。</p>
</blockquote>
<pre><code class="java">@ParameterizedTest
@ValueSource(strings = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)
@DisplayName(&quot;参数化测试1&quot;)
public void parameterizedTest1(String string) &#123;
    System.out.println(string);
    Assertions.assertTrue(StringUtils.isNotBlank(string));
&#125;


@ParameterizedTest
@MethodSource(&quot;method&quot;)    //指定方法名
@DisplayName(&quot;方法来源参数&quot;)
public void testWithExplicitLocalMethodSource(String name) &#123;
    System.out.println(name);
    Assertions.assertNotNull(name);
&#125;

static Stream&lt;String&gt; method() &#123;
    return Stream.of(&quot;apple&quot;, &quot;banana&quot;);
&#125;
</code></pre>
<h2 id="7-迁移指南"><a href="#7-迁移指南" class="headerlink" title="7. 迁移指南"></a>7. 迁移指南</h2><p><a target="_blank" rel="noopener" href="https://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4">官方文档 - Migrating from JUnit 4</a></p>
<p>在进行迁移的时候需要注意如下的变化：</p>
<ul>
<li>注解在 <code>org.junit.jupiter.api</code> 包中，断言在 <code>org.junit.jupiter.api.Assertions</code> 类中，前置条件在 <code>org.junit.jupiter.api.Assumptions</code> 类中。</li>
<li>把<code>@Before</code> 和<code>@After</code> 替换成<code>@BeforeEach</code> 和<code>@AfterEach</code>。</li>
<li>把<code>@BeforeClass</code> 和<code>@AfterClass</code> 替换成<code>@BeforeAll</code> 和@AfterAll。</li>
<li>把<code>@Ignore</code> 替换成<code>@Disabled</code>。</li>
<li>把<code>@Category</code> 替换成<code>@Tag</code>。</li>
<li>把<code>@RunWith</code>、<code>@Rule</code> 和<code>@ClassRule</code> 替换成<code>@ExtendWith</code>。</li>
</ul>
<h1 id="08、指标监控"><a href="#08、指标监控" class="headerlink" title="08、指标监控"></a>08、指标监控</h1><h2 id="1-SpringBoot-Actuator"><a href="#1-SpringBoot-Actuator" class="headerlink" title="1. SpringBoot Actuator"></a>1. SpringBoot Actuator</h2><h3 id="1-1-簡介"><a href="#1-1-簡介" class="headerlink" title="1.1 簡介"></a>1.1 簡介</h3><p>未来每一个微服务在云上部署以后，我们都需要对其进行监控、追踪、审计、控制等。SpringBoot就抽取了Actuator场景，使得我们每个微服务快速引用即可获得生产级别的应用监控、审计等功能。</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#production-ready">官方文档 - Spring Boot Actuator: Production-ready Features</a></p>
<h3 id="1-2-1-x与2-x的不同："><a href="#1-2-1-x与2-x的不同：" class="headerlink" title="1.2 1.x与2.x的不同："></a>1.2 1.x与2.x的不同：</h3><img src=" 20230325_010037.jpg" alt="img" style="zoom:67%;" />



<h3 id="1-3-如何使用"><a href="#1-3-如何使用" class="headerlink" title="1.3 如何使用"></a>1.3 如何使用</h3><ul>
<li>添加依赖：</li>
</ul>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>访问<code>http://localhost:8080/actuator/**</code>。</li>
</ul>
<p>由於endpoint默認在HTTP下並非全部暴露 (可參考 [Endpoints默認的暴露方式](#2.4.2 暴露Endpoints) ) ，若要在HTTP下全部暴露，可到application.yaml設置下面配置</p>
<ul>
<li>暴露所有监控信息为HTTP。</li>
</ul>
<pre><code class="yaml">management:
  endpoints:
    enabled-by-default: true #暴露所有端点信息
    web:
      exposure:
        include: &#39;*&#39;  #以web方式暴露
</code></pre>
<ul>
<li><p>测试例子</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://localhost:8080/actuator/beans">http://localhost:8080/actuator/beans</a></li>
<li><a target="_blank" rel="noopener" href="http://localhost:8080/actuator/configprops">http://localhost:8080/actuator/configprops</a></li>
<li><a target="_blank" rel="noopener" href="http://localhost:8080/actuator/metrics">http://localhost:8080/actuator/metrics</a></li>
<li><a target="_blank" rel="noopener" href="http://localhost:8080/actuator/metrics/jvm.gc.pause">http://localhost:8080/actuator/metrics/jvm.gc.pause</a></li>
</ul>
</li>
</ul>
<p>語法格式： <code>http://localhost:8080/actuator/endpointName/detailPath</code></p>
<blockquote>
<p>若要在Http下看jason格式的東西，可以在瀏覽器安裝”FeHelper”美化頁面展示</p>
</blockquote>
<h3 id="1-4-可視化-略"><a href="#1-4-可視化-略" class="headerlink" title="1.4 可視化 (略)"></a>1.4 可視化 (略)</h3><p>若有需求，也可參考下面可視化界面</p>
<p><a target="_blank" rel="noopener" href="https://github.com/codecentric/spring-boot-admin">https://github.com/codecentric/spring-boot-admin</a></p>
<h2 id="2-Actuator-Endpoint"><a href="#2-Actuator-Endpoint" class="headerlink" title="2. Actuator Endpoint"></a>2. Actuator Endpoint</h2><h3 id="2-1-常使用的端点"><a href="#2-1-常使用的端点" class="headerlink" title="2.1 常使用的端点"></a>2.1 常使用的端点</h3><table>
<thead>
<tr>
<th>ID</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>auditevents</code></td>
<td>暴露当前应用程序的审核事件信息。需要一个<code>AuditEventRepository组件</code>。</td>
</tr>
<tr>
<td><code>beans</code></td>
<td>显示应用程序中所有Spring Bean的完整列表。</td>
</tr>
<tr>
<td><code>caches</code></td>
<td>暴露可用的缓存。</td>
</tr>
<tr>
<td><code>conditions</code></td>
<td>显示自动配置的所有条件信息，包括匹配或不匹配的原因。</td>
</tr>
<tr>
<td><code>configprops</code></td>
<td>显示所有<code>@ConfigurationProperties</code>。</td>
</tr>
<tr>
<td><code>env</code></td>
<td>暴露Spring的属性<code>ConfigurableEnvironment</code></td>
</tr>
<tr>
<td><code>flyway</code></td>
<td>显示已应用的所有Flyway数据库迁移。 需要一个或多个<code>Flyway</code>组件。</td>
</tr>
<tr>
<td><code>health</code></td>
<td>显示应用程序运行状况信息。</td>
</tr>
<tr>
<td><code>httptrace</code></td>
<td>显示HTTP跟踪信息（默认情况下，最近100个HTTP请求-响应）。需要一个<code>HttpTraceRepository</code>组件。</td>
</tr>
<tr>
<td><code>info</code></td>
<td>显示应用程序信息。</td>
</tr>
<tr>
<td><code>integrationgraph</code></td>
<td>显示Spring <code>integrationgraph</code> 。需要依赖<code>spring-integration-core</code>。</td>
</tr>
<tr>
<td><code>loggers</code></td>
<td>显示和修改应用程序中日志的配置。</td>
</tr>
<tr>
<td><code>liquibas</code></td>
<td>显示已应用的所有Liquibase数据库迁移。需要一个或多个<code>Liquibase</code>组件。</td>
</tr>
<tr>
<td><code>metrics</code></td>
<td>显示当前应用程序的“指标”信息。</td>
</tr>
<tr>
<td><code>mappings</code></td>
<td>显示所有<code>@RequestMapping</code>路径列表。</td>
</tr>
<tr>
<td><code>scheduledtasks</code></td>
<td>显示应用程序中的计划任务。</td>
</tr>
<tr>
<td><code>sessions</code></td>
<td>允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序。</td>
</tr>
<tr>
<td><code>shutdown</code></td>
<td>使应用程序正常关闭。默认禁用。</td>
</tr>
<tr>
<td><code>startup</code></td>
<td>显示由<code>ApplicationStartup</code>收集的启动步骤数据。需要使用<code>SpringApplication</code>进行配置<code>BufferingApplicationStartup</code>。</td>
</tr>
<tr>
<td><code>threaddump</code></td>
<td>执行线程转储。</td>
</tr>
</tbody></table>
<p>如果您的应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>heapdump</td>
<td>返回<code>hprof</code>堆转储文件。</td>
</tr>
<tr>
<td>jolokia</td>
<td>通过HTTP暴露JMX bean（需要引入Jolokia，不适用于WebFlux）。需要引入依赖<code>jolokia-core</code>。</td>
</tr>
<tr>
<td>logfile</td>
<td>返回日志文件的内容（如果已设置<code>logging.file.name</code>或<code>logging.file.path</code>属性）。支持使用HTTP<code>Range</code>标头来检索部分日志文件的内容。</td>
</tr>
<tr>
<td>prometheus</td>
<td>以Prometheus服务器可以抓取的格式公开指标。需要依赖<code>micrometer-registry-prometheus</code>。</td>
</tr>
</tbody></table>
<p>其中最常用的Endpoint：</p>
<ul>
<li><strong>Health：监控健康状况</strong></li>
<li><strong>Metrics：运行时指标</strong></li>
<li><strong>Loggers：日志记录</strong></li>
</ul>
<h3 id="2-2-Health-Endpoint"><a href="#2-2-Health-Endpoint" class="headerlink" title="2.2 Health Endpoint"></a>2.2 Health Endpoint</h3><p>健康检查端点，我们一般用于在云平台，平台会定时的检查应用的健康状况，我们就需要Health Endpoint可以为平台返回当前应用的一系列组件健康状况的集合。</p>
<p>重要的几点：</p>
<ul>
<li>health endpoint返回的结果，应该是一系列健康检查后的一个汇总报告。</li>
<li>很多的健康检查默认已经自动配置好了，比如：数据库、redis等。</li>
<li>可以很容易的添加自定义的健康检查机制。</li>
</ul>
<p>Health Endpoint開啟顯示詳細內容：</p>
 <img src=" 20230325_121343.jpg" alt="img" style="border: 3px solid orange;" />



<blockquote>
<p>K8s的自癒功能，就是利用健康監控</p>
</blockquote>
<h3 id="2-3-Metrics-Endpoint"><a href="#2-3-Metrics-Endpoint" class="headerlink" title="2.3 Metrics Endpoint"></a>2.3 Metrics Endpoint</h3><p>提供详细的、层级的、空间指标信息，这些信息可以被pull（主动推送）或者push（被动获取）方式得到：</p>
<ul>
<li>通过Metrics对接多种监控系统。</li>
<li>简化核心Metrics开发。</li>
<li>添加自定义Metrics或者扩展已有Metrics。</li>
</ul>
<p>Metrics監控指標內容如下：</p>
 <img src=" 20230325_121809.jpg" alt="img" style="zoom:80%;border: 4px solid orange;" />



<h3 id="2-4-管理Endpoints"><a href="#2-4-管理Endpoints" class="headerlink" title="2.4. 管理Endpoints"></a>2.4. 管理Endpoints</h3><h5 id="2-4-1-开启与禁用Endpoints"><a href="#2-4-1-开启与禁用Endpoints" class="headerlink" title="2.4.1 开启与禁用Endpoints"></a>2.4.1 开启与禁用Endpoints</h5><ul>
<li>默认所有的Endpoint除过shutdown都是开启的。</li>
<li>需要开启或者禁用某个Endpoint。配置模式为<code>management.endpoint.&lt;endpointName&gt;.enabled = true</code></li>
</ul>
<pre><code class="yaml">management:
  endpoint:
    beans:
      enabled: true
</code></pre>
<ul>
<li>或者禁用所有的Endpoint然后手动开启指定的Endpoint。</li>
</ul>
<pre><code class="yaml">management:
  endpoints:
    enabled-by-default: false
  endpoint:
    beans:
      enabled: true
    health:
      enabled: true
</code></pre>
<h5 id="2-4-2-暴露Endpoints"><a href="#2-4-2-暴露Endpoints" class="headerlink" title="2.4.2 暴露Endpoints"></a>2.4.2 暴露Endpoints</h5><p>支持的暴露方式</p>
<ul>
<li>HTTP：默认只暴露health和info。</li>
<li>JMX：默认暴露所有Endpoint。</li>
<li>除过health和info，剩下的Endpoint都应该进行保护访问。如果引入Spring Security，则会默认配置安全访问规则。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">ID</th>
<th align="left">JMX</th>
<th align="left">Web</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>auditevents</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>beans</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>caches</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>conditions</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>configprops</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>env</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>flyway</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>health</code></td>
<td align="left">Yes</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left"><code>heapdump</code></td>
<td align="left">N/A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>httptrace</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>info</code></td>
<td align="left">Yes</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left"><code>integrationgraph</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>jolokia</code></td>
<td align="left">N/A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>logfile</code></td>
<td align="left">N/A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>loggers</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>liquibase</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>metrics</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>mappings</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>prometheus</code></td>
<td align="left">N/A</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>scheduledtasks</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>sessions</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>shutdown</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>startup</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left"><code>threaddump</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
</tbody></table>
<p>若要更改公开的Endpoint，请配置以下的包含和排除属性：</p>
<table>
<thead>
<tr>
<th align="left">Property</th>
<th align="left">Default</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>management.endpoints.jmx.exposure.exclude</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>management.endpoints.jmx.exposure.include</code></td>
<td align="left"><code>*</code></td>
</tr>
<tr>
<td align="left"><code>management.endpoints.web.exposure.exclude</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>management.endpoints.web.exposure.include</code></td>
<td align="left"><code>info, health</code></td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#production-ready-endpoints-exposing-endpoints">官方文档 - Exposing Endpoints</a></p>
<blockquote>
<p>JMX協定：java控制台可用 (ex：jconsole)</p>
</blockquote>
<h2 id="3-指标监控-定制Endpoint"><a href="#3-指标监控-定制Endpoint" class="headerlink" title="3. 指标监控-定制Endpoint"></a>3. 指标监控-定制Endpoint</h2><h3 id="3-1-定制-Health-信息"><a href="#3-1-定制-Health-信息" class="headerlink" title="3.1 定制 Health 信息"></a>3.1 定制 Health 信息</h3><ul>
<li>開啟health管理詳情顯示</li>
</ul>
<pre><code class="yaml">management:
    health:
      enabled: true
      show-details: always #总是显示详细信息。可显示每个模块的状态信息
</code></pre>
<ul>
<li>可以通过实现<code>HealthIndicator </code>接口，或继承<code>MyComHealthIndicator </code>类。</li>
</ul>
<p>实现<code>HealthIndicator </code>接口</p>
<pre><code class="java">import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

@Component
public class MyHealthIndicator implements HealthIndicator &#123;

    @Override
    public Health health() &#123;
        int errorCode = check(); // perform some specific health check
        if (errorCode != 0) &#123;
            return Health.down().withDetail(&quot;Error Code&quot;, errorCode).build();
        &#125;
        return Health.up().build();
    &#125;

&#125;

/*
构建Health
Health build = Health.down()
                .withDetail(&quot;msg&quot;, &quot;error service&quot;)
                .withDetail(&quot;code&quot;, &quot;500&quot;)
                .withException(new RuntimeException())
                .build();
*/
</code></pre>
<p>继承<code>AbstractHealthIndicator</code>类</p>
<pre><code class="java">@Component
public class MyComHealthIndicator extends AbstractHealthIndicator &#123;

    /**
     * 真实的检查方法
     * @param builder
     * @throws Exception
     */
    @Override
    protected void doHealthCheck(Health.Builder builder) throws Exception &#123;
        //mongodb。  获取连接进行测试
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        // 检查的業務邏輯
        if(1 == 2)&#123;
//            builder.up(); //健康
            builder.status(Status.UP);
            map.put(&quot;count&quot;,1);
            map.put(&quot;ms&quot;,100);
        &#125;else &#123;
//            builder.down();
            builder.status(Status.OUT_OF_SERVICE);
            map.put(&quot;err&quot;,&quot;连接超时&quot;);
            map.put(&quot;ms&quot;,3000);
        &#125;


        builder.withDetail(&quot;code&quot;,100)
                .withDetails(map);

    &#125;
&#125;
</code></pre>
<blockquote>
<p>:bulb:一定要將方法名定義為xxxxHealthIndicator，在health監控顯示時會顯示xxxx</p>
</blockquote>
<h3 id="3-2-定制info信息"><a href="#3-2-定制info信息" class="headerlink" title="3.2 定制info信息"></a>3.2 定制info信息</h3><p>常用两种方式：</p>
<ul>
<li>编写配置文件</li>
</ul>
<pre><code class="yaml">info:
  appName: boot-admin   #自訂義，寫死的
  version: 2.0.1        #自訂義，寫死的
  mavenProjectName: @project.artifactId@  #使用@@可以获取maven的pom文件值  -&gt;動態獲取
  mavenProjectVersion: @project.version@  #使用@@可以获取maven的pom文件值  -&gt;動態獲取
</code></pre>
<ul>
<li>编写InfoContributor</li>
</ul>
<pre><code class="java">import java.util.Collections;

import org.springframework.boot.actuate.info.Info;
import org.springframework.boot.actuate.info.InfoContributor;
import org.springframework.stereotype.Component;

@Component
public class ExampleInfoContributor implements InfoContributor &#123;

    @Override
    public void contribute(Info.Builder builder) &#123;
        builder.withDetail(&quot;example&quot;,
                Collections.singletonMap(&quot;key&quot;, &quot;value&quot;));
    &#125;

&#125;
</code></pre>
<blockquote>
<p><code>http://localhost:8080/actuator/info</code> 会输出以上兩種方式返回的所有info信息</p>
</blockquote>
<h3 id="3-3-定制Metrics信息"><a href="#3-3-定制Metrics信息" class="headerlink" title="3.3 定制Metrics信息"></a>3.3 定制Metrics信息</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#production-ready-metrics-meter">官方文檔：Spring Boot支持的metrics</a></p>
<h5 id="3-3-1-SpringBoot支持自动适配的Metrics"><a href="#3-3-1-SpringBoot支持自动适配的Metrics" class="headerlink" title="3.3.1 SpringBoot支持自动适配的Metrics"></a>3.3.1 SpringBoot支持自动适配的Metrics</h5><ul>
<li><p>JVM metrics, report utilization of:</p>
</li>
<li><ul>
<li>Various memory and buffer pools</li>
</ul>
</li>
<li><p>Statistics related to garbage collection</p>
</li>
<li><p>Threads utilization</p>
</li>
<li><p>Number of classes loaded/unloaded</p>
</li>
<li><p>CPU metrics</p>
</li>
<li><p>File descriptor metrics</p>
</li>
<li><p>Kafka consumer and producer metrics</p>
</li>
<li><p>Log4j2 metrics: record the number of events logged to Log4j2 at each level</p>
</li>
<li><p>Logback metrics: record the number of events logged to Logback at each level</p>
</li>
<li><p>Uptime metrics: report a gauge for uptime and a fixed gauge representing the application’s absolute start time</p>
</li>
<li><p>Tomcat metrics (<code>server.tomcat.mbeanregistry.enabled</code> must be set to <code>true</code> for all Tomcat metrics to be registered)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-integration/docs/5.4.1/reference/html/system-management.html#micrometer-integration">Spring Integration</a> metrics</p>
</li>
</ul>
<blockquote>
<p>上述Metrics監控的指標由Spring Integration整合</p>
</blockquote>
<h5 id="3-3-2-增加定制Metrics："><a href="#3-3-2-增加定制Metrics：" class="headerlink" title="3.3.2 增加定制Metrics："></a>3.3.2 增加定制Metrics：</h5><pre><code class="java">class MyService&#123;
    Counter counter;
    //使用構造器注入MeterRegistry
    public MyService(MeterRegistry meterRegistry)&#123;
         counter = meterRegistry.counter(&quot;myservice.method.running.counter&quot;); 
        //&quot;myservice.method.running.counter&quot; 要展示在metris上的指標名
    &#125;

    public void hello() &#123;
        counter.increment();  //在監控的方法上，調用此方法，實現每調用一次就增加計數一次
    &#125;
&#125;
</code></pre>
<pre><code class="java">//也可以使用下面的方式
@Bean
MeterBinder queueSize(Queue queue) &#123;
    return (registry) -&gt; Gauge.builder(&quot;queueSize&quot;, queue::size).register(registry);
&#125;
</code></pre>
<h3 id="3-4-定制Endpoint"><a href="#3-4-定制Endpoint" class="headerlink" title="3.4 定制Endpoint"></a>3.4 定制Endpoint</h3><pre><code class="java">@Component
@Endpoint(id = &quot;container&quot;) //要展示在metris上的指標名
public class DockerEndpoint &#123;

    @ReadOperation
    public Map getDockerInfo()&#123;
        return Collections.singletonMap(&quot;info&quot;,&quot;docker started...&quot;);
    &#125;

    @WriteOperation
    private void restartDocker()&#123;
        System.out.println(&quot;docker restarted....&quot;);
    &#125;

&#125;
</code></pre>
<blockquote>
<p>自定義Endpoint默認為暴露開啟 (2.5.x 好像要加到配置文件開啟??未確定)</p>
</blockquote>
<p>使用场景：</p>
<ul>
<li>开发ReadinessEndpoint来管理程序是否就绪。</li>
<li>开发LivenessEndpoint来管理程序是否存活。</li>
</ul>
<p>当然，这个也可以直接使用 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-kubernetes-probes">https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-kubernetes-probes</a></p>
<p>更多内容参照：大厂学院</p>
<p><a target="_blank" rel="noopener" href="https://codecentric.github.io/spring-boot-admin/2.3.1/#getting-started">https://codecentric.github.io/spring-boot-admin/2.3.1/#getting-started</a>)</p>
<h1 id="09、原理解析"><a href="#09、原理解析" class="headerlink" title="09、原理解析"></a>09、原理解析</h1><h2 id="1-Profile功能"><a href="#1-Profile功能" class="headerlink" title="1. Profile功能"></a>1. Profile功能</h2><p>为了方便多环境适配，Spring Boot简化了profile功能。</p>
<h3 id="1-1-application-profile功能"><a href="#1-1-application-profile功能" class="headerlink" title="1.1 application-profile功能"></a>1.1 application-profile功能</h3><ul>
<li><p>默认配置文件<code>application.yaml</code>任何时候都会加载。</p>
<blockquote>
<p><code>application.yaml</code> 或 <code>application.properties</code>都可以，不看副檔名</p>
</blockquote>
</li>
<li><p>指定环境配置文件<code>application-&#123;env&#125;.yaml</code>，<code>env</code>通常替代为<code>test</code>，</p>
</li>
<li><p>激活指定环境</p>
<ul>
<li><p>配置文件激活：<code>spring.profiles.active=prod</code></p>
<blockquote>
<p>在默認配置文件中配置</p>
</blockquote>
</li>
<li><p>命令行激活：<code>java -jar xxx.jar --spring.profiles.active=prod  --person.name=haha</code></p>
<blockquote>
<p>可以在打包後，利用命令行激活jar包啟動服務器，並且在激活時臨時只定要以什麼環境啟動，同時能修改配置文件的任意值，<strong>命令行优先於jar包內配置的信息</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p>默认配置与环境配置同时生效</p>
</li>
<li><p>同名配置项，profile配置优先</p>
</li>
</ul>
<h3 id="1-2-Profile条件装配功能"><a href="#1-2-Profile条件装配功能" class="headerlink" title="1.2 @Profile条件装配功能"></a>1.2 @Profile条件装配功能</h3><pre><code class="java">@Data
@Component
@ConfigurationProperties(&quot;person&quot;)//在配置文件中綁定的配置
public class Person&#123;
    private String name;
    private Integer age;
&#125;
</code></pre>
<p>application.properties</p>
<pre><code class="yaml">person: 
  name: lun
  age: 8
</code></pre>
<hr>
<pre><code class="java">public interface Person &#123;

   String getName();
   Integer getAge();

&#125;

@Profile(&quot;test&quot;)//當環境為test時才執行
@Component
@ConfigurationProperties(&quot;person&quot;)
@Data
public class Worker implements Person &#123;

    private String name;
    private Integer age;
&#125;

@Profile(value = &#123;&quot;prod&quot;,&quot;default&quot;&#125;)//當環境為prod或默認環境時才執行
@Component
@ConfigurationProperties(&quot;person&quot;)
@Data
public class Boss implements Person &#123;

    private String name;
    private Integer age;
&#125;
</code></pre>
<p>application-test.yaml</p>
<pre><code class="yaml">person:
  name: test-张三

server:
  port: 7000
</code></pre>
<p>application-prod.yaml</p>
<pre><code class="yaml">person:
  name: prod-李四

server:
  port: 8000
</code></pre>
<p>application.properties</p>
<pre><code class="properties"># 激活prod配置文件
spring.profiles.active=prod
</code></pre>
<pre><code class="java">@Autowired
private Person person;

@GetMapping(&quot;/&quot;)
public String hello()&#123;
    //激活了prod，则返回Boss.class；激活了test，则返回Worker.c;ass
    return person.getClass().toString();
&#125;
</code></pre>
<hr>
<p>@Profile还可以修饰在方法上：</p>
<pre><code class="java">class Color &#123;
&#125;

@Configuration
public class MyConfig &#123;

    @Profile(&quot;prod&quot;)
    @Bean
    public Color red()&#123;
        return new Color();
    &#125;

    @Profile(&quot;test&quot;)
    @Bean
    public Color green()&#123;
        return new Color();
    &#125;
&#125;
</code></pre>
<hr>
<h3 id="1-3-profile分组"><a href="#1-3-profile分组" class="headerlink" title="1.3 profile分组"></a>1.3 profile分组</h3><p>使用<code>spring.profiles.active=production</code>可以激活<code>spring.profiles.group.production</code>分組下的全部配置，分組下的全部配置文件會全部生效</p>
<pre><code class="properties">spring.profiles.active=production

spring.profiles.group.production[0]=proddb
spring.profiles.group.production[1]=prodmq
</code></pre>
<h2 id="2-外部化配置"><a href="#2-外部化配置" class="headerlink" title="2. 外部化配置"></a>2. 外部化配置</h2><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#boot-features-external-config">官方文档 - Externalized Configuration</a></p>
<p>Spring Boot uses a very particular <code>PropertySource</code> order that is designed to allow sensible overriding of values. Properties are considered in the following order (with values from lower items overriding earlier ones)（1优先级最低，14优先级最高）:</p>
<blockquote>
<p>:bulb:後面的會覆蓋前面的同名配置</p>
</blockquote>
<ol>
<li>Default properties (specified by setting <code>SpringApplication.setDefaultProperties</code>).</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.3.3/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a> annotations on your <code>@Configuration</code> classes. Please note that such property sources are not added to the <code>Environment</code> until the application context is being refreshed. This is too late to configure certain properties such as <code>logging.*</code> and <code>spring.main.*</code> which are read before refresh begins.</li>
<li>Config data (such as <code>application.properties</code> files)</li>
<li>A <code>RandomValuePropertySource</code> that has properties only in <code>random.*</code>.</li>
<li>OS environment variables.</li>
<li>Java System properties (<code>System.getProperties()</code>).</li>
<li>JNDI attributes from <code>java:comp/env</code>.</li>
<li><code>ServletContext</code> init parameters.</li>
<li><code>ServletConfig</code> init parameters.</li>
<li>Properties from <code>SPRING_APPLICATION_JSON</code> (inline JSON embedded in an environment variable or system property).</li>
<li>Command line arguments.</li>
<li><code>properties</code> attribute on your tests. Available on <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/api/org/springframework/boot/test/context/SpringBootTest.html"><code>@SpringBootTest</code></a> and the <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests">test annotations for testing a particular slice of your application</a>.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.3.3/javadoc-api/org/springframework/test/context/TestPropertySource.html"><code>@TestPropertySource</code></a> annotations on your tests.</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#using-boot-devtools-globalsettings">Devtools global settings properties</a> in the <code>$HOME/.config/spring-boot</code> directory when devtools is active.</li>
</ol>
<pre><code class="java">import org.springframework.stereotype.*;
import org.springframework.beans.factory.annotation.*;

@Component
public class MyBean &#123;

    @Value(&quot;$&#123;name&#125;&quot;)//以这种方式可以获得配置值
    private String name;

    // ...

&#125;
</code></pre>
<hr>
<h3 id="2-1-外部配置源"><a href="#2-1-外部配置源" class="headerlink" title="2.1 外部配置源"></a>2.1 外部配置源</h3><p>主要有下面幾種配置來源：</p>
<ul>
<li>Java属性文件。</li>
<li>YAML文件。</li>
<li>环境变量。</li>
<li>命令行参数。</li>
</ul>
<h3 id="2-2-配置文件默認查找位置"><a href="#2-2-配置文件默認查找位置" class="headerlink" title="2.2 配置文件默認查找位置"></a>2.2 配置文件默認查找位置</h3><ol>
<li>classpath 根路径。</li>
<li>classpath 根路径下config目录。</li>
<li>jar包当前目录。</li>
<li>jar包当前目录的config目录。</li>
<li>/config子目录的直接子目录。 (only 一級子目錄)</li>
</ol>
<blockquote>
<p>後面的會覆蓋前面的配置</p>
</blockquote>
<h3 id="2-3-配置文件加载顺序："><a href="#2-3-配置文件加载顺序：" class="headerlink" title="2.3 配置文件加载顺序："></a>2.3 配置文件加载顺序：</h3><ol>
<li>当前jar包内部的<code>application.properties</code>和<code>application.yml</code>。</li>
<li>当前jar包内部的<code>application-&#123;profile&#125;.properties</code> 和 <code>application-&#123;profile&#125;.yml</code>。</li>
<li>引用的外部jar包的<code>application.properties</code>和<code>application.yml</code>。</li>
<li>引用的外部jar包的<code>application-&#123;profile&#125;.properties</code>和<code>application-&#123;profile&#125;.yml</code>。</li>
</ol>
<p><strong>:bulb:小結：</strong></p>
<p><strong>指定环境优先，外部优先，后面的可以覆盖前面的同名配置项。</strong></p>
<h2 id="3-自定义starter细节"><a href="#3-自定义starter细节" class="headerlink" title="3. 自定义starter细节"></a>3. 自定义starter细节</h2><h3 id="3-1-starter启动原理"><a href="#3-1-starter启动原理" class="headerlink" title="3.1 starter启动原理"></a>3.1 starter启动原理</h3><ul>
<li>starter的pom.xml引入autoconfigure依赖</li>
</ul>
<pre><code class="mermaid">graph LR
A[starter] --&gt;B[autoconfigure]
B --&gt; C[spring-boot-starter]
</code></pre>
<ul>
<li><p>autoconfigure包中配置使用**<font color=red>META-INF/spring.factories</font><strong>中</strong>EnableAutoConfiguration<strong>的值，使得</strong>项目启动加载指定的自动配置类**</p>
</li>
<li><p>编写自动配置类 <code>xxxAutoConfiguration</code> -&gt; <code>xxxxProperties</code></p>
<ul>
<li><p><code>@Configuration</code></p>
</li>
<li><p><code>@Conditional</code></p>
</li>
<li><p><code>@EnableConfigurationProperties</code></p>
</li>
<li><p><code>@Bean</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong><font color=red>引入starter</font></strong> — <code>xxxAutoConfiguration</code> — 容器中放入组件 —- <code>绑定xxxProperties</code> —- <strong><font color=red>配置项</font></strong></li>
</ul>
<h3 id="3-2-自定义starter"><a href="#3-2-自定义starter" class="headerlink" title="3.2 自定义starter"></a>3.2 自定义starter</h3><p><strong>atguigu-hello-spring-boot-starter（启动器）</strong></p>
<p><strong>atguigu-hello-spring-boot-starter-autoconfigure（自动配置包）</strong></p>
<ul>
<li><p>目标：创建<code>HelloService</code>的自定义starter。</p>
</li>
<li><p>创建两个工程，分别命名为<code>hello-spring-boot-starter</code>（普通Maven工程），<code>hello-spring-boot-starter-autoconfigure</code>（需用用到Spring Initializr创建的Maven工程）。</p>
</li>
<li><p><code>hello-spring-boot-starter</code>无需编写什么代码，只需让该工程引入<code>hello-spring-boot-starter-autoconfigure</code>依赖：</p>
</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.lun&lt;/groupId&gt;
    &lt;artifactId&gt;hello-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.lun&lt;/groupId&gt;
            &lt;artifactId&gt;hello-spring-boot-starter-autoconfigure&lt;/artifactId&gt;
            &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre>
<ul>
<li><code>hello-spring-boot-starter-autoconfigure</code>的pom.xml如下：</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.4.2&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.lun&lt;/groupId&gt;
    &lt;artifactId&gt;hello-spring-boot-starter-autoconfigure&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;hello-spring-boot-starter-autoconfigure&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<ul>
<li>创建4个文件：<ul>
<li><code>com/lun/hello/auto/HelloServiceAutoConfiguration</code></li>
<li><code>com/lun/hello/bean/HelloProperties</code></li>
<li><code>com/lun/hello/service/HelloService</code></li>
<li><code>src/main/resources/META-INF/spring.factories</code></li>
</ul>
</li>
</ul>
<pre><code class="java">import com.lun.hello.bean.HelloProperties;
import com.lun.hello.service.HelloService;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@ConditionalOnMissingBean(HelloService.class)
@EnableConfigurationProperties(HelloProperties.class)//默认HelloProperties放在容器中
public class HelloServiceAutoConfiguration &#123;

    @Bean
    public HelloService helloService()&#123;
        return new HelloService();
    &#125;

&#125;
</code></pre>
<pre><code class="java">import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(&quot;hello&quot;)
public class HelloProperties &#123;
    private String prefix;
    private String suffix;

    public String getPrefix() &#123;
        return prefix;
    &#125;

    public void setPrefix(String prefix) &#123;
        this.prefix = prefix;
    &#125;

    public String getSuffix() &#123;
        return suffix;
    &#125;

    public void setSuffix(String suffix) &#123;
        this.suffix = suffix;
    &#125;
&#125;
</code></pre>
<pre><code class="java">import com.lun.hello.bean.HelloProperties;
import org.springframework.beans.factory.annotation.Autowired;


/**
 * 默认不要放在容器中
 */
public class HelloService &#123;

    @Autowired
    private HelloProperties helloProperties;

    public String sayHello(String userName)&#123;
        return helloProperties.getPrefix() + &quot;: &quot; + userName + &quot; &gt; &quot; + helloProperties.getSuffix();
    &#125;
&#125;
</code></pre>
<pre><code class="properties"># Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.lun.hello.auto.HelloServiceAutoConfiguration
</code></pre>
<ul>
<li><p>用maven插件，将两工程install到maven本地倉庫。</p>
</li>
<li><p>接下来，测试使用自定义starter，用Spring Initializr创建名为<code>hello-spring-boot-starter-test</code>工程，引入<code>hello-spring-boot-starter</code>依赖，其pom.xml如下：</p>
</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.4.2&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.lun&lt;/groupId&gt;
    &lt;artifactId&gt;hello-spring-boot-starter-test&lt;/artifactId&gt;
    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;hello-spring-boot-starter-test&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!-- 引入`hello-spring-boot-starter`依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.lun&lt;/groupId&gt;
            &lt;artifactId&gt;hello-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<ul>
<li>添加配置文件<code>application.properties</code>：</li>
</ul>
<pre><code class="properties">hello.prefix=hello
hello.suffix=666
</code></pre>
<ul>
<li>添加单元测试类：</li>
</ul>
<pre><code class="java">import com.lun.hello.service.HelloService;//来自自定义starter
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class HelloSpringBootStarterTestApplicationTests &#123;

    @Autowired
    private HelloService helloService;

    @Test
    void contextLoads() &#123;
        // System.out.println(helloService.sayHello(&quot;lun&quot;));
        Assertions.assertEquals(&quot;hello: lun &gt; 666&quot;, helloService.sayHello(&quot;lun&quot;));
    &#125;

&#125;
</code></pre>
<h2 id="4-SpringBoot原理解析"><a href="#4-SpringBoot原理解析" class="headerlink" title="4. SpringBoot原理解析"></a>4. SpringBoot原理解析</h2><p>Spring原理【<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gW411W7wy?p=1">Spring注解</a>】、<strong>SpringMVC</strong>原理、<strong>自动配置原理</strong>、SpringBoot原理</p>
<h3 id="4-1-SpringBoot启动过程"><a href="#4-1-SpringBoot启动过程" class="headerlink" title="4.1 SpringBoot启动过程"></a>4.1 SpringBoot启动过程</h3><p><strong><span style="background-color:yellow;">黃底：組件</span></strong></p>
<p><span style="background-color:#99FFFF;">藍底：調用方法</span></p>
<ul>
<li><p>创建 <strong>SpringApplication</strong></p>
<ul>
<li>先保存一些信息。</li>
<li>判定当前应用的类型。使用ClassUtils來判定 –&gt; 目前是Servlet</li>
<li>**<font color=red>bootstrappers</font>**：初始启动引导器（List<Bootstrapper>）：去spring.factories文件中找 <strong>org.springframework.boot.Bootstrapper</strong></li>
<li>找 **<font color=red>ApplicationContextInitializer</font>**；去spring.factories找 <span style="background-color:yellow;"><strong>ApplicationContextInitializer</strong></span><ul>
<li>List&lt;ApplicationContextInitializer&lt;?&gt;&gt; <strong>initializers</strong></li>
</ul>
</li>
<li>找 <strong><font color=red>ApplicationListener</font>  ；应用监听器。</strong>去spring.factories找<span style="background-color:yellow;"> <strong>ApplicationListener</strong></span><ul>
<li>List&lt;ApplicationListener&lt;?&gt;&gt; <strong>listeners</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>运行 <strong>SpringApplication</strong></p>
<ul>
<li>新增一個<strong>StopWatch</strong></li>
<li>记录应用的启动时间</li>
<li>创建啟動引导器上下文（Context环境）：<strong>createBootstrapContext()</strong><ul>
<li><span style="background-color:#99FFFF;">获取到所有之前配置的 <strong><font color=red>bootstrappers 挨个执行</font></strong> intitialize() 来完成对引导启动器上下文环境设置</span></li>
</ul>
</li>
<li>让当前应用进入<strong>headless</strong>模式。<strong>java.awt.headless</strong></li>
<li>获取所有 **<font color=red>RunListener</font>**（运行监听器）【为了方便所有Listener进行事件感知】<ul>
<li>getSpringFactoriesInstances 去<strong>spring.factories</strong>找<span style="background-color:yellow;"><strong><font color=red>SpringApplicationRunListener</font></strong>. </span></li>
</ul>
</li>
<li>遍历 <strong><font color=red>SpringApplicationRunListener 调用 starting 方法；</font></strong><ul>
<li><strong><font color=red>相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。</font></strong></li>
</ul>
</li>
<li>保存命令行参数；ApplicationArguments</li>
<li>准备环境 prepareEnvironment（）;<ul>
<li>返回或者创建基础环境信息对象。<strong>StandardServletEnvironment</strong></li>
<li>配置环境信息对象。<ul>
<li>读取所有的配置源的配置属性值。</li>
</ul>
</li>
<li>绑定环境信息</li>
<li><span style="background-color:#99FFFF;">监听器调用 listener.environmentPrepared()；通知所有的监听器当前环境准备完成</span></li>
</ul>
</li>
<li>创建IOC容器（**<font color=red>createApplicationContext（）</font>**）<ul>
<li>根据项目类型（當前為Servlet）创建容器</li>
<li>当前会创建 <strong>AnnotationConfigServletWebServerApplicationContext</strong>這個容器</li>
</ul>
</li>
<li><strong>准备ApplicationContext IOC容器的基本信息</strong>  –&gt; 使用<strong>prepareContext()</strong><ul>
<li>保存环境信息</li>
<li>IOC容器的后置处理流程。</li>
<li>应用初始化器；applyInitializers；<ul>
<li><span style="background-color:#99FFFF;">遍历所有的 <strong><font color=red>ApplicationContextInitializer</font> 。调用</strong> <strong><font color=red>initialize</font></strong> 来对ioc容器<strong>进行初始化扩展功能</strong></span></li>
<li><span style="background-color:#99FFFF;">遍历所有的 listener 调用 <strong>contextPrepared。EventPublishRunListener；通知所有的监听器</strong>contextPrepared</span></li>
</ul>
</li>
<li><span style="background-color:#99FFFF;">所有的监听器 调用 <strong>contextLoaded</strong>方法。通知所有的监听器 <strong>contextLoaded</strong></span></li>
</ul>
</li>
<li><strong>刷新IOC容器。</strong>refreshContext<ul>
<li>创建容器中的所有组件（詳細內容參考<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gW411W7wy?p=1">Spring注解</a>）</li>
</ul>
</li>
<li>容器刷新完成后工作；afterRefresh</li>
<li><span style="background-color:#99FFFF;">所有监听器调用 listeners.<strong>started</strong>(context); <strong>通知所有的监听器</strong> <strong>started</strong></span></li>
<li>调用所有<strong>runners</strong>；callRunners()<ul>
<li>获取容器中的 <span style="background-color:yellow;"><strong>ApplicationRunner</strong> </span></li>
<li>获取容器中的 <span style="background-color:yellow;"> <strong>CommandLineRunner</strong></span></li>
<li>合并所有runner并且按照**@Order**进行排序</li>
<li><span style="background-color:#99FFFF;">遍历所有的runner。並调用 <strong>run 方法</strong></span></li>
</ul>
</li>
<li>如果以上有异常<ul>
<li><span style="background-color:#99FFFF;">调用Listener 的 <strong>failed</strong>方法</span></li>
</ul>
</li>
<li><span style="background-color:#99FFFF;">调用所有监听器的 <strong>running 方法</strong>  listeners.running(context) ； 通知所有的监听器 <strong>running</strong> </span></li>
<li><span style="background-color:#99FFFF;">running如果有问题。继续通知 failed 。调用所有 Listener 的<strong>failed</strong>；通知所有的监听器 <strong>failed</strong></span></li>
</ul>
</li>
</ul>
<ul>
<li>bootstrappers初啟動引導器接口</li>
</ul>
<pre><code class="java">public interface Bootstrapper &#123;

    /**
     * Initialize the given &#123;@link BootstrapRegistry&#125; with any required registrations.
     * @param registry the registry to initialize
     */
    void intitialize(BootstrapRegistry registry);

&#125;
</code></pre>
<ul>
<li>spring.factories內配置的ApplicationContextInitializer</li>
</ul>
 <img src=" 20230327_145203.jpg" alt="img" style="zoom:67%;border: 5px solid orange;" />



<ul>
<li>SpringApplicationRunListener 接口包含的方法</li>
</ul>
 <img src=" 20230327_145329.jpg" alt="img" style="zoom:80%;border: 4px solid orange;" />



<ul>
<li>目前所有的listeners</li>
</ul>
 <img src=" 20230327_151545.jpg" alt="img" style="zoom:80%;border: 4px solid orange;" />



<ul>
<li>ApplicationRunner接口</li>
</ul>
<pre><code class="java">@FunctionalInterface
public interface ApplicationRunner &#123;

    /**
     * Callback used to run the bean.
     * @param args incoming application arguments
     * @throws Exception on error
     */
    void run(ApplicationArguments args) throws Exception;

&#125;
</code></pre>
<ul>
<li>CommandLineRunner接口</li>
</ul>
<pre><code class="java">@FunctionalInterface
public interface CommandLineRunner &#123;

    /**
     * Callback used to run the bean.
     * @param args incoming main method arguments
     * @throws Exception on error
     */
    void run(String... args) throws Exception;

&#125;
</code></pre>
<p>:bulb:在SpringBoot啟動中，若想要自己定義一些東西來做事情，則可以自定義上面<span style="background-color:yellow;">黃色標註的組件</span></p>
<h2 id="5-自定義事件監聽組件"><a href="#5-自定義事件監聽組件" class="headerlink" title="5. 自定義事件監聽組件"></a>5. 自定義事件監聽組件</h2><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-application-events-and-listeners">官方文檔-Application Events and Listeners</a></p>
<p>根據原理解析，SpringBoot監聽組件共有下面五種：</p>
<ul>
<li><p>ApplicationContextInitializer</p>
</li>
<li><p>ApplicationListener</p>
</li>
<li><p>SpringApplicationRunListener</p>
</li>
<li><p>ApplicationRunner</p>
</li>
<li><p>CommandLineRunner</p>
</li>
</ul>
<ul>
<li>自定義MyApplicationContextInitializer</li>
</ul>
<pre><code class="java">import org.springframework.context.ApplicationContextInitializer;
import org.springframework.context.ConfigurableApplicationContext;

public class MyApplicationContextInitializer implements ApplicationContextInitializer &#123;
    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) &#123;
        System.out.println(&quot;MyApplicationContextInitializer ....initialize.... &quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li>自定義MyApplicationListener</li>
</ul>
<pre><code class="java">import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;

public class MyApplicationListener implements ApplicationListener &#123;
    @Override
    public void onApplicationEvent(ApplicationEvent event) &#123;
        System.out.println(&quot;MyApplicationListener.....onApplicationEvent...&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li>自定義MyApplicationRunner</li>
</ul>
<pre><code class="java">import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;


@Order(1)
@Component//放入容器
public class MyApplicationRunner implements ApplicationRunner &#123;
    @Override
    public void run(ApplicationArguments args) throws Exception &#123;
        System.out.println(&quot;MyApplicationRunner...run...&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li>自定義MyCommandLineRunner</li>
</ul>
<pre><code class="java">import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
/**
 * 应用启动做一个一次性事情
 */
@Order(2)
@Component//放入容器
public class MyCommandLineRunner implements CommandLineRunner &#123;
    @Override
    public void run(String... args) throws Exception &#123;
        System.out.println(&quot;MyCommandLineRunner....run....&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li>自定義MySpringApplicationRunListener</li>
</ul>
<pre><code class="java">import org.springframework.boot.ConfigurableBootstrapContext;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.SpringApplicationRunListener;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.core.env.ConfigurableEnvironment;

public class MySpringApplicationRunListener implements SpringApplicationRunListener &#123;

    private SpringApplication application;
    //MySpringApplicationRunListener的有參構造器，必須有，否則報錯
    public MySpringApplicationRunListener(SpringApplication application, String[] args)&#123;
        this.application = application;
    &#125;

    @Override
    public void starting(ConfigurableBootstrapContext bootstrapContext) &#123;
        System.out.println(&quot;MySpringApplicationRunListener....starting....&quot;);
    &#125;

    @Override
    public void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) &#123;
        System.out.println(&quot;MySpringApplicationRunListener....environmentPrepared....&quot;);
    &#125;

    @Override
    public void contextPrepared(ConfigurableApplicationContext context) &#123;
        System.out.println(&quot;MySpringApplicationRunListener....contextPrepared....&quot;);
    &#125;

    @Override
    public void contextLoaded(ConfigurableApplicationContext context) &#123;
        System.out.println(&quot;MySpringApplicationRunListener....contextLoaded....&quot;);
    &#125;

    @Override
    public void started(ConfigurableApplicationContext context) &#123;
        System.out.println(&quot;MySpringApplicationRunListener....started....&quot;);
    &#125;

    @Override
    public void running(ConfigurableApplicationContext context) &#123;
        System.out.println(&quot;MySpringApplicationRunListener....running....&quot;);
    &#125;

    @Override
    public void failed(ConfigurableApplicationContext context, Throwable exception) &#123;
        System.out.println(&quot;MySpringApplicationRunListener....failed....&quot;);
    &#125;
&#125;
</code></pre>
<p>:bulb: 注意！<code>MyApplicationContextInitializer</code>，<code>MyApplicationListener</code>，<code>MySpringApplicationRunListener</code>這三個組件必須由spring.factories中取得，要將這三個組件配置到spring.factories中，配置如下。</p>
<p><code>resources / META-INF / spring.factories</code>:</p>
<pre><code class="properties">org.springframework.context.ApplicationContextInitializer=\
  com.lun.boot.listener.MyApplicationContextInitializer

org.springframework.context.ApplicationListener=\
  com.lun.boot.listener.MyApplicationListener

org.springframework.boot.SpringApplicationRunListener=\
  com.lun.boot.listener.MySpringApplicationRunListener
</code></pre>
<h1 id="star-尚未學習"><a href="#star-尚未學習" class="headerlink" title=":star:尚未學習"></a>:star:尚未學習</h1><ul>
<li><p>Spring Boot 2 场景整合篇</p>
<ul>
<li>虚拟化技术</li>
<li>安全控制</li>
<li>缓存技术</li>
<li>消息中间件</li>
<li>对象存储</li>
<li>定时调度</li>
<li>异步任务</li>
<li>分布式系统</li>
</ul>
</li>
<li><p>Spring Boot 2 响应式编程</p>
<ul>
<li>响应式编程基础</li>
<li>Webflux开发Web应用</li>
<li>响应式访问持久化层</li>
<li>响应式安全开发</li>
<li>响应式原理</li>
</ul>
</li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 轉載請注明來源，歡迎對文章中的引用來源進行考證，歡迎指出任何有錯誤或不夠清晰的表達。可以郵件至 b8954008@gmail.com </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2023-2030 Eker
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
