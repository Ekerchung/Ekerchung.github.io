<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Redis筆記 | Myblog</title>
  <meta name="keywords" content=" Redis ">
  <meta name="description" content="Redis筆記 | Myblog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="[toc]  # :triangular_flag_on_post: Vue2 基础用法&amp;基础原理整理  1. vue基础知识和原理1.1 初识Vue 想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象 demo容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法 demo容器里的代码被称为【Vue模板】 Vue实例和容器是一一对应的 (一對一) 真实开发中只有一个Vue">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue筆記">
<meta property="og:url" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/index.html">
<meta property="og:site_name" content="Myblog">
<meta property="og:description" content="[toc]  # :triangular_flag_on_post: Vue2 基础用法&amp;基础原理整理  1. vue基础知识和原理1.1 初识Vue 想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象 demo容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法 demo容器里的代码被称为【Vue模板】 Vue实例和容器是一一对应的 (一對一) 真实开发中只有一个Vue">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406021433800.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406100449407.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406100457984.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406100502994.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406100510745.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406100518965.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406100523934.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406143257752.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406150617885.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174522418.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174528046.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174540863.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174554265.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174604757.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174612346.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174617528.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174622375.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174625934.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174631491.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230407001845676.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230407002120246.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230407002313091.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174638041.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174642987.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174651004.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174705811.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230407094611814.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174718099.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174725994.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174730443.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174738357.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230407170311153.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230407170432347.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174750773.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174801619.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174805333.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174818899.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174823548.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174826605.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230408085507192.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174839783.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174844341.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406192336061.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406192346078.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406192356666.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406192435392.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406192445359.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406192453125.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230410160646819.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406192546040.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406192554427.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230411105928919.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230411110153850.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406192602962.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230411145815136.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230412121515418.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230412133744204.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230412153158733.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230412163447075.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230412162027725.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230412163331723.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230412174210677.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230412174401366.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230412174600447.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230412174512398.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230412174832928.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230413155504419.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230413155440176.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230413155639608.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230413155245773.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230414002538901.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230414110943728.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230414144412156.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230414152551764.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230414152957919.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406192625977.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/af5f8d4493f3423087d6b9e6c5e60fa1tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/c57d4d695fe64014b78610ff2a5cd2b6tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230416103501730.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/115c5318692445e78577f8ef0eb22333.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230416115549018.png">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/f84e4e2c02424d9a99862ade0a2e4114tplv-k3u1fbpfcp-watermark.gif">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.gif">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/bc0be8211fc54b6c941c036791ba4efetplv-k3u1fbpfcp-watermark.gif">
<meta property="og:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/6cc55165c0e34069a75fe36f8712eb80tplv-k3u1fbpfcp-watermark.gif">
<meta property="article:published_time" content="2023-04-17T02:05:06.000Z">
<meta property="article:modified_time" content="2023-04-17T02:38:25.330Z">
<meta property="article:author" content="Eker的編程筆記">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ekerchung.github.io/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406021433800.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.4.2"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Eker的編程筆記</span>
</div>

<div class="icon">
    
        
    
        
            <a title="github"
               href="https://github.com/Ekerchung"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="linkedin"
               href="https://www.linkedin.com/in/yhc-b6a641155/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-linkedin"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:b8954008@gmail.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(16)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="自學筆記">
                        <i class="fold iconfont icon-right"></i>
                        
                        自學筆記
                        <small>(6)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="自學筆記<--->前端">
                                        
                                        前端
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="自學筆記<--->數據庫">
                                        
                                        數據庫
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="自學筆記<--->Spring">
                                        
                                        Spring
                                        
                                            <small>(4
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="前端">
                        <i class="fold iconfont icon-right"></i>
                        
                        前端
                        <small>(3)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="前端<--->Spring">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        Spring
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="前端<--->Spring踩坑">
                                                        
                                                        踩坑
                                                        
                                                            <small>(2)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="後端">
                        <i class="fold iconfont icon-right"></i>
                        
                        後端
                        <small>(5)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="後端<--->Spring">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        Spring
                                        
                                            <small>(5
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="後端<--->Spring踩坑">
                                                        
                                                        踩坑
                                                        
                                                            <small>(4)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="數據庫">
                        <i class="fold iconfont icon-right"></i>
                        
                        數據庫
                        <small>(1)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="數據庫<--->踩坑">
                                        
                                        踩坑
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="https://ekerchung.github.io/">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="16">
<input type="hidden" id="yelog_site_word_count" value="138.4k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>踩坑</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>axios</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>mybatis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Mybatis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MySql</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Redis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spring</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Spring</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SpringBoot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>springMVC</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Thymeleaf</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Vue</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All 自學筆記 前端 "
           href="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/"
           data-tag="Vue"
           data-author="" >
            <span class="post-title" title="Vue筆記">Vue筆記</span>
            <span class="post-date" title="2023-04-17 10:05:06">2023/04/17</span>
        </a>
        
        
        <a  class="All 自學筆記 數據庫 "
           href="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis筆記">Redis筆記</span>
            <span class="post-date" title="2023-04-10 11:00:16">2023/04/10</span>
        </a>
        
        
        <a  class="All 自學筆記 Spring "
           href="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/"
           data-tag="SpringBoot"
           data-author="" >
            <span class="post-title" title="SpringBoot筆記">SpringBoot筆記</span>
            <span class="post-date" title="2023-03-28 11:00:16">2023/03/28</span>
        </a>
        
        
        <a  class="All 後端 Spring 踩坑 "
           href="/2023/03/12/12_Mybatis-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%94%A2%E7%94%9FMapper.xml%E6%9C%89%E8%AA%A4/"
           data-tag="Spring,踩坑,Mybatis"
           data-author="" >
            <span class="post-title" title="Mybatis-逆向工程產生Mapper.xml有誤">Mybatis-逆向工程產生Mapper.xml有誤</span>
            <span class="post-date" title="2023-03-12 00:55:45">2023/03/12</span>
        </a>
        
        
        <a  class="All 後端 Spring 踩坑 "
           href="/2023/03/10/11_Thymeleaf%E6%B8%B2%E6%9F%93%E6%95%B8%E6%93%9A%E5%BA%AB%E5%85%A7%E4%BF%9D%E5%AD%98%E7%9A%84%E6%99%82%E9%96%93/"
           data-tag="Spring,踩坑,Thymeleaf"
           data-author="" >
            <span class="post-title" title="Thymeleaf-渲染數據庫內保存的時間">Thymeleaf-渲染數據庫內保存的時間</span>
            <span class="post-date" title="2023-03-10 22:42:14">2023/03/10</span>
        </a>
        
        
        <a  class="All 數據庫 踩坑 "
           href="/2023/03/10/10_MySql%E4%BF%9D%E5%AD%98%E6%99%82%E9%96%93%E6%99%82%E5%8D%80%E5%95%8F%E9%A1%8C/"
           data-tag="踩坑,MySql"
           data-author="" >
            <span class="post-title" title="MySql-保存時間時區問題">MySql-保存時間時區問題</span>
            <span class="post-date" title="2023-03-10 22:20:25">2023/03/10</span>
        </a>
        
        
        <a  class="All 前端 "
           href="/2023/03/07/09_Vue%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9F%E7%9A%84confirm%20dialog/"
           data-tag="Vue"
           data-author="" >
            <span class="post-title" title="Vue使用原生的confirm dialog">Vue使用原生的confirm dialog</span>
            <span class="post-date" title="2023-03-07 15:37:59">2023/03/07</span>
        </a>
        
        
        <a  class="All 前端 Spring 踩坑 "
           href="/2023/03/07/08_Vue%E5%AF%A6%E7%8F%BE%E4%BD%BF%E7%94%A8%E8%B6%85%E9%80%A3%E7%B5%90%E7%99%BC%E9%80%81delete%E8%AB%8B%E6%B1%82/"
           data-tag="Spring,踩坑,Vue"
           data-author="" >
            <span class="post-title" title="Vue實現使用超連結發送delete請求">Vue實現使用超連結發送delete請求</span>
            <span class="post-date" title="2023-03-07 14:39:23">2023/03/07</span>
        </a>
        
        
        <a  class="All 前端 Spring 踩坑 "
           href="/2023/03/05/07_Vue+axios%E5%AF%A6%E7%8F%BE%E7%95%B0%E6%AD%A5%E8%AB%8B%E6%B1%82%E9%A9%97%E8%AD%89%E8%A8%BB%E5%86%8A%E8%A1%A8%E5%96%AE/"
           data-tag="Spring,踩坑,Vue,axios"
           data-author="" >
            <span class="post-title" title="Vue+axios實現異步請求驗證註冊表單">Vue+axios實現異步請求驗證註冊表單</span>
            <span class="post-date" title="2023-03-05 23:05:46">2023/03/05</span>
        </a>
        
        
        <a  class="All 後端 Spring 踩坑 "
           href="/2023/02/26/06_Spring-MySQL%E9%85%8D%E7%BD%AE%E5%A0%B1%E9%8C%AF/"
           data-tag="Spring,踩坑"
           data-author="" >
            <span class="post-title" title="Spring-MySQL配置報錯">Spring-MySQL配置報錯</span>
            <span class="post-date" title="2023-02-26 23:49:18">2023/02/26</span>
        </a>
        
        
        <a  class="All 後端 Spring 踩坑 "
           href="/2023/02/25/05_Mybatis-%E6%8F%92%E4%BB%B6mybatis-generator%E4%B8%8D%E9%A1%AF%E7%A4%BA/"
           data-tag="mybatis,Spring,踩坑"
           data-author="" >
            <span class="post-title" title="Mybatis-插件mybatis-generator不顯示">Mybatis-插件mybatis-generator不顯示</span>
            <span class="post-date" title="2023-02-25 00:28:36">2023/02/25</span>
        </a>
        
        
        <a  class="All 後端 Spring "
           href="/2023/02/23/04_SSM-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%95%B4%E5%90%88/"
           data-tag="mybatis,spring,springMVC"
           data-author="" >
            <span class="post-title" title="SSM-配置文件整合">SSM-配置文件整合</span>
            <span class="post-date" title="2023-02-23 16:39:00">2023/02/23</span>
        </a>
        
        
        <a  class="All 自學筆記 Spring "
           href="/2023/02/23/03_Spring%E7%AD%86%E8%A8%98/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="Spring筆記">Spring筆記</span>
            <span class="post-date" title="2023-02-23 16:39:00">2023/02/23</span>
        </a>
        
        
        <a  class="All 自學筆記 Spring "
           href="/2023/02/23/02_SpringMVC%E7%AD%86%E8%A8%98/"
           data-tag="springMVC"
           data-author="" >
            <span class="post-title" title="SpringMVC筆記">SpringMVC筆記</span>
            <span class="post-date" title="2023-02-23 16:39:00">2023/02/23</span>
        </a>
        
        
        <a  class="All 自學筆記 Spring "
           href="/2023/02/23/01_Mybatis%E7%AD%86%E8%A8%98/"
           data-tag="mybatis"
           data-author="" >
            <span class="post-title" title="Mybatis筆記">Mybatis筆記</span>
            <span class="post-date" title="2023-02-23 16:39:00">2023/02/23</span>
        </a>
        
        
        <a  class="All "
           href="/2023/02/23/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2023-02-23 16:37:11">2023/02/23</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-14_Redis筆記" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Redis筆記</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="自學筆記">自學筆記</a> > 
            
            <a  data-rel="自學筆記&lt;---&gt;數據庫">數據庫</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color1">Redis</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2023-04-10 15:30:36'>2023-04-10 11:00</time>
        
    </div>
    <div class="article-meta">
        
        <span>Count:15.8k</span>
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81Redis%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8"><span class="toc-text">2、Redis安装和启动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B0%A1%E4%BB%8B"><span class="toc-text">3、NoSQL数据库簡介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%B4%B9"><span class="toc-text">4、Redis配置文件介紹</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Units"><span class="toc-text">4.1 Units</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-INCLUDES"><span class="toc-text">4.2 INCLUDES</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-NETWORK"><span class="toc-text">4.3 NETWORK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-GENERAL"><span class="toc-text">4.4 GENERAL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-SECURITY"><span class="toc-text">4.5 SECURITY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-LIMITS"><span class="toc-text">4.6 LIMITS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81Redis%E5%B8%B8%E7%94%A8%E4%BA%94%E5%A4%A7%E6%95%B8%E6%93%9A%E9%A1%9E%E5%9E%8B"><span class="toc-text">5、Redis常用五大數據類型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-key%E6%93%8D%E4%BD%9C"><span class="toc-text">5.1 key操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89"><span class="toc-text">5.2 字符串（String）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%88%97%E8%A1%A8%EF%BC%88List%EF%BC%89"><span class="toc-text">5.3 列表（List）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-text">5.4 Set（集合）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-Hash%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89"><span class="toc-text">5.5 Hash（哈希）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-Zset%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-text">5.6 Zset（有序集合）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81Redis6%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">6、Redis6新数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Bitmaps"><span class="toc-text">6.1 Bitmaps</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-Bitmaps-%E4%B8%8E-set-%E5%AF%B9%E6%AF%94"><span class="toc-text">6.1.1 Bitmaps 与 set 对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-HyperLogLog"><span class="toc-text">6.2 HyperLogLog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Geospatial"><span class="toc-text">6.3 Geospatial</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81Redis%E7%9A%84%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85"><span class="toc-text">7、Redis的发布与订阅</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-text">8、事务和锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-Multi%E3%80%81Exec%E3%80%81Discard"><span class="toc-text">8.1 Multi、Exec、Discard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">8.2 事务的错误处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E4%BA%8B%E5%8A%A1%E5%86%B2%E7%AA%81%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">8.3 事务冲突的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E6%88%90%E4%BA%8B%E5%8A%A1"><span class="toc-text">8.3.1 为什么要做成事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">1. 悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-text">2. 乐观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Watch%E3%80%81unwatch-%E5%AF%A6%E7%8F%BE%E6%A8%82%E8%A7%80%E9%8E%96"><span class="toc-text">3. Watch、unwatch 實現樂觀鎖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-%E4%BA%8B%E5%8A%A1%E4%B8%89%E7%89%B9%E6%80%A7"><span class="toc-text">8.3.2 事务三特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-Redis-%E4%BA%8B%E5%8A%A1%E7%A7%92%E6%9D%80%E6%A1%88%E4%BE%8B"><span class="toc-text">8.4 Redis_事务秒杀案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-1-%E8%A7%A3%E5%86%B3%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E4%BA%BA%E5%91%98%E8%AE%B0%E5%BD%95%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="toc-text">8.4.1 解决计数器和人员记录的事务操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-2-Redis-%E4%BA%8B%E5%8A%A1-%E2%80%94-%E7%A7%92%E6%9D%80%E5%B9%B6%E5%8F%91%E6%A8%A1%E6%8B%9F"><span class="toc-text">8.4.2 Redis 事务 — 秒杀并发模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-3-%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-text">8.4.3 超卖问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-4-%E7%BB%A7%E7%BB%AD%E5%A2%9E%E5%8A%A0%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95"><span class="toc-text">8.4.4 继续增加并发测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-5-%E8%A7%A3%E5%86%B3%E5%BA%93%E5%AD%98%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98"><span class="toc-text">8.4.5 解决库存遗留问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">9、持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-RDB"><span class="toc-text">9.1 RDB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-1-Fork"><span class="toc-text">9.1.1 Fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-2-%E9%85%8D%E7%BD%AE"><span class="toc-text">9.1.2 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-3-%E4%BC%98%E7%82%B9"><span class="toc-text">9.1.3 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-4-%E7%BC%BA%E7%82%B9"><span class="toc-text">9.1.4 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-AOF"><span class="toc-text">9.2 AOF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-%E9%85%8D%E7%BD%AE"><span class="toc-text">9.2.1 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2%E4%BC%98%E7%82%B9"><span class="toc-text">9.2.2优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-3-%E7%BC%BA%E7%82%B9"><span class="toc-text">9.2.3 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E9%80%89%E6%8B%A9"><span class="toc-text">9.3 选择</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">10、主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%BB%E4%B8%A4%E4%BB%8E"><span class="toc-text">10.1 搭建一主两从</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E"><span class="toc-text">10.2 一主二从</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="toc-text">10.3 薪火相传</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB"><span class="toc-text">10.4 反客为主</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">10.5 哨兵模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-1-%E9%80%89%E4%B8%BE%E8%A7%84%E5%88%99"><span class="toc-text">10.5.1 选举规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-2-%E5%A4%8D%E5%88%B6%E5%BB%B6%E6%97%B6%E5%95%8F%E9%A1%8C"><span class="toc-text">10.5.2 复制延时問題</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text">10.6 复制原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E3%80%81%E9%9B%86%E7%BE%A4"><span class="toc-text">11、集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E6%90%AD%E5%BB%BA-Redis-%E9%9B%86%E7%BE%A4"><span class="toc-text">11.1 搭建 Redis 集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E9%9B%86%E7%BE%A4%E5%B8%B8%E8%A6%8B%E9%97%AE%E9%A2%98"><span class="toc-text">11.2 集群常見问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-1-redis-cluster-%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E8%BF%99%E5%85%AD%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text">11.2.1 redis cluster 如何分配这六个节点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-2-%E4%BB%80%E4%B9%88%E6%98%AF-slots%EF%BC%9F"><span class="toc-text">11.2.2 什么是 slots？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-3-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%9B%86%E7%BE%A4%E4%B8%AD%E5%AD%98%E5%85%A5%E5%80%BC%EF%BC%9F"><span class="toc-text">11.2.3 如何在集群中存入值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-4-%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E5%80%BC%EF%BC%9F"><span class="toc-text">11.2.4 如何查询集群中的值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-5-%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D%EF%BC%9F"><span class="toc-text">11.2.5 故障恢复？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E4%BC%98%E7%82%B9"><span class="toc-text">11.3 优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-%E7%BC%BA%E7%82%B9"><span class="toc-text">11.4 缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E3%80%81Jedis%E6%93%8D%E4%BD%9CRedis"><span class="toc-text">12、Jedis操作Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-Jedis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">12.1 Jedis 主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E9%9B%86%E7%BE%A4%E7%9A%84-Jedis-%E5%BC%80%E5%8F%91"><span class="toc-text">12.2 集群的 Jedis 开发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13%E3%80%81SpringBoot%E6%95%B4%E5%90%88Redis"><span class="toc-text">13、SpringBoot整合Redis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14%E3%80%81%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-text">14、应用问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">14.1 缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-1-%E7%8E%B0%E8%B1%A1"><span class="toc-text">14.1.1 现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-2-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">14.1.2 如何解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-text">14.2 缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-1-%E7%8E%B0%E8%B1%A1"><span class="toc-text">14.2.1 现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-2-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">14.2.2 如何解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-text">14.3 缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-1-%E7%8E%B0%E8%B1%A1"><span class="toc-text">14.3.1 现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-2-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">14.3.2 如何解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-4-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">14.4 分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-text">14.4.1 问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E4%BD%BF%E7%94%A8-redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">14.4.2 解决方案：使用 redis 实现分布式锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#set-sku-1-info-%E2%80%9COK%E2%80%9D-NX-PX-10000"><span class="toc-text">set sku:1:info “OK” NX PX 10000</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-2-1-%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81"><span class="toc-text">14.4.2.1 编写代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-2-2-%E4%BC%98%E5%8C%96%E4%B9%8B%E8%AE%BE%E7%BD%AE%E9%94%81%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-text">14.4.2.2 优化之设置锁的过期时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-2-3-%E4%BC%98%E5%8C%96%E4%B9%8B-UUID-%E9%98%B2%E8%AF%AF%E5%88%A0"><span class="toc-text">14.4.2.3 优化之 UUID 防误删</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-2-4-%E4%BC%98%E5%8C%96%E4%B9%8BLUA%E8%84%9A%E6%9C%AC%E4%BF%9D%E8%AF%81%E5%88%A0%E9%99%A4%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">14.4.2.4 优化之LUA脚本保证删除的原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-2-5-%E6%80%BB%E7%BB%93"><span class="toc-text">14.4.2.5 总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-Redis6-0-%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-text">15 Redis6.0 新功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-ACL"><span class="toc-text">15.1 ACL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">15.1.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-2-%E5%91%BD%E4%BB%A4"><span class="toc-text">15.1.2 命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-IO-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">15.2 IO 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-2-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">15.2.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-2-2-%E5%8E%9F%E7%90%86%E6%9E%B6%E6%9E%84"><span class="toc-text">15.2.2 原理架构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-%E5%B7%A5%E5%85%B7%E6%94%AF%E6%8C%81-Cluster"><span class="toc-text">15.3 工具支持 Cluster</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-Redis-%E6%96%B0%E5%8A%9F%E8%83%BD%E6%8C%81%E7%BB%AD%E5%85%B3%E6%B3%A8"><span class="toc-text">15.4 Redis 新功能持续关注</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81Redis%E5%AE%89%E8%A3%85%E5%92%8C%E5%90%AF%E5%8A%A8"><span class="toc-text">2、Redis安装和启动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B0%A1%E4%BB%8B"><span class="toc-text">3、NoSQL数据库簡介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%B4%B9"><span class="toc-text">4、Redis配置文件介紹</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Units"><span class="toc-text">4.1 Units</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-INCLUDES"><span class="toc-text">4.2 INCLUDES</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-NETWORK"><span class="toc-text">4.3 NETWORK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-GENERAL"><span class="toc-text">4.4 GENERAL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-SECURITY"><span class="toc-text">4.5 SECURITY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-LIMITS"><span class="toc-text">4.6 LIMITS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81Redis%E5%B8%B8%E7%94%A8%E4%BA%94%E5%A4%A7%E6%95%B8%E6%93%9A%E9%A1%9E%E5%9E%8B"><span class="toc-text">5、Redis常用五大數據類型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-key%E6%93%8D%E4%BD%9C"><span class="toc-text">5.1 key操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89"><span class="toc-text">5.2 字符串（String）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%88%97%E8%A1%A8%EF%BC%88List%EF%BC%89"><span class="toc-text">5.3 列表（List）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-text">5.4 Set（集合）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-Hash%EF%BC%88%E5%93%88%E5%B8%8C%EF%BC%89"><span class="toc-text">5.5 Hash（哈希）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-Zset%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-text">5.6 Zset（有序集合）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81Redis6%E6%96%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">6、Redis6新数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Bitmaps"><span class="toc-text">6.1 Bitmaps</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-Bitmaps-%E4%B8%8E-set-%E5%AF%B9%E6%AF%94"><span class="toc-text">6.1.1 Bitmaps 与 set 对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-HyperLogLog"><span class="toc-text">6.2 HyperLogLog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Geospatial"><span class="toc-text">6.3 Geospatial</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81Redis%E7%9A%84%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85"><span class="toc-text">7、Redis的发布与订阅</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-text">8、事务和锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-Multi%E3%80%81Exec%E3%80%81Discard"><span class="toc-text">8.1 Multi、Exec、Discard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">8.2 事务的错误处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E4%BA%8B%E5%8A%A1%E5%86%B2%E7%AA%81%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">8.3 事务冲突的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E6%88%90%E4%BA%8B%E5%8A%A1"><span class="toc-text">8.3.1 为什么要做成事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-text">1. 悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-text">2. 乐观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Watch%E3%80%81unwatch-%E5%AF%A6%E7%8F%BE%E6%A8%82%E8%A7%80%E9%8E%96"><span class="toc-text">3. Watch、unwatch 實現樂觀鎖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-%E4%BA%8B%E5%8A%A1%E4%B8%89%E7%89%B9%E6%80%A7"><span class="toc-text">8.3.2 事务三特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-Redis-%E4%BA%8B%E5%8A%A1%E7%A7%92%E6%9D%80%E6%A1%88%E4%BE%8B"><span class="toc-text">8.4 Redis_事务秒杀案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-1-%E8%A7%A3%E5%86%B3%E8%AE%A1%E6%95%B0%E5%99%A8%E5%92%8C%E4%BA%BA%E5%91%98%E8%AE%B0%E5%BD%95%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C"><span class="toc-text">8.4.1 解决计数器和人员记录的事务操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-2-Redis-%E4%BA%8B%E5%8A%A1-%E2%80%94-%E7%A7%92%E6%9D%80%E5%B9%B6%E5%8F%91%E6%A8%A1%E6%8B%9F"><span class="toc-text">8.4.2 Redis 事务 — 秒杀并发模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-3-%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-text">8.4.3 超卖问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-4-%E7%BB%A7%E7%BB%AD%E5%A2%9E%E5%8A%A0%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95"><span class="toc-text">8.4.4 继续增加并发测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-5-%E8%A7%A3%E5%86%B3%E5%BA%93%E5%AD%98%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98"><span class="toc-text">8.4.5 解决库存遗留问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">9、持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-RDB"><span class="toc-text">9.1 RDB</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-1-Fork"><span class="toc-text">9.1.1 Fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-2-%E9%85%8D%E7%BD%AE"><span class="toc-text">9.1.2 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-3-%E4%BC%98%E7%82%B9"><span class="toc-text">9.1.3 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-4-%E7%BC%BA%E7%82%B9"><span class="toc-text">9.1.4 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-AOF"><span class="toc-text">9.2 AOF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-%E9%85%8D%E7%BD%AE"><span class="toc-text">9.2.1 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2%E4%BC%98%E7%82%B9"><span class="toc-text">9.2.2优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-3-%E7%BC%BA%E7%82%B9"><span class="toc-text">9.2.3 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E9%80%89%E6%8B%A9"><span class="toc-text">9.3 选择</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">10、主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%BB%E4%B8%A4%E4%BB%8E"><span class="toc-text">10.1 搭建一主两从</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%8E"><span class="toc-text">10.2 一主二从</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="toc-text">10.3 薪火相传</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB"><span class="toc-text">10.4 反客为主</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">10.5 哨兵模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-1-%E9%80%89%E4%B8%BE%E8%A7%84%E5%88%99"><span class="toc-text">10.5.1 选举规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-2-%E5%A4%8D%E5%88%B6%E5%BB%B6%E6%97%B6%E5%95%8F%E9%A1%8C"><span class="toc-text">10.5.2 复制延时問題</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text">10.6 复制原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E3%80%81%E9%9B%86%E7%BE%A4"><span class="toc-text">11、集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E6%90%AD%E5%BB%BA-Redis-%E9%9B%86%E7%BE%A4"><span class="toc-text">11.1 搭建 Redis 集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E9%9B%86%E7%BE%A4%E5%B8%B8%E8%A6%8B%E9%97%AE%E9%A2%98"><span class="toc-text">11.2 集群常見问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-1-redis-cluster-%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E8%BF%99%E5%85%AD%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text">11.2.1 redis cluster 如何分配这六个节点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-2-%E4%BB%80%E4%B9%88%E6%98%AF-slots%EF%BC%9F"><span class="toc-text">11.2.2 什么是 slots？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-3-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%9B%86%E7%BE%A4%E4%B8%AD%E5%AD%98%E5%85%A5%E5%80%BC%EF%BC%9F"><span class="toc-text">11.2.3 如何在集群中存入值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-4-%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E5%80%BC%EF%BC%9F"><span class="toc-text">11.2.4 如何查询集群中的值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-5-%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D%EF%BC%9F"><span class="toc-text">11.2.5 故障恢复？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E4%BC%98%E7%82%B9"><span class="toc-text">11.3 优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-4-%E7%BC%BA%E7%82%B9"><span class="toc-text">11.4 缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E3%80%81Jedis%E6%93%8D%E4%BD%9CRedis"><span class="toc-text">12、Jedis操作Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-Jedis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">12.1 Jedis 主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E9%9B%86%E7%BE%A4%E7%9A%84-Jedis-%E5%BC%80%E5%8F%91"><span class="toc-text">12.2 集群的 Jedis 开发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13%E3%80%81SpringBoot%E6%95%B4%E5%90%88Redis"><span class="toc-text">13、SpringBoot整合Redis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14%E3%80%81%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-text">14、应用问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">14.1 缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-1-%E7%8E%B0%E8%B1%A1"><span class="toc-text">14.1.1 现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-2-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">14.1.2 如何解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-text">14.2 缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-1-%E7%8E%B0%E8%B1%A1"><span class="toc-text">14.2.1 现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-2-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">14.2.2 如何解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-text">14.3 缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-1-%E7%8E%B0%E8%B1%A1"><span class="toc-text">14.3.1 现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-2-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-text">14.3.2 如何解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-4-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">14.4 分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-text">14.4.1 问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E4%BD%BF%E7%94%A8-redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">14.4.2 解决方案：使用 redis 实现分布式锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#set-sku-1-info-%E2%80%9COK%E2%80%9D-NX-PX-10000"><span class="toc-text">set sku:1:info “OK” NX PX 10000</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-2-1-%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81"><span class="toc-text">14.4.2.1 编写代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-2-2-%E4%BC%98%E5%8C%96%E4%B9%8B%E8%AE%BE%E7%BD%AE%E9%94%81%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-text">14.4.2.2 优化之设置锁的过期时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-2-3-%E4%BC%98%E5%8C%96%E4%B9%8B-UUID-%E9%98%B2%E8%AF%AF%E5%88%A0"><span class="toc-text">14.4.2.3 优化之 UUID 防误删</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-2-4-%E4%BC%98%E5%8C%96%E4%B9%8BLUA%E8%84%9A%E6%9C%AC%E4%BF%9D%E8%AF%81%E5%88%A0%E9%99%A4%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">14.4.2.4 优化之LUA脚本保证删除的原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-2-5-%E6%80%BB%E7%BB%93"><span class="toc-text">14.4.2.5 总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-Redis6-0-%E6%96%B0%E5%8A%9F%E8%83%BD"><span class="toc-text">15 Redis6.0 新功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-ACL"><span class="toc-text">15.1 ACL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">15.1.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-2-%E5%91%BD%E4%BB%A4"><span class="toc-text">15.1.2 命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-IO-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">15.2 IO 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-2-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">15.2.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-2-2-%E5%8E%9F%E7%90%86%E6%9E%B6%E6%9E%84"><span class="toc-text">15.2.2 原理架构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-%E5%B7%A5%E5%85%B7%E6%94%AF%E6%8C%81-Cluster"><span class="toc-text">15.3 工具支持 Cluster</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-Redis-%E6%96%B0%E5%8A%9F%E8%83%BD%E6%8C%81%E7%BB%AD%E5%85%B3%E6%B3%A8"><span class="toc-text">15.4 Redis 新功能持续关注</span></a></li></ol></li></ol></li></ol></div></p>
<hr></hr>
# 1、Redis概述

<p><em><strong>Redis</strong></em> 是典型的 <em><strong>NoSQL</strong></em> 数据库。</p>
<p><em><strong>redis官网</strong></em>：<a target="_blank" rel="noopener" href="https://redis.io/download">https://redis.io/download</a></p>
<blockquote>
<p><em><strong>Redis</strong></em> 是一个开源的 <em><strong>key-value</strong></em> 存储系统。</p>
<p>和 <em><strong>Memcached</strong></em> 类似，它支持存储的 <em><strong>value</strong></em> 类型相对更多，包括 <em><strong>string、list、set、zset、sorted set、hash</strong></em>。</p>
<p>这些数据类型都支持 <em><strong>push/pop、add/remove</strong></em> 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p>
<p>在此基础上，<em><strong>Redis</strong></em> 支持各种不同方式的排序。</p>
<p>与 <em><strong>memcached</strong></em>一样，为了保证效率，数据都是缓存在内存中。</p>
<p>区别的是 <em><strong>Redis</strong></em> 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</p>
<p>并且在此基础上实现了<em><strong>master-slave</strong></em> （主从）同步。</p>
<p>单线程 + <em><strong>IO</strong></em> 多路复用。</p>
</blockquote>
<h1 id="2、Redis安装和启动"><a href="#2、Redis安装和启动" class="headerlink" title="2、Redis安装和启动"></a>2、Redis安装和启动</h1><p>Reids一般是安裝在linux環境下使用，我們可以使用下面幾種方式使用：</p>
<ul>
<li>購買雲端服務器：阿里雲、騰訊雲、華為雲…等等。自帶CentoOs、Ubuntu環境，直接使用</li>
<li>VMWare本地虛擬機</li>
<li>Docker</li>
</ul>
<p>这里以VMWare為例：</p>
<blockquote>
<p>首先判断我们的centos 7是多少位的，使用64位切记</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getconf LONG_BIT            返回是多少就是几位</span><br></pre></td></tr></table></figure>

<p>Linux安装Redis必须先具备gcc编译环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -v                  查看版本</span><br><span class="line">yum -y install gcc-c++          安装gcc and c++库环境</span><br></pre></td></tr></table></figure>

<p>下载redis7.0.9.tar.gz后放入Linux目录/opt</p>
<p>解压至当前目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-6.2.6.tar.gz </span><br></pre></td></tr></table></figure>

<p>解压完成后进入目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-6.2.6</span><br></pre></td></tr></table></figure>

<p>在当前目录下执行 <em><strong>make</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>默认安装在 <code>/usr/local/bin</code></p>
<img src="  image-20230330143224012.png" alt="image-20230330143224012" style="zoom:67%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark：性能测试工具，可以在自己本子运行，看看自己本子性能如何</span><br><span class="line">redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲</span><br><span class="line">redis-check-dump：修复有问题的dump.rdb文件</span><br><span class="line">redis-sentinel：Redis集群使用</span><br><span class="line">redis-server：Redis服务器启动命令</span><br><span class="line">redis-cli：客户端，操作入口</span><br></pre></td></tr></table></figure>



<p>前台启动<font color=red>【不推薦】</font>：***/usr/local/bin*** 目录下启动 <em><strong>redis</strong></em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server(前台启动)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>啟動的窗口不能關閉，否則redis會關掉</p>
</blockquote>
<p>后台启动<font color=red>【推薦】</font>：</p>
<ul>
<li><p>安装 <em><strong>redis</strong></em> 的目录 <em><strong>/opt/redis-6.2.6</strong></em> 中将 <em><strong>redis.conf</strong></em> 复制到etc文件夹下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf /etc/redis.conf</span><br><span class="line">// 将redis.conf复制到/etc/下</span><br></pre></td></tr></table></figure></li>
<li><p>修改 <em><strong>/etc/redis.conf</strong></em> 配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#redis.conf配置文件，改完后确保生效，记得重启，记得重启</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#- 默认daemonize no 改为 daemonize yes</span></span><br><span class="line"><span class="comment">#- 默认protected-mode yes 改为 protected-mode no (其他人可以連接)</span></span><br><span class="line"><span class="comment">#- 默认bind 127.0.0.1 改为 直接注释掉(默认bind 127.0.0.1只能本机访问)或改成本机IP地址，否则影响远程IP连接</span></span><br><span class="line"><span class="comment">#- 添加redis密码 改为 requirepass 你自己设置的密码 (可不用)</span></span><br></pre></td></tr></table></figure>

<img src="  image-20230330143241387.png" alt="image-20230330143241387" style="zoom:67%;" /></li>
<li><p><em><strong>/usr/local/bin</strong></em> 目录下启动 <em><strong>redis</strong></em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>執行後不會有反饋，但可通過<code>ps -ef | grep redis</code>指令查詢進程狀況</p>
</blockquote>
<p>关闭 <em><strong>redis</strong></em></p>
<ul>
<li><em><strong>kill</strong></em> 进程</li>
<li>命令 <em><strong>shutdown</strong></em></li>
</ul>
</blockquote>
<p><u><strong>默认端口号：6379</strong></u></p>
<h1 id="3、NoSQL数据库簡介"><a href="#3、NoSQL数据库簡介" class="headerlink" title="3、NoSQL数据库簡介"></a>3、NoSQL数据库簡介</h1><ul>
<li><p>解决 <em><strong>CPU</strong></em> 及内存压力</p>
<img src="  image-20230330143300959.png" alt="image-20230330143300959" style="zoom: 50%;" /></li>
<li><p>解决 <em><strong>IO</strong></em> 压力</p>
<img src="  image-20230330143314385.png" alt="image-20230330143314385" style="zoom:50%;" /></li>
</ul>
<p><em><strong>NoSQL（ NoSQL = Not Only SQL ）</strong></em>，意即不仅仅是 <em><strong>SQL</strong></em>，泛指非关系型的数据库。</p>
<p><em><strong>NoSQL</strong></em> 不依赖业务逻辑方式存储，而以简单的 <em><strong>key-value</strong></em> 模式存储。因此大大的增加了数据库的扩展能力。</p>
<ul>
<li>不遵循 <em><strong>SQL</strong></em> 标准。</li>
<li>不支持 <em><strong>ACID</strong></em>。</li>
<li>远超于 <em><strong>SQL</strong></em> 的性能。</li>
</ul>
<p><strong>适用于的场景</strong></p>
<ul>
<li>对数据高并发的读写；</li>
<li>海量数据的读写；</li>
<li>对数据高可扩展性的。</li>
</ul>
<p><strong>不适用的场景</strong></p>
<ul>
<li>需要事务支持；</li>
<li>基于 <em><strong>sql</strong></em> 的结构化查询存储，处理复杂的关系，需要即席查询。</li>
</ul>
<p>常见的 <em><strong>NoSQL</strong></em> 数据库</p>
<ul>
<li>Redis</li>
<li>MongoDB</li>
</ul>
<p>大数据时代常用的数据库类型</p>
<ul>
<li><p>行式数据库</p>
<img src="  image-20230330143325255.png" alt="image-20230330143325255" style="zoom:50%;" /></li>
<li><p>列式数据库</p>
<img src="  image-20230330143514854.png" alt="image-20230330143514854" style="zoom:50%;" /></li>
</ul>
<h1 id="4、Redis配置文件介紹"><a href="#4、Redis配置文件介紹" class="headerlink" title="4、Redis配置文件介紹"></a>4、Redis配置文件介紹</h1><p><em><strong>redis.conf</strong></em></p>
<h2 id="4-1-Units"><a href="#4-1-Units" class="headerlink" title="4.1 Units"></a>4.1 <em><strong>Units</strong></em></h2><blockquote>
<p>单位，配置大小单位，开头定义了一些基本的度量单位，只支持 <em><strong>bytes</strong></em>，不支持 <em><strong>bit</strong></em>。</p>
<p>大小写不敏感。</p>
</blockquote>
<img src="  image-20230330143520951.png" alt="image-20230330143520951" style="zoom:50%;" />



<h2 id="4-2-INCLUDES"><a href="#4-2-INCLUDES" class="headerlink" title="4.2 INCLUDES"></a>4.2 <em><strong>INCLUDES</strong></em></h2><blockquote>
<p>包含，多实例的情况可以把公用的配置文件提取出来。</p>
</blockquote>
<img src="  image-20230330143527236.png" alt="image-20230330143527236" style="zoom:50%;" />



<h2 id="4-3-NETWORK"><a href="#4-3-NETWORK" class="headerlink" title="4.3 NETWORK"></a>4.3 <em><strong>NETWORK</strong></em></h2><blockquote>
<p>网络相关配置。</p>
<p><em><strong>bind</strong></em></p>
<p>默认情况 <code>bind=127.0.0.1</code> 只能接受本机的访问请求。</p>
<p>不写的情况下，无限制接受任何 <em><strong>ip</strong></em> 地址的访问。</p>
<p>生产环境肯定要写你应用服务器的地址，服务器是需要远程访问的，*<u>所以需要将其注释掉</u>*。</p>
<p>如果开启了<em><strong>protected-mode</strong></em>，那么在没有设定 <em><strong>bind ip</strong></em> 且没有设密码的情况下，<em><strong>Redis</strong></em> 只允许接受本机的响应。</p>
<img src="  image-20230330143608162.png" alt="image-20230330143608162" style="zoom:50%;" />



<p><em><strong>protected-mode</strong></em></p>
<p>将本机访问保护模式设置 <em><strong>no</strong></em>。</p>
<img src="  image-20230330143613906.png" alt="image-20230330143613906" style="zoom:50%;" />



<p><em><strong>port</strong></em></p>
<p>端口号，默认 <em><strong>6379</strong></em>。</p>
<img src="  image-20230330143619446.png" alt="image-20230330143619446" style="zoom:50%;" />



<p><em><strong>tcp-backlog</strong></em></p>
<p>设置 <em><strong>tcp</strong></em> 的 <em><strong>backlog</strong></em>，<em><strong>backlog</strong></em> 其实是一个连接队列，<em><strong>backlog</strong></em> 队列总和 $=$ 未完成三次握手队列 $+$ 已经完成三次握手队列。</p>
<p>在高并发环境下你需要一个高 <em><strong>backlog</strong></em> 值来避免慢客户端连接问题。</p>
<img src="  image-20230330143625289.png" alt="image-20230330143625289" style="zoom:50%;" />



<p><em><strong>timeout</strong></em></p>
<p>一个空闲的客户端维持多少秒会关闭，0 表示关闭该功能。即永不关闭。</p>
<img src="  image-20230330143633223.png" alt="image-20230330143633223" style="zoom:50%;" />



<p><em><strong>tcp-keepalive</strong></em></p>
<p>对访问客户端的一种心跳检测，每个 <em><strong>n</strong></em> 秒检测一次。</p>
<p>单位为秒，如果设置为 0，则不会进行 <em><strong>Keepalive</strong></em> 检测，建议设置成 60。</p>
<img src="  image-20230330143639945.png" alt="image-20230330143639945" style="zoom:50%;" />
</blockquote>
<h2 id="4-4-GENERAL"><a href="#4-4-GENERAL" class="headerlink" title="4.4 GENERAL"></a>4.4 <em><strong>GENERAL</strong></em></h2><blockquote>
<p>通用。</p>
<p><em><strong>daemonize</strong></em></p>
<p>是否为后台进程，设置为 <em><strong>yes</strong></em>。</p>
<p>守护进程，后台启动。</p>
<img src="  image-20230330143652233.png" alt="image-20230330143652233" style="zoom:50%;" />



<p><em><strong>pidfile</strong></em></p>
<p>存放 <em><strong>pid</strong></em> 文件的位置，每个实例会产生一个不同的 <em><strong>pid</strong></em> 文件。</p>
<img src="  image-20230330143657741.png" alt="image-20230330143657741" style="zoom:50%;" />



<p><em><strong>loglevel</strong></em></p>
<p>指定日志记录级别，<em><strong>Redis</strong></em> 总共支持四个级别：<em><strong>debug、verbose、notice、warning</strong></em>，默认为 <em><strong>notice</strong></em>。</p>
<img src="  image-20230330143710179.png" alt="image-20230330143710179" style="zoom:50%;" />



<p><em><strong>logfile</strong></em></p>
<p>日志文件名称。</p>
<img src="  image-20230330143718428.png" alt="image-20230330143718428" style="zoom:50%;" />



<p><em><strong>database</strong></em></p>
<p>设定库的数量 默认16，默认数据库为 0，可以使用 <code>SELECT &lt;dbid&gt;</code> 命令在连接上指定数据库 <em><strong>id</strong></em>。</p>
<img src="  image-20230330143724347.png" alt="image-20230330143724347" style="zoom:50%;" />
</blockquote>
<h2 id="4-5-SECURITY"><a href="#4-5-SECURITY" class="headerlink" title="4.5 SECURITY"></a>4.5 <em><strong>SECURITY</strong></em></h2><blockquote>
<p>安全。</p>
<p>访问密码的查看、设置和取消。</p>
<p>在命令中设置密码，只是临时的。重启 <em><strong>redis</strong></em> 服务器，密码就还原了。</p>
<p>永久设置，需要在配置文件中进行设置。</p>
</blockquote>
<h2 id="4-6-LIMITS"><a href="#4-6-LIMITS" class="headerlink" title="4.6 LIMITS"></a>4.6 <em><strong>LIMITS</strong></em></h2><blockquote>
<p>限制。</p>
<p><em><strong>maxclients</strong></em></p>
<p>设置 <em><strong>redis</strong></em> 同时可以与多少个客户端进行连接。</p>
<p>默认情况下为 <em><strong>10000</strong></em> 个客户端。</p>
<p>如果达到了此限制，<em><strong>redis</strong></em> 则会拒绝新的连接请求，并且向这些连接请求方发出 <em><strong>max number of clients reached</strong></em> 以作回应。</p>
<img src="  image-20230330143739351.png" alt="image-20230330143739351" style="zoom:50%;" />

<p><em><strong>maxmemory</strong></em></p>
<p>建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机。</p>
<p>设置 <em><strong>redis</strong></em> 可以使用的内存量。一旦到达内存使用上限，<em><strong>redis</strong></em> 将会试图移除内部数据，移除规则可以通过 <em><strong>maxmemory-policy</strong></em> 来指定。</p>
<p>如果 <em><strong>redis</strong></em> 无法根据移除规则来移除内存中的数据，或者设置了不允许移除，那么 <em><strong>redis</strong></em> 则会针对那些需要申请内存的指令返回错误信息，比如 <em><strong>SET、LPUSH</strong></em> 等。</p>
<p>但是对于无内存申请的指令，仍然会正常响应，比如 <em><strong>GET</strong></em> 等。如果你的 <em><strong>redis</strong></em> 是主 <em><strong>redis</strong></em>（ 说明你的 <em><strong>redis</strong></em> 有从 <em><strong>redis</strong></em> ），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p>
<img src="  image-20230330143757340.png" alt="image-20230330143757340" style="zoom:50%;" />



<p><em><strong>maxmemory-policy</strong></em></p>
<p><em><strong>volatile-lru</strong></em>：使用 <em><strong>LRU</strong></em> 算法移除 <em><strong>key</strong></em>，只对设置了过期时间的键（最近最少使用）。</p>
<p><em><strong>allkeys-lru</strong></em>：在所有集合 <em><strong>key</strong></em> 中，使用 <em><strong>LRU</strong></em> 算法移除 <em><strong>key</strong></em>。</p>
<p><em><strong>volatile-random</strong></em>：在过期集合中移除随机的 <em><strong>key</strong></em>，只对设置了过期时间的键。</p>
<p><em><strong>allkeys-random</strong></em>：在所有集合 <em><strong>key</strong></em> 中，移除随机的 <em><strong>key</strong></em>。</p>
<p><em><strong>volatile-ttl</strong></em>：移除那些 <em><strong>TTL</strong></em> 值最小的 <em><strong>key</strong></em>，即那些最近要过期的 <em><strong>key</strong></em>。</p>
<p><em><strong>noeviction</strong></em>：不进行移除。针对写操作，只是返回错误信息。</p>
<img src="  image-20230330143820057.png" alt="image-20230330143820057" style="zoom:50%;" />



<p><em><strong>maxmemory-samples</strong></em></p>
<p>设置样本数量，<em><strong>LRU</strong></em> 算法和最小 <em><strong>TTL</strong></em> 算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，<em><strong>redis</strong></em> 默认会检查这么多个 <em><strong>key</strong></em> 并选择其中 <em><strong>LRU</strong></em> 的那个。</p>
<p>一般设置 3 到 7 的数字，数值越小样本越不准确，但性能消耗越小。</p>
<img src="  image-20230330143840607.png" alt="image-20230330143840607" style="zoom:50%;" />
</blockquote>
<h1 id="5、Redis常用五大數據類型"><a href="#5、Redis常用五大數據類型" class="headerlink" title="5、Redis常用五大數據類型"></a>5、Redis常用五大數據類型</h1><h2 id="5-1-key操作"><a href="#5-1-key操作" class="headerlink" title="5.1 key操作"></a>5.1 key操作</h2><blockquote>
<p><code>keys *</code>：查看当前库所有 <em><strong>key</strong></em></p>
<p><code>exists key</code>：判断某个 <em><strong>key</strong></em> 是否存在</p>
<p><code>type key</code>：查看你的 <em><strong>key</strong></em> 是什么类型</p>
<p><code>del key</code> ：删除指定的 <em><strong>key</strong></em> 数据</p>
<p><code>unlink key</code>：根据 <em><strong>value</strong></em> 选择非阻塞删除，仅将 <em><strong>keys</strong></em> 从 <em><strong>keyspace</strong></em> 元数据中删除，真正的删除会在后续异步操作</p>
<p><code>expire key 10</code> ：为给定的 <em><strong>key</strong></em> 设置过期时间 (以秒為單位)</p>
<p><code>ttl key</code>：查看还有多少秒过期，-1表示永不过期，-2表示已过期</p>
<p><code>select</code>：命令切换数据库</p>
<p><code>dbsize</code>：查看当前数据库的 <em><strong>key</strong></em> 的数量</p>
<p><code>flushdb</code>：清空当前库 (慎用)</p>
<p><code>flushall</code>：通杀全部库 (慎用)</p>
</blockquote>
<h2 id="5-2-字符串（String）"><a href="#5-2-字符串（String）" class="headerlink" title="5.2 字符串（String）"></a>5.2 字符串（String）</h2><p><em><strong>String</strong></em> 类型是二进制安全的。意味着 <em><strong>Redis</strong></em> 的 <em><strong>string</strong></em> 可以包含任何数据。比如 <em><strong>jpg</strong></em> 图片或者序列化的对象。</p>
<p><em><strong>String</strong></em> 类型是 <em><strong>Redis</strong></em> 最基本的数据类型，一个 <em><strong>Redis</strong></em> 中字符串 <em><strong>value</strong></em> 最多可以是 512M。</p>
<p><a target="_blank" rel="noopener" href="https://www.modb.pro/db/53575">【更多細節參考】聊聊 Redis 基本数据类型 String</a></p>
<blockquote>
<p><code>set &lt;key&gt;&lt;value&gt;</code>：添加键值对</p>
<p><code>get &lt;key&gt;</code>：查询对应键值</p>
<p><code>append &lt;key&gt;&lt;value&gt;</code>：将给定的 <em><strong>&lt;value&gt;</strong></em> 追加到原值的末尾</p>
<p><code>strlen &lt;key&gt;</code>：获得值的长度</p>
<p><code>setnx &lt;key&gt;&lt;value&gt;</code>：只有在 <em><strong>key</strong></em> 不存在时，设置 <em><strong>key</strong></em> 的值</p>
<p><code>incr &lt;key&gt;</code>：将 <em><strong>key</strong></em> 中储存的数字值增 1，只能对数字值操作，如果为空，新增值为 1（**<u>具有原子性</u>**）</p>
<p><code>decr &lt;key&gt;</code>：将 <em><strong>key</strong></em> 中储存的数字值减 1，只能对数字值操作，如果为空，新增值为 -1</p>
<p><code>incrby/decrby &lt;key&gt;&lt;步长&gt;</code>：将 <em><strong>key</strong></em> 中储存的数字值增减。自定义步长</p>
<p><code>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;</code> ：同时设置一个或多个 <em><strong>key-value</strong></em> 对</p>
<p><code>mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt;...</code>：同时获取一个或多个 <em><strong>value</strong></em></p>
<p><code>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;... </code>：同时设置一个或多个 <em><strong>key-value</strong></em> 对，当且仅当所有给定 <em><strong>key</strong></em> 都不存在</p>
<p><code>getrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;</code>：获得值的范围</p>
<p><code>setrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;</code>：用 <em><strong>&lt;value&gt;</strong></em> 覆写 <em><strong>&lt;key&gt;</strong></em> 所储存的字符串值</p>
<p><code>setex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;</code>：设置键值的同时，设置过期时间，单位秒。</p>
<p><code>getset &lt;key&gt;&lt;value&gt;</code>：以新换旧，设置了新值同时获得旧值。</p>
</blockquote>
<p><strong>原子性</strong></p>
<p>所谓 <strong>原子</strong> 操作是指不会被线程调度机制打断的操作；</p>
<p>这种操作一旦开始，就一直运行到结束，中间不会有任何 <em><strong>context switch</strong></em> （切换到另一个线程）。</p>
<ul>
<li><p>在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</p>
</li>
<li><p>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</p>
</li>
</ul>
<p><em><strong>Redis</strong></em> 单命令的原子性主要得益于 <em><strong>Redis</strong></em> 的单线程。</p>
<p><strong>数据结构</strong></p>
<p>内部结构实现上类似于 <em><strong>Java</strong></em> 的 <em><strong>ArrayList</strong></em>，采用预分配冗余空间的方式来减少内存的频繁分配.</p>
<img src="  image-20230330143851068.png" alt="image-20230330143851068" style="zoom:50%;" />



<h2 id="5-3-列表（List）"><a href="#5-3-列表（List）" class="headerlink" title="5.3 列表（List）"></a>5.3 列表（List）</h2><p><em><strong>Redis</strong></em> 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p>
<p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>
<img src="  image-20230330143857441.png" alt="image-20230330143857441" style="zoom:50%;" />



<blockquote>
<p><code>lpush/rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....</code>： 从左边/右边插入一个或多个值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lpush k1 v1 v2 v3</span><br><span class="line">lrange k1 0 -1</span><br><span class="line">输出：v3 v2 v1</span><br><span class="line"></span><br><span class="line">rpush k1 v1 v2 v3</span><br><span class="line">rrange k1 0 -1</span><br><span class="line">输出：v1 v2 v3</span><br></pre></td></tr></table></figure>

<p><code>lpop/rpop &lt;key&gt;</code>：从左边/右边吐出一个值。值在键在，值光键亡。</p>
<p><code>rpoplpush &lt;key1&gt;&lt;key2&gt;</code>：从 <em><strong>&lt;key1&gt;</strong></em> 列表右边吐出一个值，插到 <em><strong>&lt;key2&gt;</strong></em> 列表左边。</p>
<p><code>lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;</code>：按照索引下标获得元素（从左到右）</p>
<p><code>lrange mylist 0 -1  0</code>：左边第一个，-1右边第一个，（0 -1表示获取所有）</p>
<p><code>lindex &lt;key&gt;&lt;index&gt;</code>：按照索引下标获得元素（从左到右）</p>
<p><code>llen &lt;key&gt;</code>：获得列表长度</p>
<p><code>linsert &lt;key&gt; before/after &lt;value&gt;&lt;newvalue&gt;</code>：在 <em><strong>&lt;value&gt;</strong></em> 的前面/后面插入 <em><strong>&lt;newvalue&gt;</strong></em> 插入值</p>
<p><code>lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;</code>：从左边删除 <em><strong>n</strong></em> 个 <em><strong>value</strong></em>（从左到右）</p>
<p><code>lset&lt;key&gt;&lt;index&gt;&lt;value&gt;</code>：将列表 <em><strong>key</strong></em> 下标为 <em><strong>index</strong></em> 的值替换成 <em><strong>value</strong></em></p>
</blockquote>
<p><strong>数据结构</strong></p>
<p><em><strong>List</strong></em> 的数据结构为快速链表 <em><strong>quickList</strong></em>。</p>
<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 <em><strong>ziplist</strong></em>，也即是压缩列表。</p>
<p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p>
<p>当数据量比较多的时候才会改成 <em><strong>quicklist</strong></em>。</p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 <em><strong>int</strong></em> 类型的数据，结构上还需要两个额外的指针 <em><strong>prev</strong></em> 和 <em><strong>next</strong></em>。</p>
<p><em><strong>Redis</strong></em> 将链表和 <em><strong>ziplist</strong></em> 结合起来组成了 <em><strong>quicklist</strong></em>。也就是将多个 <em><strong>ziplist</strong></em> 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<img src="  image-20230330143906282.png" alt="image-20230330143906282" style="zoom:50%;" />



<h2 id="5-4-Set（集合）"><a href="#5-4-Set（集合）" class="headerlink" title="5.4 Set（集合）"></a>5.4 Set（集合）</h2><p><em><strong>Set</strong></em> 对外提供的功能与 <em><strong>List</strong></em> 类似列表的功能，特殊之处在于 <em><strong>Set</strong></em> 是可以 <strong><u>自动排重</u></strong> 的，当需要存储一个列表数据，又不希望出现重复数据时，<em><strong>Set</strong></em> 是一个很好的选择，并且 <em><strong>Set</strong></em> 提供了判断某个成员是否在一个 <em><strong>Set</strong></em> 集合内的重要接口，这个也是 <em><strong>List</strong></em> 所不能提供的。</p>
<p><em><strong>Redis</strong></em> 的 <em><strong>Set</strong></em> 是 <em><strong>String</strong></em> 类型的无序集合。它底层其实是一个 <em><strong>value</strong></em> 为 <em><strong>null</strong></em> 的 <em><strong>hash</strong></em> 表，所以添加，删除，查找的复杂度都是 ***O(1)***。</p>
<p>一个算法，随着数据的增加，执行时间的长短，如果是 ***O(1)***，数据增加，查找数据的时间不变。</p>
<blockquote>
<p><code>sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ..... </code>：将一个或多个 <em><strong>member</strong></em> 元素加入到集合 <em><strong>key</strong></em> 中，已经存在的 <em><strong>member</strong></em> 元素将被忽略</p>
<p><code>smembers &lt;key&gt;</code>：取出该集合的所有值。</p>
<p><code>sismember &lt;key&gt;&lt;value&gt;</code>：判断集合 <em><strong>&lt;key&gt;</strong></em> 是否为含有该 <em><strong>&lt;value&gt;</strong></em> 值，有返回 1，没有返回 0</p>
<p><code>scard&lt;key&gt;</code>：返回该集合的元素个数。</p>
<p><code>srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ....</code>：删除集合中的某个元素</p>
<p><code>spop &lt;key&gt;</code>：随机从该集合中吐出一个值</p>
<p><code>srandmember &lt;key&gt;&lt;n&gt;</code>：随机从该集合中取出 <em><strong>n</strong></em> 个值，不会从集合中删除</p>
<p><code>smove &lt;source&gt;&lt;destination&gt;value</code>：把集合中一个值从一个集合移动到另一个集合</p>
<p><code>sinter &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的交集元素</p>
<p><code>sunion &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的聯集元素</p>
<p><code>sdiff &lt;key1&gt;&lt;key2&gt;</code>：返回两个集合的差集元素（<em><strong>key1</strong></em> 中的，不包含 <em><strong>key2</strong></em> 中的）</p>
</blockquote>
 <img src="  image-20230330114917788.png" alt="image-20230330114917788" style="zoom:67%;" />



<p><strong>数据结构</strong></p>
<p><em><strong>Set</strong></em> 数据结构是字典，字典是用哈希表实现的。</p>
<h2 id="5-5-Hash（哈希）"><a href="#5-5-Hash（哈希）" class="headerlink" title="5.5 Hash（哈希）"></a>5.5 Hash（哈希）</h2><p><em><strong>Redis hash</strong></em> 是一个键值对集合。</p>
<p><em><strong>Redis hash</strong></em> 是一个 <em><strong>String</strong></em> 类型的 <em><strong>field</strong></em> 和 <em><strong>value</strong></em> 的映射表，<em><strong>hash</strong></em> 特别适合用于存储对象。</p>
<blockquote>
<p><code>hset &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：给 <em><strong>&lt;key&gt;</strong></em> 集合中的 <em><strong>&lt;field&gt;</strong></em> 键赋值 <em><strong>&lt;value&gt;</strong></em></p>
<p><code>hget &lt;key1&gt;&lt;field&gt;</code>：从 <em><strong>&lt;key1&gt;</strong></em> 集合 <em><strong>&lt;field&gt;</strong></em> 取出 <em><strong>value</strong></em></p>
<p><code>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...</code>： 批量设置 <em><strong>hash</strong></em> 的值</p>
<p><code>hexists &lt;key1&gt;&lt;field&gt;</code>：查看哈希表 <em><strong>key</strong></em> 中，给定域 <em><strong>field</strong></em> 是否存在</p>
<p><code>hkeys &lt;key&gt;</code>：列出该 <em><strong>hash</strong></em> 集合的所有 <em><strong>field</strong></em></p>
<p><code>hvals &lt;key&gt;</code>：列出该 <em><strong>hash</strong></em> 集合的所有 <em><strong>value</strong></em></p>
<p><code>hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;</code>：为哈希表 <em><strong>key</strong></em> 中的域 <em><strong>field</strong></em> 的值加上增量 1  -1</p>
<p><code>hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;</code>：将哈希表 <em><strong>key</strong></em> 中的域 <em><strong>field</strong></em> 的值设置为 <em><strong>value</strong></em> ，当且仅当域 <em><strong>field</strong></em> 不存在</p>
</blockquote>
<p><strong>数据结构</strong></p>
<p><em><strong>Hash</strong></em> 类型对应的数据结构是两种：<em><strong>ziplist</strong></em>（压缩列表），<em><strong>hashtable</strong></em>（哈希表）。</p>
<p>当 <em><strong>field-value</strong></em> 长度较短且个数较少时，使用 <em><strong>ziplist</strong></em>，否则使用 <em><strong>hashtable</strong></em>。</p>
<h2 id="5-6-Zset（有序集合）"><a href="#5-6-Zset（有序集合）" class="headerlink" title="5.6 Zset（有序集合）"></a>5.6 Zset（有序集合）</h2><p><em><strong>Redis</strong></em> 有序集合 <em><strong>zset</strong></em> 与普通集合 <em><strong>set</strong></em> 非常相似，是一个没有重复元素的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个评分（<em><strong>score</strong></em>）,这个评分（<em><strong>score</strong></em>）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复的。</p>
<p>因为元素是有序的，所以可以很快的根据评分（<em><strong>score</strong></em>）或者次序（<em><strong>position</strong></em>）来获取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。</p>
<blockquote>
<p><code>zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…</code>：将一个或多个 <em><strong>member</strong></em> 元素及其 <em><strong>score</strong></em> 值加入到有序集 <em><strong>key</strong></em> 当中</p>
<p><code>zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES]  </code>：返回有序集 <em><strong>key</strong></em> 中，下标在 <em><strong>&lt;start&gt;&lt;stop&gt;</strong></em> 之间的元素</p>
<p>当带 <em><strong>WITHSCORES</strong></em>，可以让分数一起和值返回到结果集</p>
<p><code>zrangebyscore key min max [withscores] [limit offset count]</code>：返回有序集 <em><strong>key</strong></em> 中，所有 <em><strong>score</strong></em> 值介于 <em><strong>min</strong></em> 和 <em><strong>max</strong></em> 之间（包括等于 <em><strong>min</strong></em> 或 <em><strong>max</strong></em> ）的成员。有序集成员按 <em><strong>score</strong></em> 值递增（从小到大）次序排列。</p>
<p><code>zrevrangebyscore key max min [withscores] [limit offset count] </code>：同上，改为从大到小排列</p>
<p><code>zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;</code>：为元素的 <em><strong>score</strong></em> 加上增量</p>
<p><code>zrem &lt;key&gt;&lt;value&gt;</code>：删除该集合下，指定值的元素</p>
<p><code>zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;</code>：统计该集合，分数区间内的元素个数</p>
<p><code>zrank &lt;key&gt;&lt;value&gt;</code>：返回该值在集合中的排名，从 0 开始。</p>
</blockquote>
<p><strong>数据结构</strong></p>
<p><em><strong>SortedSet（zset）</strong></em>是 <em><strong>Redis</strong></em> 提供的一个非常特别的数据结构，一方面它等价于 <em><strong>Java</strong></em> 的数据结构 ***Map&lt;String, Double&gt;***，可以给每一个元素 <em><strong>value</strong></em> 赋予一个权重 <em><strong>score</strong></em>，另一方面它又类似于 <em><strong>TreeSet</strong></em>，内部的元素会按照权重 <em><strong>score</strong></em> 进行排序，可以得到每个元素的名次，还可以通过 <em><strong>score</strong></em> 的范围来获取元素的列表。</p>
<p><em><strong>zset</strong></em> 底层使用了两个数据结构</p>
<ul>
<li><p><em><strong>hash</strong></em>，<em><strong>hash</strong></em> 的作用就是关联元素 <em><strong>value</strong></em> 和权重 <em><strong>score</strong></em>，保障元素 <em><strong>value</strong></em> 的唯一性，可以通过元素 <em><strong>value</strong></em> 找到相应的 <em><strong>score</strong></em> 值</p>
</li>
<li><p>跳跃表，跳跃表的目的在于给元素 <em><strong>value</strong></em> 排序，根据 <em><strong>score</strong></em> 的范围获取元素列表</p>
</li>
</ul>
<h1 id="6、Redis6新数据结构"><a href="#6、Redis6新数据结构" class="headerlink" title="6、Redis6新数据结构"></a>6、Redis6新数据结构</h1><h3 id="6-1-Bitmaps"><a href="#6-1-Bitmaps" class="headerlink" title="6.1 Bitmaps"></a>6.1 Bitmaps</h3><p>Redis 提供了 Bitmaps 这个 “数据类型” 可以实现对位的操作：</p>
<ul>
<li><p>Bitmaps 本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</p>
</li>
<li><p>Bitmaps 单独提供了一套命令， 所以在 Redis 中使用 Bitmaps 和使用字符串的方法不太相同。 可以把 Bitmaps 想象成一个以位为单位的数组， 数组的每个单元只能存储 0 和 1， 数组的下标在 Bitmaps 中叫做偏移量。</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/b954d034b3204dd38f2201893a7097cf.jpeg" alt="在这里插入图片描述"></p>
</li>
</ul>
<h4 id="6-1-1-Bitmaps-与-set-对比"><a href="#6-1-1-Bitmaps-与-set-对比" class="headerlink" title="6.1.1 Bitmaps 与 set 对比"></a>6.1.1 <strong>Bitmaps</strong> 与 set 对比</h4><p>假设网站有 1 亿用户， 每天独立访问的用户有 5 千万， 如果每天用集合类型和 Bitmaps 分别存储活跃用户可以得到表：</p>
<table>
<thead>
<tr>
<th>set 和 Bitmaps 存储一天活跃用户对比</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>每个用户 id 占用空间</td>
<td>需要存储的用户量</td>
<td>全部内存量</td>
</tr>
<tr>
<td>集合</td>
<td>64 位</td>
<td>50000000</td>
<td>64 位 * 50000000 = 400MB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1 位</td>
<td>100000000</td>
<td>1 位 * 100000000 = 12.5MB</td>
</tr>
</tbody></table>
<p>很明显， 这种情况下使用 Bitmaps 能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的。</p>
<table>
<thead>
<tr>
<th>set 和 Bitmaps 存储独立用户空间对比</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>一天</td>
<td>一个月</td>
<td>一年</td>
</tr>
<tr>
<td>集合</td>
<td>400MB</td>
<td>12GB</td>
<td>144GB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>12.5MB</td>
<td>375MB</td>
<td>4.5GB</td>
</tr>
</tbody></table>
<p>但 Bitmaps 并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有 10 万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用 Bitmaps 就不太合适了， 因为基本上大部分位都是 0。</p>
<table>
<thead>
<tr>
<th>set 和 Bitmaps 存储一天活跃用户对比（用户比较少）</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>每个 userid 占用空间</td>
<td>需要存储的用户量</td>
<td>全部内存量</td>
</tr>
<tr>
<td>集合</td>
<td>64 位</td>
<td>100000</td>
<td>64 位 * 100000 = 800KB</td>
</tr>
<tr>
<td>Bitmaps</td>
<td>1 位</td>
<td>100000000</td>
<td>1 位 * 100000000 = 12.5MB</td>
</tr>
</tbody></table>
<h3 id="6-2-HyperLogLog"><a href="#6-2-HyperLogLog" class="headerlink" title="6.2 HyperLogLog"></a>6.2 <strong>HyperLogLog</strong></h3><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站 PV（PageView 页面访问量），可以使用 Redis 的 incr、incrby 轻松实现。但像 UV（UniqueVisitor 独立访客）、独立 IP 数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p>
<p>解决基数问题有很多种方案：</p>
<ol>
<li>数据存储在 MySQL 表中，使用 distinct count 计算不重复个数。</li>
<li>使用 Redis 提供的 hash、set、bitmaps 等数据结构来处理。</li>
</ol>
<p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。能否能够降低一定的精度来平衡存储空间？Redis 推出了 HyperLogLog。</p>
<ul>
<li>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是：在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</li>
<li>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</li>
<li>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</li>
</ul>
<p>什么是基数？</p>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}，那么这个数据集的基数集为 {1, 3, 5 ,7, 8}，基数 (不重复元素) 为 5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<h3 id="6-3-Geospatial"><a href="#6-3-Geospatial" class="headerlink" title="6.3 Geospatial"></a>6.3 Geospatial</h3><p>Redis 3.2 中增加了对 GEO 类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的 2 维坐标，在地图上就是经纬度。redis 基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度 Hash 等常见操作。</p>
<h1 id="7、Redis的发布与订阅"><a href="#7、Redis的发布与订阅" class="headerlink" title="7、Redis的发布与订阅"></a>7、Redis的发布与订阅</h1><p><em><strong>Redis</strong></em> 发布订阅（ <em><strong>pub/sub</strong></em> ）是一种消息通信模式：发送者（ <em><strong>pub</strong></em> ）发送消息，订阅者（ <em><strong>sub</strong></em> ）接收消息。</p>
<p><em><strong>Redis</strong></em> 客户端可以订阅任意数量的频道。</p>
<ol>
<li>客户端可以订阅频道</li>
</ol>
<img src="  image-20230330143920558.png" alt="image-20230330143920558" style="zoom:50%;" />



<ol start="2">
<li>当给这个频道发布消息后，消息就会发送给订阅的客户端</li>
</ol>
<img src="  image-20230330143933459.png" alt="image-20230330143933459" style="zoom:50%;" />



<blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel # 订阅频道</span><br><span class="line"></span><br><span class="line">publish channel hello # 频道发送信息</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="8、事务和锁机制"><a href="#8、事务和锁机制" class="headerlink" title="8、事务和锁机制"></a>8、事务和锁机制</h1><p><em><strong>Redis</strong></em> 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p><em><strong>Redis</strong></em> 事务的主要作用就是串联多个命令防止别的命令插队。</p>
<h2 id="8-1-Multi、Exec、Discard"><a href="#8-1-Multi、Exec、Discard" class="headerlink" title="8.1 Multi、Exec、Discard"></a>8.1 <em>Multi</em>、<em>Exec</em>、<em>Discard</em></h2><p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211113155415463-1656409103.png" alt="img"></p>
<blockquote>
<p><em><strong>Multi</strong></em></p>
<p><em><strong>Exec</strong></em></p>
<p><em><strong>Discard</strong></em></p>
<p>从输入 <em><strong>Multi</strong></em> 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 <em><strong>Exec</strong></em> 后，<em><strong>Redis</strong></em> 会将之前的命令队列中的命令依次执行。</p>
<p>组队的过程中可以通过 <em><strong>Discard</strong></em> 来放弃组队。</p>
</blockquote>
<ul>
<li><p>组队成功，提交成功</p>
<img src="  image-20230330143945601.png" alt="image-20230330143945601" style="zoom:50%;" /></li>
<li><p>放弃组队</p>
<img src="  image-20230330144000723.png" alt="image-20230330144000723" style="zoom:50%;" /></li>
<li><p>组队中有命令错误，不会执行</p>
<img src="  image-20230330144008039.png" alt="image-20230330144008039" style="zoom:50%;" /></li>
<li><p>组队中不报错，执行时报错</p>
<img src="  image-20230330144016472.png" alt="image-20230330144016472" style="zoom:50%;" /></li>
</ul>
<h2 id="8-2-事务的错误处理"><a href="#8-2-事务的错误处理" class="headerlink" title="8.2 事务的错误处理"></a>8.2 事务的错误处理</h2><ul>
<li>【錯誤狀況一】组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619094058710.png"><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/image-20210619094058710.png" alt="image-20210619094058710"></a></p>
<ul>
<li>【錯誤狀況二】如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619094201203.png"><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/image-20210619094201203.png" alt="image-20210619094201203"></a></p>
<h2 id="8-3-事务冲突的问题"><a href="#8-3-事务冲突的问题" class="headerlink" title="8.3 事务冲突的问题"></a>8.3 <strong>事务冲突的问题</strong></h2><h3 id="8-3-1-为什么要做成事务"><a href="#8-3-1-为什么要做成事务" class="headerlink" title="8.3.1 为什么要做成事务"></a>8.3.1 <strong>为什么要做成事务</strong></h3><p>想想一个场景：有很多人有你的账户，同时去参加双十一抢购。</p>
<p><strong>例子</strong></p>
<ul>
<li><p>一个请求想给金额减 8000；</p>
</li>
<li><p>一个请求想给金额减 5000；</p>
</li>
<li><p>一个请求想给金额减 1000。</p>
<p>最终我们可以发现，总共金额是 10000，如果请求全部执行，那最后的金额变为 - 4000，很明显不合理。</p>
</li>
</ul>
<blockquote>
<p>我們有下面兩種方式可以處理這個問題</p>
</blockquote>
<h4 id="1-悲观锁"><a href="#1-悲观锁" class="headerlink" title="1. 悲观锁"></a>1. 悲观锁</h4><p>悲观锁（<em><strong>Pessimistic Lock</strong></em>），即每次去拿数据的时候都认为有其他线程会修改，所以每次在拿数据的时候都会上锁，这样其他线程想要拿到这个数据就会被 <em><strong>block</strong></em> 直到成功拿到锁。（效率低）</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/image-20230330201343058.png" alt="image-20230330201343058"></p>
<h4 id="2-乐观锁"><a href="#2-乐观锁" class="headerlink" title="2. 乐观锁"></a>2. 乐观锁</h4><p>乐观锁（<em><strong>Optimistic Lock</strong></em>），即每次去拿数据的时候都认为其他线程不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间有没有其他线程去更新这个数据，可以使用版本号等机制。</p>
<p><strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。</p>
<p><em><strong>Redis</strong></em> 就是利用这种 <em><strong>check-and-set</strong></em> 机制实现事务的。</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/image-20230330201410223.png" alt="image-20230330201410223"></p>
<h4 id="3-Watch、unwatch-實現樂觀鎖"><a href="#3-Watch、unwatch-實現樂觀鎖" class="headerlink" title="3. Watch、unwatch 實現樂觀鎖"></a>3. <em>Watch、unwatch</em> 實現樂觀鎖</h4><p>在执行 <em><strong>multi</strong></em> 之前，先执行 <em><strong>watch key1 [key2]<em><strong>，可以监视一个（或多个 ）</strong></em>key</strong></em> 。如果在事务执行之前这个 <em><strong>key</strong></em> 被其他命令所改动，那么事务将被打断。</p>
<p>取消 <em><strong>WATCH</strong></em> 命令对所有 <em><strong>key</strong></em> 的监视。如果在执行 <em><strong>WATCH</strong></em> 命令之后，<em><strong>EXEC</strong></em> 命令或 <em><strong>DISCARD</strong></em> 命令先被执行，那么就不需要再执行 <em><strong>UNWATCH</strong></em> 。</p>
<h3 id="8-3-2-事务三特性"><a href="#8-3-2-事务三特性" class="headerlink" title="8.3.2 事务三特性"></a>8.3.2 事务三特性</h3><ul>
<li><p>单独的隔离操作</p>
<p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
<li><p>没有隔离级别的概念</p>
<p>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</p>
</li>
<li><p>不保证原子性</p>
<p>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 。</p>
</li>
</ul>
<h2 id="8-4-Redis-事务秒杀案例"><a href="#8-4-Redis-事务秒杀案例" class="headerlink" title="8.4 Redis_事务秒杀案例"></a>8.4 Redis_事务秒杀案例</h2><h3 id="8-4-1-解决计数器和人员记录的事务操作"><a href="#8-4-1-解决计数器和人员记录的事务操作" class="headerlink" title="8.4.1 解决计数器和人员记录的事务操作"></a>8.4.1 <strong>解决计数器和人员记录的事务操作</strong></h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619095633057.png"><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/image-20210619095633057.png" alt="image-20210619095633057"></a></p>
<h3 id="8-4-2-Redis-事务-—-秒杀并发模拟"><a href="#8-4-2-Redis-事务-—-秒杀并发模拟" class="headerlink" title="8.4.2 Redis 事务 — 秒杀并发模拟"></a>8.4.2 Redis 事务 — 秒杀并发模拟</h3><blockquote>
<p><strong>使用工具 ab 模拟测试：</strong></p>
<ul>
<li>CentOS6 默认安装</li>
<li>CentOS7 需要手动安装</li>
</ul>
</blockquote>
<p>linux下使用指令<code>yum install httpd-tools</code>安裝</p>
<ul>
<li><strong>通过 ab 测试高併發場景</strong></li>
</ul>
<p>im postfile 模拟表单提交参数， 以 &amp; 符号结尾，存放当前目录。</p>
<p>内容：prodid=0101&amp;</p>
<p>执行：ab -n 2000 -c 200 -k -p ~/postfile -T application/x-www-form-urlencoded</p>
<p>访问：<a target="_blank" rel="noopener" href="http://192.168.2.115:8081/Seckill/doseckill">http://192.168.2.115:8081/Seckill/doseckill</a></p>
<ul>
<li><strong>發現超卖問題</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100129431.png"><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/image-20210619100129431.png" alt="image-20210619100129431"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100138313.png"><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/image-20210619100138313.png" alt="image-20210619100138313"></a></p>
<h3 id="8-4-3-超卖问题"><a href="#8-4-3-超卖问题" class="headerlink" title="8.4.3 超卖问题"></a>8.4.3 超卖问题</h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100303067.png"><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/image-20210619100303067.png" alt="image-20210619100303067"></a></p>
<p><strong>利用乐观锁淘汰用户，解决超卖问题。</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100339429.png"><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/image-20210619100339429.png" alt="image-20210619100339429"></a></p>
<p><strong>主要代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">public class SecKill_redis &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Jedis jedis =new Jedis(&quot;192.168.44.168&quot;,6379);</span><br><span class="line">		System.out.println(jedis.ping());</span><br><span class="line">		jedis.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//秒杀过程</span><br><span class="line">	public static boolean doSecKill(String uid,String prodid) throws IOException &#123;</span><br><span class="line">		//1 uid和prodid非空判断</span><br><span class="line">		if(uid == null || prodid == null) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//2 连接redis</span><br><span class="line">		//Jedis jedis = new Jedis(&quot;192.168.44.168&quot;,6379);</span><br><span class="line">		//通过连接池得到jedis对象</span><br><span class="line">		JedisPool jedisPoolInstance = JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line">		Jedis jedis = jedisPoolInstance.getResource();</span><br><span class="line"></span><br><span class="line">		//3 拼接key</span><br><span class="line">		// 3.1 库存key</span><br><span class="line">		String kcKey = &quot;sk:&quot;+prodid+&quot;:qt&quot;;</span><br><span class="line">		// 3.2 秒杀成功用户key</span><br><span class="line">		String userKey = &quot;sk:&quot;+prodid+&quot;:user&quot;;</span><br><span class="line"></span><br><span class="line">		//监视库存</span><br><span class="line">		jedis.watch(kcKey);</span><br><span class="line"></span><br><span class="line">		//4 获取库存，如果库存null，秒杀还没有开始</span><br><span class="line">		String kc = jedis.get(kcKey);</span><br><span class="line">		if(kc == null) &#123;</span><br><span class="line">			System.out.println(&quot;秒杀还没有开始，请等待&quot;);</span><br><span class="line">			jedis.close();</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 5 判断用户是否重复秒杀操作</span><br><span class="line">		if(jedis.sismember(userKey, uid)) &#123;</span><br><span class="line">			System.out.println(&quot;已经秒杀成功了，不能重复秒杀&quot;);</span><br><span class="line">			jedis.close();</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//6 判断如果商品数量，库存数量小于1，秒杀结束</span><br><span class="line">		if(Integer.parseInt(kc)&lt;=0) &#123;</span><br><span class="line">			System.out.println(&quot;秒杀已经结束了&quot;);</span><br><span class="line">			jedis.close();</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//7 秒杀过程</span><br><span class="line">		//使用事务</span><br><span class="line">		Transaction multi = jedis.multi();</span><br><span class="line"></span><br><span class="line">		//组队操作</span><br><span class="line">		multi.decr(kcKey);</span><br><span class="line">		multi.sadd(userKey,uid);</span><br><span class="line"></span><br><span class="line">		//执行</span><br><span class="line">		List&lt;Object&gt; results = multi.exec();</span><br><span class="line"></span><br><span class="line">		if(results == null || results.size()==0) &#123;</span><br><span class="line">			System.out.println(&quot;秒杀失败了....&quot;);</span><br><span class="line">			jedis.close();</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//7.1 库存-1</span><br><span class="line">		//jedis.decr(kcKey);</span><br><span class="line">		//7.2 把秒杀成功用户添加清单里面</span><br><span class="line">		//jedis.sadd(userKey,uid);</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;秒杀成功了..&quot;);</span><br><span class="line">		jedis.close();</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619100941862.png"><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/image-20210619100941862.png" alt="image-20210619100941862"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619101004992.png"><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/image-20210619101004992.png" alt="image-20210619101004992"></a></p>
<h3 id="8-4-4-继续增加并发测试"><a href="#8-4-4-继续增加并发测试" class="headerlink" title="8.4.4 继续增加并发测试"></a>8.4.4 继续增加并发测试</h3><ul>
<li><strong>连接有限制</strong></li>
</ul>
<p>增加 - r 参数，-r Don’t exit on socket receive errors。</p>
<ul>
<li><strong>已经秒光，可是还有库存</strong></li>
</ul>
<p>已经秒光，可是还有库存。原因：乐观锁导致很多请求都失败。先点的没秒到，后点的可能秒到了。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619101322601.png"><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/image-20210619101322601.png" alt="image-20210619101322601"></a></p>
<ul>
<li><strong>连接超时，通过连接池解决</strong></li>
</ul>
<p>节省每次连接 redis 服务带来的消耗，把连接好的实例反复利用。通过参数管理连接的行为，代码见项目中：</p>
<p>连接池参数：</p>
<ul>
<li>MaxTotal：控制一个 pool 可分配多少个 jedis 实例，通过 pool.getResource () 来获取；如果赋值为 - 1，则表示不限制；如果 pool 已经分配了 MaxTotal 个 jedis 实例，则此时 pool 的状态为 exhausted。</li>
<li>maxIdle：控制一个 pool 最多有多少个状态为 idle (空闲) 的 jedis 实例；</li>
<li>MaxWaitMillis：表示当 borrow 一个 jedis 实例时，最大的等待毫秒数，如果超过等待时间，则直接抛 JedisConnectionException；</li>
<li>testOnBorrow：获得一个 jedis 实例的时候是否检查连接可用性（ping ()）；如果为 true，则得到的 jedis 实例均是可用的。</li>
</ul>
<h3 id="8-4-5-解决库存遗留问题"><a href="#8-4-5-解决库存遗留问题" class="headerlink" title="8.4.5 解决库存遗留问题"></a>8.4.5 <strong>解决库存遗留问题</strong></h3><p><strong>LUA 脚本在 Redis 中的优势</strong></p>
<ul>
<li>将复杂的或者多步的 redis 操作，写为一个脚本，一次提交给 redis 执行，减少反复连接 redis 的次数，提升性能。</li>
<li>LUA 脚本是类似 redis 事务，有一定的原子性，不会被其他命令插队，可以完成一些 redis 事务性的操作。</li>
<li>但是注意 redis 的 lua 脚本功能，只有在 Redis 2.6 以上的版本才可以使用。</li>
<li>利用 lua 脚本淘汰用户，解决超卖问题，redis 2.6 版本以后，通过 lua 脚本解决<strong>争抢问题</strong>，实际上是 <strong>redis</strong> <strong>利用其单线程的特性，用任务队列的方式解决多任务并发问题</strong>。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/zhangc233/pic@master/img/image-20210619101853376.png"><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/image-20210619101853376.png" alt="image-20210619101853376"></a></p>
<h1 id="9、持久化"><a href="#9、持久化" class="headerlink" title="9、持久化"></a>9、持久化</h1><h2 id="9-1-RDB"><a href="#9-1-RDB" class="headerlink" title="9.1 RDB"></a>9.1 RDB</h2><p>在指定的时间间隔内将内存中的数据集快照写入磁盘， 即 <em><strong>Snapshot</strong></em> 快照，恢复时是将快照文件直接读到内存里。</p>
<img src="  image-20230330144025395.png" alt="image-20230330144025395" style="zoom:50%;" />

<p><em><strong>Redis</strong></em> 会单独创建一个子进程（<em><strong>fork</strong></em>）来进行持久化。</p>
<p>先将数据写入到一个临时文件中，待持久化过程完成后，再将这个临时文件内容覆盖到 <em><strong>dump.rdb</strong></em>。</p>
<p>整个过程中，主进程是不进行任何 <em><strong>IO</strong></em> 操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 <em><strong>RDB</strong></em> 方式要比 <em><strong>AOF</strong></em> 方式更加的高效。</p>
<p><strong><em>RDB</em> 的缺点是最后一次持久化后的数据可能丢失</strong>。</p>
<h3 id="9-1-1-Fork"><a href="#9-1-1-Fork" class="headerlink" title="9.1.1 Fork"></a>9.1.1 Fork</h3><ul>
<li><p>作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</p>
</li>
<li><p>在 <em><strong>Linux</strong></em> 程序中，<em><strong>fork()</strong></em> 会产生一个和父进程完全相同的子进程，但子进程在此后多会 <em><strong>exec</strong></em> 系统调用，出于效率考虑，<em><strong>Linux</strong></em> 中引入了 <strong>写时复制技术</strong></p>
</li>
<li><p><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</p>
</li>
</ul>
<h3 id="9-1-2-配置"><a href="#9-1-2-配置" class="headerlink" title="9.1.2 配置"></a>9.1.2 配置</h3><blockquote>
<p><strong><em>dump</em> 文件名字</strong></p>
<p>在 <em><strong>redis.conf</strong></em> 中配置文件名称，默认为 <em><strong>dump.rdb</strong></em>。</p>
<img src="  image-20230330144033896.png" alt="image-20230330144033896" style="zoom:50%;" />



<p><strong><em>dump</em> 保存位置</strong></p>
<p><em><strong>rdb</strong></em> 文件的保存路径可以修改。默认为 <em><strong>Redis</strong></em> 启动时命令行所在的目录下。</p>
<img src="  image-20230330144040106.png" alt="image-20230330144040106" style="zoom:50%;" />



<p><em><strong>stop-writes-on-bgsave-error</strong></em></p>
<p>即当 <em><strong>redis</strong></em> 无法写入磁盘，关闭 <em><strong>redis</strong></em> 的写入操作。</p>
<img src="  image-20230330144044481.png" alt="image-20230330144044481" style="zoom:50%;" />



<p><em><strong>rdbcompression</strong></em></p>
<p>持久化的文件是否进行压缩存储。</p>
<img src="  image-20230330144051552.png" alt="image-20230330144051552" style="zoom:50%;" />



<p><em><strong>rdbchecksum</strong></em></p>
<p>完整性的检查，即数据是否完整性、准确性。</p>
<img src="  image-20230330144059410.png" alt="image-20230330144059410" style="zoom:50%;" />



<p><em><strong>save</strong></em></p>
<p>表示写操作的次数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：save 秒 写操作次数</span><br></pre></td></tr></table></figure>

<img src="  image-20230330144108058.png" alt="image-20230330144108058" style="zoom:50%;" />
</blockquote>
<h3 id="9-1-3-优点"><a href="#9-1-3-优点" class="headerlink" title="9.1.3 优点"></a>9.1.3 优点</h3><ul>
<li>适合大规模的数据恢复；</li>
<li>对数据完整性和一致性要求不高更适合使用；</li>
<li>节省磁盘空间；</li>
<li>恢复速度快。</li>
</ul>
<h3 id="9-1-4-缺点"><a href="#9-1-4-缺点" class="headerlink" title="9.1.4 缺点"></a>9.1.4 缺点</h3><ul>
<li><em><strong>Fork</strong></em> 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑；</li>
<li>虽然 <em><strong>Redis</strong></em> 在 <em><strong>fork</strong></em> 时使用了<strong>写时拷贝技术</strong>，但是如果数据庞大时还是比较消耗性能；</li>
<li>在备份周期在一定间隔时间做一次备份，所以如果 <em><strong>Redis</strong></em> 意外 <em><strong>down</strong></em> 掉的话，就会丢失最后一次快照后的所有修改。</li>
</ul>
<h2 id="9-2-AOF"><a href="#9-2-AOF" class="headerlink" title="9.2 AOF"></a>9.2 AOF</h2><p>以日志的形式来记录每个写操作（增量保存），将 <em><strong>Redis</strong></em> 执行过的所有写指令记录下来（读操作不记录）， <u>只许追加文件但不可以改写文件</u>，<em><strong>Redis</strong></em> 启动之初会读取该文件重新构建数据，换言之，如果 <em><strong>Redis</strong></em> 重启就会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<p><strong>执行流程</strong></p>
<ul>
<li><p>客户端的请求写命令会被 <em><strong>append</strong></em> 追加到 <em><strong>AOF</strong></em> 缓冲区内；</p>
</li>
<li><p><em><strong>AOF</strong></em> 缓冲区根据 <em><strong>AOF</strong></em> 持久化策略 <code>[always,everysec,no]</code> 将操作 <em><strong>sync</strong></em> 同步到磁盘的 <em><strong>AOF</strong></em> 文件中；</p>
</li>
<li><p><em><strong>AOF</strong></em> 文件大小超过重写策略或手动重写时，会对 <em><strong>AOF</strong></em> 文件 <em><strong>Rewrite</strong></em> 重写，压缩 <em><strong>AOF</strong></em> 文件容量；</p>
</li>
<li><p><em><strong>Redis</strong></em> 服务重启时，会重新 <em><strong>load</strong></em> 加载 <em><strong>AOF</strong></em> 文件中的写操作达到数据恢复的目的。</p>
</li>
</ul>
<p><em><strong>AOF</strong></em> 和 <em><strong>RDB</strong></em> 同时开启时，系统默认读取 <em><strong>AOF</strong></em> 的数据（数据不会存在丢失）</p>
<h3 id="9-2-1-配置"><a href="#9-2-1-配置" class="headerlink" title="9.2.1 配置"></a>9.2.1 配置</h3><blockquote>
<p><strong><em>AOF</em> 默认不开启</strong></p>
<img src="  image-20230330144115897.png" alt="image-20230330144115897" style="zoom:50%;" />



<p><strong>文件名字</strong></p>
<img src="  image-20230330144126527.png" alt="image-20230330144126527" style="zoom:50%;" />



<p><strong><em>AOF</em> 同步频率设置</strong></p>
<img src="  image-20230330144131810.png" alt="image-20230330144131810" style="zoom:50%;" />

<p><em><strong>appendfsync always</strong></em></p>
<p>​    始终同步，每次 <em><strong>Redis</strong></em> 的写入都会立刻记入日志；</p>
<p>​    性能较差但数据完整性比较好。</p>
<p><em><strong>appendfsync everysec</strong></em></p>
<p>​    每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p>
<p><em><strong>appendfsync no</strong></em></p>
<p>​    <em><strong>Redis</strong></em> 不主动进行同步，把同步时机交给操作系统。</p>
<p><strong><em>Rewrite</em> 压缩</strong></p>
<p>当 <em><strong>AOF</strong></em> 文件的大小超过所设定的阈值时，<em><strong>Redis</strong></em> 就会启动 <em><strong>AOF</strong></em> 文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令 <em><strong>bgrewriteaof</strong></em>。</p>
<img src="  image-20230330144139216.png" alt="image-20230330144139216" style="zoom:50%;" />
</blockquote>
<h3 id="9-2-2优点"><a href="#9-2-2优点" class="headerlink" title="9.2.2优点"></a>9.2.2优点</h3><ul>
<li>备份机制更稳健，丢失数据概率更低；</li>
<li>可读的日志文本，通过操作 <em><strong>AOF</strong></em> 稳健，可以处理误操作。</li>
</ul>
<h3 id="9-2-3-缺点"><a href="#9-2-3-缺点" class="headerlink" title="9.2.3 缺点"></a>9.2.3 缺点</h3><ul>
<li>比起 <em><strong>RDB</strong></em> 占用更多的磁盘空间；</li>
<li>恢复备份速度要慢；</li>
<li>每次读写都同步的话，有一定的性能压力；</li>
<li>存在个别 <em><strong>Bug</strong></em>，造成不能恢复。</li>
</ul>
<h2 id="9-3-选择"><a href="#9-3-选择" class="headerlink" title="9.3 选择"></a>9.3 选择</h2><blockquote>
<p>官方推荐两个都启用。</p>
<p>如果对数据不敏感，可以选单独用 <em><strong>RDB</strong></em>。</p>
<p>不建议单独用 <em><strong>AOF</strong></em>，因为可能会出现 <em><strong>Bug</strong></em>。</p>
<p>如果只是做纯内存缓存，可以都不用。</p>
</blockquote>
<h1 id="10、主从复制"><a href="#10、主从复制" class="headerlink" title="10、主从复制"></a>10、主从复制</h1><p>主机数据更新后根据配置和策略， 自动同步到备机的 <em><strong>master/slaver</strong></em> 机制，<em><strong>Master</strong></em> 以写为主，<em><strong>Slaver</strong></em> 以读为主。</p>
<p>功能：</p>
<ol>
<li>读写分离，性能扩展</li>
<li>容灾快速恢复</li>
</ol>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/image-20230331173945855.png" alt="image-20230331173945855"></p>
<h2 id="10-1-搭建一主两从"><a href="#10-1-搭建一主两从" class="headerlink" title="10.1 搭建一主两从"></a>10.1 搭建一主两从</h2><ol>
<li>创建文件目录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/etc</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将 <em><strong>redis.conf</strong></em> 复制到当前目录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/redis.conf /opt/etc/</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建 3 个 <em><strong>redis.conf</strong></em> 配置文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis6379.conf</span><br><span class="line">redis6380.conf</span><br><span class="line">redis6381.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis6379.conf</span></span><br><span class="line">include /opt/etc/redis.conf</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">port 6379</span><br><span class="line">dbfilename dump6379.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># redis6380.conf</span></span><br><span class="line">include /opt/etc/redis.conf</span><br><span class="line">pidfile /var/run/redis_6380.pid</span><br><span class="line">port 6380</span><br><span class="line">dbfilename dump6380.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># redis6381.conf</span></span><br><span class="line">include /opt/etc/redis.conf</span><br><span class="line">pidfile /var/run/redis_6381.pid</span><br><span class="line">port 6381</span><br><span class="line">dbfilename dump6381.rdb</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>启动 3 台 <em><strong>redis</strong></em> 服务器</li>
</ol>
<img src="  image-20230330144152165.png" alt="image-20230330144152165" style="zoom:50%;" />

<ol start="5">
<li>查看主机运行情况</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info replication</span><br></pre></td></tr></table></figure>

<img src="  image-20230330144157642.png" alt="image-20230330144157642" style="zoom:50%;" />

<ol start="6">
<li>配从不配主</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slaveof  &lt;ip&gt;&lt;port&gt;</span><br><span class="line"><span class="comment"># 成为某个实例的从服务器</span></span><br></pre></td></tr></table></figure>

<img src="  image-20230330144206596.png" alt="image-20230330144206596" style="zoom:50%;" />

<img src="  image-20230330144216201.png" alt="image-20230330144216201" style="zoom:50%;" />

<ol start="7">
<li>再次查看主机运行情况</li>
</ol>
<img src="  image-20230330144222545.png" alt="image-20230330144222545" style="zoom:50%;" />

<p>成功搭建。</p>
<h2 id="10-2-一主二从"><a href="#10-2-一主二从" class="headerlink" title="10.2 一主二从"></a>10.2 一主二从</h2><p>一主二從的特點演示如下：</p>
<blockquote>
<p>主机 <em><strong>6379</strong></em>，从机 <em><strong>6380</strong></em> 和 <em><strong>6381</strong></em>。</p>
<ol>
<li>假设从机 <em><strong>6380</strong></em> 挂掉。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当6380重启后，6380不再是6379的从机，而是作为新的master；</span><br><span class="line">当再次把6380作为6379的从机加入后，从机会把数据从头到尾复制。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>假设主机 <em><strong>6379</strong></em> 挂掉。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6380和6381仍然是6379的从机，不会做任何事；</span><br><span class="line">当6379重启后，既然是主服务器。</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="10-3-薪火相传"><a href="#10-3-薪火相传" class="headerlink" title="10.3 薪火相传"></a>10.3 薪火相传</h2><p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211113202916287-690809342.png" alt="img"></p>
<p>上一个 <em><strong>slave</strong></em> 可以是下一个 <em><strong>slave</strong></em> 的 <em><strong>master</strong></em>，<em><strong>slave</strong></em> 同样可以接收其他 <em><strong>slave</strong></em>的连接和同步请求，那么该 <em><strong>slave</strong></em> 作为了链条中下一个的 <em><strong>master</strong></em>，可以有效减轻 <em><strong>master</strong></em> 的写压力，去中心化降低风险。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;ip&gt;&lt;port&gt;</span><br></pre></td></tr></table></figure>

<p>中途变更转向：会清除之前的数据，重新建立拷贝最新的。</p>
<p>当某个 <em><strong>slave</strong></em> 宕机，后面的 <em><strong>slave</strong></em> 都没法备份。</p>
<p>即当主机挂掉，从机还是从机，但是无法继续写数据。</p>
<h2 id="10-4-反客为主"><a href="#10-4-反客为主" class="headerlink" title="10.4 反客为主"></a>10.4 反客为主</h2><p>当一个 <em><strong>master</strong></em> 宕机后，后面的 <em><strong>slave</strong></em> 可以立刻升为 <em><strong>master</strong></em>，其后面的 <em><strong>slave</strong></em> 不用做任何修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此方法須人工輸入才能由從機改為主機</p>
</blockquote>
<h2 id="10-5-哨兵模式"><a href="#10-5-哨兵模式" class="headerlink" title="10.5 哨兵模式"></a>10.5 哨兵模式</h2><p>**<font color=red>反客为主的自动版</font>**，即能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p>
<p>:bulb:SpringBoot整合Redis哨兵模式的配置詳見這兩篇</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904134181666824">1. SpringBoot结合Redis哨兵模式的实现</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ankeway/article/details/86544475">2. SpringBoot2.0默认使用Redis连接池的配置注意事项</a></p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211113204559803-571328236.png" alt="img"></p>
<ol>
<li>创建 <em><strong>sentinel.conf</strong></em> 文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/etc/sentinel.conf</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置哨兵</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 172.16.88.168 6379 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># mymaster：监控对象起的服务器名称</span></span><br><span class="line"><span class="comment"># 1：至少有多少个哨兵同意迁移的数量。 </span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动哨兵</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel  /opt/etc/sentinel.conf </span><br></pre></td></tr></table></figure>

<img src="  image-20230330144237383.png" alt="image-20230330144237383" style="zoom:50%;" />



<ul>
<li><p>主机挂掉，会从机选举中产生新的主机。选举的规则詳見[選舉規則](#10.5.1 选举规则)。</p>
</li>
<li><p>原本的主機重新上線後，會變為從機。</p>
</li>
</ul>
<h3 id="10-5-1-选举规则"><a href="#10-5-1-选举规则" class="headerlink" title="10.5.1 选举规则"></a>10.5.1 选举规则</h3><p>依下面順序進行選擇：</p>
<ol>
<li>根据<em><strong>优先级别</strong></em>：***slave-priority(舊版) / replica-priority(新版)***，优先选择优先级靠前的。</li>
</ol>
<img src="  image-20230330144243066.png" alt="image-20230330144243066" style="zoom:50%;" />

<ol start="2">
<li><p>根据<em><strong>偏移量</strong></em>：指获得原主机数据最全的比例，优先选择偏移量大的。</p>
</li>
<li><p>根据 <em><strong>runid</strong></em>：每个 redis 实例启动后都会随机生成一个 40 位的 runid，优先选择最小的服务。</p>
</li>
</ol>
<h3 id="10-5-2-复制延时問題"><a href="#10-5-2-复制延时問題" class="headerlink" title="10.5.2 复制延时問題"></a>10.5.2 复制延时問題</h3><p>由于所有的写操作都是先在 <em><strong>master</strong></em> 上操作，然后同步更新到 <em><strong>slave</strong></em> 上，所以从 <em><strong>master</strong></em> 同步到 <em><strong>slave</strong></em> 从机有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，<em><strong>slave</strong></em> 机器数量的增加也会使这个问题更加严重。</p>
<h2 id="10-6-复制原理"><a href="#10-6-复制原理" class="headerlink" title="10.6 复制原理"></a>10.6 复制原理</h2><ul>
<li><p><em><strong>slave</strong></em> 启动成功连接到 <em><strong>master</strong></em> 后会发送一个 <em><strong>sync</strong></em> 命令（同步命令）。</p>
</li>
<li><p><em><strong>master</strong></em> 接到命令启动后台的存盘进程，对数据进行持久化操作，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<em><strong>master</strong></em> 将传送整个数据文件（<em><strong>rdb</strong></em>）到 <em><strong>slave</strong></em>，以完成一次完全同步。</p>
</li>
<li><p>当主服务进行写操作后，和从服务器进行数据同步。</p>
</li>
<li><p>全量复制：而 <em><strong>slave</strong></em> 服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
</li>
<li><p>增量复制：<em><strong>master</strong></em> 继续将新的所有收集到的修改命令依次传给 <em><strong>slave</strong></em>，完成同步。</p>
</li>
<li><p>只要是重新连接 <em><strong>master</strong></em>，一次完全同步（全量复制）将被自动执行。</p>
</li>
</ul>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/image-20230331224840464.png" alt="image-20230331224840464"></p>
<h1 id="11、集群"><a href="#11、集群" class="headerlink" title="11、集群"></a>11、集群</h1><p>容量不够，<em><strong>redis</strong></em> 如何进行扩容？</p>
<p>并发写操作， <em><strong>redis</strong></em> 如何分摊？</p>
<p>主从模式，薪火相传模式，主机宕机，导致 <em><strong>ip</strong></em> 地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p>
<p>解决方法：</p>
<ul>
<li><p>代理主机（ <em><strong>之前</strong></em> ）</p>
<img src="  image-20230330144250098.png" style="zoom:50%;" /></li>
<li><p>无中心化集群配置（ <em><strong>redis3.0</strong></em> ）</p>
</li>
</ul>
<img src="  image-20230330144303739.png" alt="image-20230330144303739" style="zoom:50%;" />



<p><em><strong>Redis</strong></em> 集群实现了对 <em><strong>Redis</strong></em> 的水平扩容，即启动 <em><strong>N</strong></em> 个 <em><strong>Redis</strong></em> 节点，将整个数据库分布存储在这 <em><strong>N</strong></em> 个节点中，每个节点存储总数据的 <em><strong>1/N</strong></em> 。</p>
<p><em><strong>Redis</strong></em> 集群通过分区（<em><strong>partition</strong></em>）来提供一定程度的可用性（<em><strong>availability</strong></em>），即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>
<h2 id="11-1-搭建-Redis-集群"><a href="#11-1-搭建-Redis-集群" class="headerlink" title="11.1 搭建 Redis 集群"></a>11.1 搭建 <em>Redis</em> 集群</h2><ol>
<li>创建配置文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以redis6379.conf为例</span></span><br><span class="line">include /opt/etc/redis.conf</span><br><span class="line">pidfile /var/run/redis_6379.pid <span class="comment"># 更改</span></span><br><span class="line">port 6379 <span class="comment"># 更改</span></span><br><span class="line">dbfilename dump6379.rdb <span class="comment"># 更改</span></span><br><span class="line">cluster-enabled <span class="built_in">yes</span> <span class="comment"># 打开集群模式</span></span><br><span class="line">cluster-config-file nodes-6379.conf <span class="comment"># 设置节点配置文件名称，需要更改</span></span><br><span class="line">cluster-node-timeout 15000 <span class="comment"># 设置节点失联事件，超过该时间（ms），集群自动进行主从切换</span></span><br></pre></td></tr></table></figure>

<img src="  image-20230330144312096.png" alt="image-20230330144312096" style="zoom:50%;" />

<ol start="2">
<li>启动</li>
</ol>
<img src="  image-20230330144316838.png" alt="image-20230330144316838" style="zoom:50%;" />

<ol start="3">
<li>将 6 个节点合成一个集群</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 组合之前请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。</span></span><br></pre></td></tr></table></figure>

<img src="  image-20230330144322927.png" alt="image-20230330144322927" style="zoom:50%;" />

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录，必須在此目錄下才可執行節點合成操作</span></span><br><span class="line">/opt/redis-6.2.6/src</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">redis-cli --cluster create --cluster-replicas 1 172.16.88.168:6379 172.16.88.168:6380 172.16.88.168:6381 172.16.88.168:6389 172.16.88.168:6390 172.16.88.168:6391</span><br></pre></td></tr></table></figure>

<img src="  image-20230330144333996.png" alt="image-20230330144333996" style="zoom:50%;" />

<ol start="4">
<li>使用集群策略连接</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p PORT <span class="comment">#連接方式要添加 -c 才是以集群方式連接</span></span><br><span class="line">cluster nodes <span class="comment"># 命令查看集群信息</span></span><br></pre></td></tr></table></figure>

<img src="  image-20230330144340548.png" alt="image-20230330144340548" style="zoom:50%;" />



<h2 id="11-2-集群常見问题"><a href="#11-2-集群常見问题" class="headerlink" title="11.2 集群常見问题"></a>11.2 集群常見问题</h2><h3 id="11-2-1-redis-cluster-如何分配这六个节点"><a href="#11-2-1-redis-cluster-如何分配这六个节点" class="headerlink" title="11.2.1 redis cluster 如何分配这六个节点?"></a>11.2.1 <em>redis cluster</em> 如何分配这六个节点?</h3><blockquote>
<p>一个集群至少要有三个主节点。</p>
<p>选项 <code>--cluster-replicas 1</code>，表示希望为集群中的每个主节点创建一个从节点。</p>
<p>分配原则尽量保证每个主数据库运行在不同的 <em><strong>IP</strong></em> 地址，每个从库和主库不在一个 <em><strong>IP</strong></em> 地址上。</p>
<img src="  image-20230330144350941.png" alt="image-20230330144350941" style="zoom:50%;" />
</blockquote>
<h3 id="11-2-2-什么是-slots？"><a href="#11-2-2-什么是-slots？" class="headerlink" title="11.2.2 什么是 slots？"></a>11.2.2 什么是 <em>slots</em>？</h3><img src="  image-20230330144357240.png" alt="image-20230330144357240" style="zoom:50%;" />

<img src="  image-20230330144402562.png" alt="image-20230330144402562" style="zoom:50%;" />

<blockquote>
<p>一个 <em><strong>Redis</strong></em> 集群包含 <em><strong>16384</strong></em> 个插槽（<em><strong>hash slot</strong></em>）， 数据库中的每个键都属于这 <em><strong>16384</strong></em> 个插槽的其中一个。</p>
<p>集群使用公式 <em><strong>CRC16(key) % 16384</strong></em> 来计算键 <em><strong>key</strong></em> 属于哪个槽， 其中 <em><strong>CRC16(key)</strong></em> 语句用于计算键 <em><strong>key</strong></em> 的 <em><strong>CRC16</strong></em> 校验和 。</p>
<p>集群中的每个节点负责处理一部分插槽。 例如， 如果一个集群可以有主节点， 其中：</p>
<ul>
<li>节点 <em><strong>A</strong></em> 负责处理 <em><strong>0</strong></em> 号至 <em><strong>5460</strong></em> 号插槽。</li>
<li>节点 <em><strong>B</strong></em> 负责处理 <em><strong>5461</strong></em> 号至 <em><strong>10922</strong></em> 号插槽。</li>
<li>节点 <em><strong>C</strong></em> 负责处理 <em><strong>10923</strong></em> 号至 <em><strong>16383</strong></em> 号插槽。</li>
</ul>
</blockquote>
<h3 id="11-2-3-如何在集群中存入值？"><a href="#11-2-3-如何在集群中存入值？" class="headerlink" title="11.2.3 如何在集群中存入值？"></a>11.2.3 如何在集群中存入值？</h3><blockquote>
<p>在 <em><strong>redis-cli</strong></em> 每次存入、查詢键值，<em><strong>redis</strong></em> 都会计算出该 <em><strong>key</strong></em> 应该送往的插槽，如果不是该客户端对应服务器的插槽，<em><strong>redis</strong></em> 会报错，并告知应前往的 <em><strong>redis</strong></em> 实例地址和端口。</p>
<blockquote>
<p><em><strong>redis-cli</strong></em> 客户端提供了 <em><strong>–c</strong></em> 参数实现自动重定向。</p>
<p>例如 <em><strong>redis-cli -c –p 6379</strong></em> 登入后，再存入、查询键值对可以自动重定向。</p>
</blockquote>
</blockquote>
<h3 id="11-2-4-如何查询集群中的值？"><a href="#11-2-4-如何查询集群中的值？" class="headerlink" title="11.2.4 如何查询集群中的值？"></a>11.2.4 如何查询集群中的值？</h3><blockquote>
<p>每个主机只能查询<em><strong>自己范围内部的插槽</strong></em>。</p>
<p><code>cluster keyslot &lt;key&gt;</code>：查询某个 <em><strong>key</strong></em> 的 **<em>slot</em> **。</p>
<p><code>cluster countkeysinslot &lt;slot&gt;</code>：查询某个 <em><strong>slot</strong></em> 是否有值。</p>
<p><code>CLUSTER GETKEYSINSLOT &lt;slot&gt;&lt;count&gt;</code>：返回 <em><strong>count</strong></em> 个 <em><strong>slot</strong></em> 槽中的键。</p>
</blockquote>
<h3 id="11-2-5-故障恢复？"><a href="#11-2-5-故障恢复？" class="headerlink" title="11.2.5 故障恢复？"></a>11.2.5 故障恢复？</h3><blockquote>
<p>如果主节点下线？从节点能否自动升为主节点？注意：<em><strong>15</strong></em> 秒超时。</p>
<img src="  image-20230330144409718.png" alt="image-20230330144409718" style="zoom:50%;" />

<ul>
<li>当 <em><strong>6379</strong></em> 挂掉后，<em><strong>6389</strong></em> 成为新的主机。</li>
</ul>
<p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p>
<ul>
<li>当 <em><strong>6379</strong></em> 重启后，<em><strong>6379</strong></em> 成为 <em><strong>6389</strong></em> 的从机。</li>
</ul>
<p>如果所有某一段插槽的主从节点都宕掉，<em><strong>redis</strong></em> 服务是否还能继续?</p>
<ul>
<li>如果某一段插槽的主从都挂掉，而 <em><strong>cluster-require-full-coverage=yes</strong></em>，那么 ，整个集群都挂掉。</li>
<li>如果某一段插槽的主从都挂掉，而 <em><strong>cluster-require-full-coverage=no</strong></em>，那么，该插槽数据全都不能使用，也无法存储。</li>
</ul>
<p><code>redis.conf</code> 中的参数 <code>cluster-require-full-coverage</code></p>
</blockquote>
<h2 id="11-3-优点"><a href="#11-3-优点" class="headerlink" title="11.3 优点"></a>11.3 优点</h2><ul>
<li>实现扩容；</li>
<li>分摊压力；</li>
<li>无中心配置相对简单。</li>
</ul>
<h2 id="11-4-缺点"><a href="#11-4-缺点" class="headerlink" title="11.4 缺点"></a>11.4 缺点</h2><ul>
<li>多键操作是不被支持的；(硬要使用，可利用分組方式儲存，不方便)</li>
<li>多键的 <em><strong>Redis</strong></em> 事务是不被支持的。<em><strong>lua</strong></em> 脚本不被支持；</li>
<li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至<em><strong>redis cluster</strong></em>，需要整体迁移而不是逐步过渡，复杂度较大。</li>
</ul>
<h1 id="12、Jedis操作Redis"><a href="#12、Jedis操作Redis" class="headerlink" title="12、Jedis操作Redis"></a>12、Jedis操作Redis</h1><p>即 <em><strong>Java</strong></em> 操作 <em><strong>Redis</strong></em>。</p>
<ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>连接 <em><strong>Redis</strong></em></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.57.101&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">pong</span> <span class="operator">=</span> jedis.ping();</span><br><span class="line">    System.out.println(<span class="string">&quot;连接成功：&quot;</span> + pong);</span><br><span class="line">    jedis.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>连接Redis的注意事项</li>
</ol>
<ul>
<li>禁用Linux的防火墙：Linux(CentOS7)里执行命令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop/disable firewalld.service   </span><br></pre></td></tr></table></figure>



<ul>
<li>redis.conf中注释掉bind 127.0.0.1 ,然后 protected-mode no</li>
</ul>
 <img src="  d1177c5a865346679b7765e4a94a63e8.png" alt="在这里插入图片描述" style="zoom:67%;" />

 <img src="  b674b31bbd174d3da8263be5c6f803a7.png" alt="在这里插入图片描述" style="zoom:67%;" />



<ul>
<li>最后重启redis服务</li>
</ul>
<blockquote>
<p><em><strong>Key</strong></em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jedis.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line">Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">System.out.println(keys.size());</span><br><span class="line"><span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(jedis.exists(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">System.out.println(jedis.ttl(<span class="string">&quot;k1&quot;</span>));                </span><br><span class="line">System.out.println(jedis.get(<span class="string">&quot;k1&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><em><strong>String</strong></em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jedis.mset(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;v2&quot;</span>,<span class="string">&quot;str3&quot;</span>,<span class="string">&quot;v3&quot;</span>);</span><br><span class="line">System.out.println(jedis.mget(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;str3&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><em><strong>List</strong></em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = jedis.lrange(<span class="string">&quot;mylist&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (String element : list) &#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>Set</strong></em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order01&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order02&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order03&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order04&quot;</span>);</span><br><span class="line">Set&lt;String&gt; smembers = jedis.smembers(<span class="string">&quot;orders&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String order : smembers) &#123;</span><br><span class="line">System.out.println(order);</span><br><span class="line">&#125;</span><br><span class="line">jedis.srem(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order02&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><em><strong>Hash</strong></em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jedis.hset(<span class="string">&quot;hash1&quot;</span>,<span class="string">&quot;userName&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">System.out.println(jedis.hget(<span class="string">&quot;hash1&quot;</span>,<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;telphone&quot;</span>,<span class="string">&quot;13810169999&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;abc@163.com&quot;</span>);</span><br><span class="line">jedis.hmset(<span class="string">&quot;hash2&quot;</span>,map);</span><br><span class="line">List&lt;String&gt; result = jedis.hmget(<span class="string">&quot;hash2&quot;</span>, <span class="string">&quot;telphone&quot;</span>,<span class="string">&quot;email&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String element : result) &#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>zset</strong></em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">100d</span>, <span class="string">&quot;z3&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">90d</span>, <span class="string">&quot;l4&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">80d</span>, <span class="string">&quot;w5&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">70d</span>, <span class="string">&quot;z6&quot;</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; zrange = jedis.zrange(<span class="string">&quot;zset01&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (String e : zrange) &#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="12-1-Jedis-主从复制"><a href="#12-1-Jedis-主从复制" class="headerlink" title="12.1 Jedis 主从复制"></a>12.1 <em>Jedis</em> 主从复制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JedisSentinelPool jedisSentinelPool=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  Jedis <span class="title function_">getJedisFromSentinel</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(jedisSentinelPool==<span class="literal">null</span>)&#123;</span><br><span class="line">    Set&lt;String&gt; sentinelSet=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    sentinelSet.add(<span class="string">&quot;172.16.88.168:26379&quot;</span>); <span class="comment">// 端口为sentinal</span></span><br><span class="line">    <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">    jedisPoolConfig.setMaxTotal(<span class="number">10</span>); <span class="comment">// 最大可用连接数</span></span><br><span class="line">    jedisPoolConfig.setMaxIdle(<span class="number">5</span>); <span class="comment">// 最大闲置连接数</span></span><br><span class="line">    jedisPoolConfig.setMinIdle(<span class="number">5</span>); <span class="comment">// 最小闲置连接数</span></span><br><span class="line">    jedisPoolConfig.setBlockWhenExhausted(<span class="literal">true</span>); <span class="comment">// 连接耗尽是否等待</span></span><br><span class="line">    jedisPoolConfig.setMaxWaitMillis(<span class="number">2000</span>); <span class="comment">// 等待时间</span></span><br><span class="line">    jedisPoolConfig.setTestOnBorrow(<span class="literal">true</span>); <span class="comment">// 取连接的时候进行测试</span></span><br><span class="line"></span><br><span class="line">    jedisSentinelPool=<span class="keyword">new</span> <span class="title class_">JedisSentinelPool</span>(<span class="string">&quot;mymaster&quot;</span>,sentinelSet,jedisPoolConfig); <span class="comment">// 服务主机名</span></span><br><span class="line">    <span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="12-2-集群的-Jedis-开发"><a href="#12-2-集群的-Jedis-开发" class="headerlink" title="12.2 集群的 Jedis 开发"></a>12.2 集群的 <em>Jedis</em> 开发</h2><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。</p>
<p>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisClusterTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">     Set&lt;HostAndPort&gt;set =<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;HostAndPort&gt;(); <span class="comment">//去中心化也可不用set，任選其中一台主機即可</span></span><br><span class="line">     set.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;172.16.88.168&quot;</span>,<span class="number">6379</span>)); <span class="comment">// 任何一个端口</span></span><br><span class="line">     <span class="type">JedisCluster</span> <span class="variable">jedisCluster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(set);</span><br><span class="line">     jedisCluster.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">     System.out.println(jedisCluster.get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="13、SpringBoot整合Redis"><a href="#13、SpringBoot整合Redis" class="headerlink" title="13、SpringBoot整合Redis"></a>13、SpringBoot整合Redis</h1><p>【參考SpringBoot2筆記】</p>
<h1 id="14、应用问题解决"><a href="#14、应用问题解决" class="headerlink" title="14、应用问题解决"></a>14、应用问题解决</h1><h2 id="14-1-缓存穿透"><a href="#14-1-缓存穿透" class="headerlink" title="14.1 缓存穿透"></a>14.1 缓存穿透</h2><h3 id="14-1-1-现象"><a href="#14-1-1-现象" class="headerlink" title="14.1.1 现象"></a>14.1.1 现象</h3><p><em><strong>key</strong></em> 对应的数据在数据源并不存在，每次针对此 <em><strong>key</strong></em> 的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。</p>
<p>比如用一个不存在的用户 <em><strong>id</strong></em> 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p>
<p>造成：</p>
<ol>
<li>应用服务器压力变大。</li>
<li><em><strong>redis</strong></em> 命中率下降 $\longrightarrow$ 查询数据库 。</li>
</ol>
<img src="  image-20230330144426310.png" alt="image-20230330144426310" style="zoom:50%;" />



<h3 id="14-1-2-如何解决"><a href="#14-1-2-如何解决" class="headerlink" title="14.1.2 如何解决"></a>14.1.2 如何解决</h3><ul>
<li><p><strong>对空值缓存</strong></p>
<p>如果一个查询返回的数据为空（不管是数据是否不存在），仍然把这个空结果（<em><strong>null</strong></em>）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。</p>
</li>
<li><p><strong>设置可访问的名单（白名单）：</strong></p>
<p>使用 <em><strong>bitmaps</strong></em> 类型定义一个可以访问的名单，名单 <em><strong>id</strong></em> 作为 <em><strong>bitmaps</strong></em> 的偏移量，每次访问和 <em><strong>bitmap</strong></em> 里面的 <em><strong>id</strong></em> 进行比较，如果访问 <em><strong>id</strong></em> 不在 <em><strong>bitmaps</strong></em> 里面，进行拦截，则不允许访问。</p>
</li>
<li><p><strong>采用布隆过滤器</strong></p>
<p>布隆过滤器（<em><strong>Bloom Filter</strong></em>）是1970年由布隆提出的。它实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数）。</p>
<p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<p>将所有可能存在的数据哈希到一个足够大的 <em><strong>bitmaps</strong></em> 中，一个一定不存在的数据会被这个 <em><strong>bitmaps</strong></em> 拦截掉，从而避免了对底层存储系统的查询压力。</p>
</li>
<li><p><strong>进行实时监控</strong></p>
<p>当发现 <em><strong>Redis</strong></em> 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</p>
</li>
</ul>
<h2 id="14-2-缓存击穿"><a href="#14-2-缓存击穿" class="headerlink" title="14.2 缓存击穿"></a>14.2 缓存击穿</h2><h3 id="14-2-1-现象"><a href="#14-2-1-现象" class="headerlink" title="14.2.1 现象"></a>14.2.1 现象</h3><p><em><strong>key</strong></em> 对应的数据存在，但在 <em><strong>redis</strong></em> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端<em><strong>DB</strong></em> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <em><strong>DB</strong></em> 压垮。</p>
<ol>
<li>数据库访问压力瞬间增大。</li>
<li><em><strong>redis</strong></em> 中没有出现大量 <em><strong>key</strong></em> 过期，<em><strong>redis</strong></em> 正常运行。</li>
<li>（即某个经常访问的 <em><strong>key</strong></em> 过期，突然有大量访问这个数据）</li>
</ol>
<img src="  image-20230330144432552.png" alt="image-20230330144432552" style="zoom:50%;" />



<h3 id="14-2-2-如何解决"><a href="#14-2-2-如何解决" class="headerlink" title="14.2.2 如何解决"></a>14.2.2 如何解决</h3><ul>
<li><p>预先设置热门数据</p>
<p>在 <em><strong>redis</strong></em> 高峰访问之前，把一些热门数据提前存入到 <em><strong>redis</strong></em> 里面，加大这些热门数据 <em><strong>key</strong></em> 的时长。</p>
</li>
<li><p>实时调整</p>
<p>现场监控哪些数据热门，实时调整 <em><strong>key</strong></em> 的过期时长。</p>
</li>
<li><p>使用锁</p>
</li>
</ul>
<h2 id="14-3-缓存雪崩"><a href="#14-3-缓存雪崩" class="headerlink" title="14.3 缓存雪崩"></a>14.3 缓存雪崩</h2><h3 id="14-3-1-现象"><a href="#14-3-1-现象" class="headerlink" title="14.3.1 现象"></a>14.3.1 现象</h3><p><em><strong>key</strong></em> 对应的数据存在，但在 <em><strong>redis</strong></em> 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端<em><strong>DB</strong></em> 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 <em><strong>DB</strong></em> 压垮。</p>
<p>缓存雪崩与缓存击穿的区别在于这里针对很多 <em><strong>key</strong></em> 缓存，前者则是某一个 <em><strong>key</strong></em>。</p>
<ol>
<li>数据库压力变大。</li>
<li>即极少的时间段，查询大量 <em><strong>key</strong></em> 的集中过期情况。</li>
</ol>
<h3 id="14-3-2-如何解决"><a href="#14-3-2-如何解决" class="headerlink" title="14.3.2 如何解决"></a>14.3.2 如何解决</h3><ul>
<li><p><strong>构建多级缓存架构</strong></p>
<p><em><strong>nginx</strong></em> 缓存 + <em><strong>redis</strong></em> 缓存 + 其他缓存（<em><strong>ehcache</strong></em>等）</p>
</li>
<li><p><strong>使用锁或队列：</strong></p>
<p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况。</p>
</li>
<li><p><strong>设置过期标志更新缓存：</strong></p>
<p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 <em><strong>key</strong></em> 的缓存。</p>
</li>
<li><p><strong>将缓存失效时间分散开：</strong></p>
<p>比如我们可以在原有的失效时间基础上增加一个随机值，比如 1～5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
</li>
</ul>
<h2 id="14-4-分布式锁"><a href="#14-4-分布式锁" class="headerlink" title="14.4 分布式锁"></a>14.4 分布式锁</h2><p>redis分布式鎖可參考下面網頁：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6936956908007850014">1. 七种方案！探讨Redis分布式锁的正确使用姿势 - 掘金 (juejin.cn)</a></p>
<p><a target="_blank" rel="noopener" href="http://kaito-kidd.com/2021/06/08/is-redis-distributed-lock-really-safe/">2. 深度剖析：Redis分布式锁到底安全吗？看完这篇文章彻底懂了！ | Kaito’s Blog (kaito-kidd.com)</a></p>
<h3 id="14-4-1-问题描述"><a href="#14-4-1-问题描述" class="headerlink" title="14.4.1 问题描述"></a>14.4.1 问题描述</h3><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p>
<p>分布式锁主流的实现方案：</p>
<ol>
<li><p>基于数据库实现分布式锁</p>
</li>
<li><p>基于缓存（Redis等）</p>
</li>
<li><p>基于Zookeeper</p>
</li>
</ol>
<p>每一种分布式锁解决方案都有各自的优缺点：</p>
<ol>
<li><p>性能：redis最高</p>
</li>
<li><p>可靠性：zookeeper最高</p>
</li>
</ol>
<p>这里，我们就基于redis实现分布式锁。</p>
<h3 id="14-4-2-解决方案：使用-redis-实现分布式锁"><a href="#14-4-2-解决方案：使用-redis-实现分布式锁" class="headerlink" title="14.4.2 解决方案：使用 redis 实现分布式锁"></a>14.4.2 解决方案：使用 redis 实现分布式锁</h3><p>redis:命令</p>
<h1 id="set-sku-1-info-“OK”-NX-PX-10000"><a href="#set-sku-1-info-“OK”-NX-PX-10000" class="headerlink" title="set sku:1:info “OK” NX PX 10000"></a>set sku:1:info “OK” NX PX 10000</h1><p>EX sec：设置键的过期时间为 sec 秒。set key value EX sec 效果等同于 setex key sec value</p>
<p>PX millis：设置键的过期时间为 millis 毫秒。 set key value PX millis 效果等同于 PSETEX key millis value</p>
<p>NX：只在键不存在时，才对键进行设置操作。 set key value NX 效果等同于 setnx key value</p>
<p>XX：只在键已经存在时，才对键进行设置操作</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115202159505-416815662.png" alt="img"></p>
<ol>
<li><p>多个客户端同时获取锁（setnx）</p>
</li>
<li><p>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</p>
</li>
<li><p>其他客户端等待重试</p>
</li>
</ol>
<p>锁一直没有释放，设置key的过期时间，自动释放</p>
<p>上锁之后突然出现异常，无法设置过期时间</p>
<p>上锁的同时设置过期时间</p>
<p><strong>set users 10 nx ex 12</strong></p>
<h4 id="14-4-2-1-编写代码"><a href="#14-4-2-1-编写代码" class="headerlink" title="14.4.2.1 编写代码"></a><strong>14.4.2.1 编写代码</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;testLock&quot;)</span><br><span class="line">public void testLock() &#123;</span><br><span class="line">    //1获取锁，setne</span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, &quot;111&quot;);</span><br><span class="line">    //2获取锁成功、查询num的值</span><br><span class="line">    if (lock) &#123;</span><br><span class="line">        Object value = redisTemplate.opsForValue().get(&quot;num&quot;);</span><br><span class="line">        //2.1判断num为空return</span><br><span class="line">        if (StringUtils.isEmpty(value)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //2.2有值就转成成int</span><br><span class="line">        int num = Integer.parseInt(value + &quot;&quot;);</span><br><span class="line">        //2.3把redis的num加1</span><br><span class="line">        redisTemplate.opsForValue().set(&quot;num&quot;, ++num);</span><br><span class="line">        //2.4释放锁，del</span><br><span class="line">        redisTemplate.delete(&quot;lock&quot;);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //3获取锁失败、每隔0.1秒再获取</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">            testLock();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>重启，服务集群，通过网关压力测试：</p>
<p>ab -n 5000 -c 100 <a target="_blank" rel="noopener" href="http://192.168.184.204:8080/redisTest/testLock">http://192.168.184.204:8080/redisTest/testLock</a></p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115203517302-1808528880.png" alt="img"></p>
<p>查看redis中num的值，基本实现</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115203525053-2121343349.png" alt="img"></p>
<p>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放</p>
<p>解决：设置过期时间，自动释放锁。</p>
<h4 id="14-4-2-2-优化之设置锁的过期时间"><a href="#14-4-2-2-优化之设置锁的过期时间" class="headerlink" title="14.4.2.2 优化之设置锁的过期时间"></a>14.4.2.2 优化之设置锁的过期时间</h4><p>设置过期时间有两种方式：</p>
<p>（1）首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</p>
<p>（2）在set时指定过期时间（推荐）</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115204002008-129055379.png" alt="img"></p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115204151804-40913090.png" alt="img"></p>
<p>设置过期时间</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115204238330-1867087825.png" alt="img"></p>
<p>压力测试肯定也没有问题</p>
<p><strong>问题</strong>：可能会<strong>释放其他服务器的锁</strong></p>
<ol>
<li><ol>
<li>A B C并发操作</li>
</ol>
</li>
<li>A执行，1上锁，2具体操作，此时服务器卡住，3超时自动释放锁</li>
<li>B抢到执行，1上锁，2具体操作，3途中A服务器恢复过来，进行删除锁操作，B的锁会被释放</li>
</ol>
<p>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115204448925-208828802.png" alt="img"></p>
<h4 id="14-4-2-3-优化之-UUID-防误删"><a href="#14-4-2-3-优化之-UUID-防误删" class="headerlink" title="14.4.2.3 优化之 UUID 防误删"></a>14.4.2.3 优化之 UUID 防误删</h4><p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115204601149-111808505.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;testLock&quot;)</span><br><span class="line">public void testLock() &#123;</span><br><span class="line">    //  1 获取锁，setne</span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;,uuid,3,TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    //  2 获取锁成功、查询num的值</span><br><span class="line">    if (lock) &#123;</span><br><span class="line">        Object value = redisTemplate.opsForValue().get(&quot;num&quot;);</span><br><span class="line">        // 2.1 判断num为空return</span><br><span class="line">        if (StringUtils.isEmpty(value)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.2 有值就转成成int</span><br><span class="line">        int num = Integer.parseInt(value + &quot;&quot;);</span><br><span class="line">        // 2.3 把redis的num加1</span><br><span class="line">        redisTemplate.opsForValue().set(&quot;num&quot;, ++num);</span><br><span class="line">        // 2.4 释放锁，del</span><br><span class="line">        String lockuuid = (String) redisTemplate.opsForValue().get(&quot;lock&quot;);</span><br><span class="line">        if (uuid.equals(lockuuid)) &#123;</span><br><span class="line">            redisTemplate.delete(&quot;lock&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 3 获取锁失败、每隔0.1秒再获取</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">            testLock();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>问题</strong>：<strong>删除操作缺乏原子性</strong></p>
<ol>
<li><ol>
<li>A B C并发操作</li>
</ol>
</li>
<li>A执行，1上锁，2具体操作，3超时判断uuid一致，正要释放锁的时候，锁已经过期自动删除</li>
<li>B抢到执行，1上锁，2具体操作，3途中A服务器执行删除操作，B的锁会被释放</li>
</ol>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115205050966-1370863749.png" alt="img"></p>
<h4 id="14-4-2-4-优化之LUA脚本保证删除的原子性"><a href="#14-4-2-4-优化之LUA脚本保证删除的原子性" class="headerlink" title="14.4.2.4 优化之LUA脚本保证删除的原子性"></a>14.4.2.4 优化之LUA脚本保证删除的原子性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;testLockLua&quot;)</span><br><span class="line">public void testLockLua() &#123;</span><br><span class="line">    // 1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中</span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    // 2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！</span><br><span class="line">    String skuId = &quot;25&quot;; // 访问skuId 为25号的商品 100008348542</span><br><span class="line">    String locKey = &quot;lock:&quot; + skuId; // 锁住的是每个商品的数据</span><br><span class="line"></span><br><span class="line">    // 3 获取锁</span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(locKey,uuid,3,TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    // 如果true</span><br><span class="line">    if (lock) &#123;</span><br><span class="line">        // 执行的业务逻辑开始</span><br><span class="line">        // 获取缓存中的num 数据</span><br><span class="line">        Object value = redisTemplate.opsForValue().get(&quot;num&quot;);</span><br><span class="line">        </span><br><span class="line">        // 如果是空直接返回</span><br><span class="line">        if (StringUtils.isEmpty(value)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int num = Integer.parseInt(value + &quot;&quot;);</span><br><span class="line">        // 使num 每次+1 放入缓存</span><br><span class="line">        redisTemplate.opsForValue().set(&quot;num&quot;, String.valueOf(++num));</span><br><span class="line">        </span><br><span class="line">        /*使用lua脚本来锁*/</span><br><span class="line">        // 定义lua 脚本</span><br><span class="line">        String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return &quot; +</span><br><span class="line">            &quot;redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;;</span><br><span class="line">        </span><br><span class="line">        // 使用redis执行lua执行</span><br><span class="line">        DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;();</span><br><span class="line">        redisScript.setScriptText(script);</span><br><span class="line">        </span><br><span class="line">        // 设置一下返回值类型 为Long</span><br><span class="line">        // 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，</span><br><span class="line">        // 那么返回字符串与0 会有发生错误。</span><br><span class="line">        redisScript.setResultType(Long.class);</span><br><span class="line">        </span><br><span class="line">        // 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。</span><br><span class="line">        redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 其他线程等待</span><br><span class="line">        try &#123;</span><br><span class="line">            // 睡眠</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            // 睡醒了之后，调用方法。</span><br><span class="line">            testLockLua();</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Lua 脚本详解：</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115205641281-2003977796.png" alt="img"></p>
<p>项目中正确使用</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115205727138-572310483.png" alt="img"></p>
<h4 id="14-4-2-5-总结"><a href="#14-4-2-5-总结" class="headerlink" title="14.4.2.5 总结"></a>14.4.2.5 总结</h4><p>（1）加锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 1. 从redis中获取锁,set k1 v1 px 20000 nxString uuid = UUID.randomUUID().toString();</span><br><span class="line">Boolean lock = this.redisTemplate.opsForValue().setIfAbsent(&quot;lock&quot;, uuid, 2, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>



<p>（2）使用 lua 锁释放锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 2. 释放锁 del</span><br><span class="line">String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;;</span><br><span class="line">// 设置lua脚本返回的数据类型</span><br><span class="line">DefaultRedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;();</span><br><span class="line">// 设置lua脚本返回类型为Long</span><br><span class="line">redisScript.setResultType(Long.class);</span><br><span class="line">redisScript.setScriptText(script);</span><br><span class="line">redisTemplate.execute(redisScript, Arrays.asList(&quot;lock&quot;),uuid);</span><br></pre></td></tr></table></figure>



<p>（3）重试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(500);</span><br><span class="line">testLock();</span><br></pre></td></tr></table></figure>



<p>为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p>
<ul>
<li>互斥性。在任意时刻，只有一个客户端能持有锁</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁</li>
<li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了</li>
<li>加锁和解锁必须具有原子性</li>
</ul>
<h1 id="15-Redis6-0-新功能"><a href="#15-Redis6-0-新功能" class="headerlink" title="15 Redis6.0 新功能"></a>15 Redis6.0 新功能</h1><h3 id="15-1-ACL"><a href="#15-1-ACL" class="headerlink" title="15.1 ACL"></a>15.1 ACL</h3><h4 id="15-1-1-简介"><a href="#15-1-1-简介" class="headerlink" title="15.1.1 简介"></a>15.1.1 简介</h4><p>Redis ACL是Access Control List（访问控制列表）的缩写，该功能允许根据可以执行的命令和可以访问的键来限制某些连接。</p>
<p>在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制 ：</p>
<p>（1）接入权限:用户名和密码</p>
<p>（2）可以执行的命令</p>
<p>（3）可以操作的 KEY</p>
<p>参考官网：<a target="_blank" rel="noopener" href="https://redis.io/topics/acl">https://redis.io/topics/acl</a></p>
<h4 id="15-1-2-命令"><a href="#15-1-2-命令" class="headerlink" title="15.1.2 命令"></a>15.1.2 命令</h4><p>（1）使用 acl list 命令展示用户权限列表</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115210054429-955343300.png" alt="img"></p>
<p>（2）使用acl cat命令</p>
<p>（a）查看添加权限指令类别</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115210230818-1938412945.png" alt="img"></p>
<p>（b） 加参数类型名可以查看类型下具体命令</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115210251500-824714787.png" alt="img"></p>
<p>（3）使用acl whoami命令查看当前用户</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115210322007-661283480.png" alt="img"></p>
<p>（4）使用aclsetuser命令创建和编辑用户ACL</p>
<p>（a）ACL规则</p>
<p>下面是有效ACL规则的列表。某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115210444143-948891383.png" alt="img"></p>
<p>（b）通过命令创建新用户默认权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl setuser user1</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115210527028-398268273.png" alt="img"></p>
<p>在上面的示例中，我根本没有指定任何规则。如果用户不存在，这将使用just created的默认属性来创建用户。如果用户已经存在，则上面的命令将不执行任何操作。</p>
<p>（c）设置有用户名、密码、ACL权限、并启用的用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acl setuser user2 on &gt;password ~cached:* +get</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115210615102-960159373.png" alt="img"></p>
<p>（d） 切换用户，验证权限</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115210635596-1358120892.png" alt="img"></p>
<h3 id="15-2-IO-多线程"><a href="#15-2-IO-多线程" class="headerlink" title="15.2 IO 多线程"></a>15.2 IO 多线程</h3><h4 id="15-2-1-简介"><a href="#15-2-1-简介" class="headerlink" title="15.2.1 简介"></a>15.2.1 简介</h4><p>Redis6终于支撑多线程了，告别单线程了吗？</p>
<p>IO多线程其实指<strong>客户端交互部分</strong>的<strong>网络IO</strong>交互处理模块<strong>多线程</strong>，而非<strong>执行命令多线程</strong>。Redis6执行命令依然是单线程。</p>
<h4 id="15-2-2-原理架构"><a href="#15-2-2-原理架构" class="headerlink" title="15.2.2 原理架构"></a>15.2.2 原理架构</h4><p>Redis 6 加入多线程,但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。整体的设计大体如下</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115210826479-1336942960.png" alt="img"></p>
<p>另外，多线程IO默认也是不开启的，需要再配置文件中配置</p>
<p>io-threads-do-reads  yes</p>
<p>io-threads 4</p>
<h3 id="15-3-工具支持-Cluster"><a href="#15-3-工具支持-Cluster" class="headerlink" title="15.3 工具支持 Cluster"></a>15.3 工具支持 <strong>Cluster</strong></h3><p>之前老版Redis想要搭集群需要单独安装ruby环境，Redis 5 将 redis-trib.rb 的功能集成到 redis-cli 。另外官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测</p>
<p><img src="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/1211355-20211115210920400-1156383469.png" alt="img"></p>
<h3 id="15-4-Redis-新功能持续关注"><a href="#15-4-Redis-新功能持续关注" class="headerlink" title="15.4 Redis 新功能持续关注"></a>15.4 Redis 新功能持续关注</h3><p>Redis6新功能还有：</p>
<p>1、RESP3新的 Redis 通信协议：优化服务端与客户端之间通信</p>
<p>2、Client side caching客户端缓存：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。</p>
<p>3、Proxy集群代理模式：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。</p>
<p>4、Modules API</p>
<p>Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。</p>

      
       <hr><span style="font-style: italic;color: gray;"> 轉載請注明來源，歡迎對文章中的引用來源進行考證，歡迎指出任何有錯誤或不夠清晰的表達。可以郵件至 b8954008@gmail.com </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2023-2030 Eker
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
